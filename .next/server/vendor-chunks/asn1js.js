"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/asn1js";
exports.ids = ["vendor-chunks/asn1js"];
exports.modules = {

/***/ "(rsc)/./node_modules/asn1js/build/index.js":
/*!********************************************!*\
  !*** ./node_modules/asn1js/build/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * Copyright (c) 2014, GMO GlobalSign\n * Copyright (c) 2015-2022, Peculiar Ventures\n * All rights reserved.\n * \n * Author 2014-2019, Yury Strozhevsky\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n * \n * * Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n * \n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(rsc)/./node_modules/pvtsutils/build/index.js\");\nvar pvutils = __webpack_require__(/*! pvutils */ \"(rsc)/./node_modules/pvutils/build/utils.js\");\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\nvar pvtsutils__namespace = /*#__PURE__*/ _interopNamespace(pvtsutils);\nvar pvutils__namespace = /*#__PURE__*/ _interopNamespace(pvutils);\nfunction assertBigInt() {\n    if (typeof BigInt === \"undefined\") {\n        throw new Error(\"BigInt is not defined. Your environment doesn't implement BigInt.\");\n    }\n}\nfunction concat(buffers) {\n    let outputLength = 0;\n    let prevLength = 0;\n    for(let i = 0; i < buffers.length; i++){\n        const buffer = buffers[i];\n        outputLength += buffer.byteLength;\n    }\n    const retView = new Uint8Array(outputLength);\n    for(let i = 0; i < buffers.length; i++){\n        const buffer = buffers[i];\n        retView.set(new Uint8Array(buffer), prevLength);\n        prevLength += buffer.byteLength;\n    }\n    return retView.buffer;\n}\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\n    if (!(inputBuffer instanceof Uint8Array)) {\n        baseBlock.error = \"Wrong parameter: inputBuffer must be 'Uint8Array'\";\n        return false;\n    }\n    if (!inputBuffer.byteLength) {\n        baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\n        return false;\n    }\n    if (inputOffset < 0) {\n        baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\n        return false;\n    }\n    if (inputLength < 0) {\n        baseBlock.error = \"Wrong parameter: inputLength less than zero\";\n        return false;\n    }\n    if (inputBuffer.byteLength - inputOffset - inputLength < 0) {\n        baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n        return false;\n    }\n    return true;\n}\nclass ViewWriter {\n    constructor(){\n        this.items = [];\n    }\n    write(buf) {\n        this.items.push(buf);\n    }\n    final() {\n        return concat(this.items);\n    }\n}\nconst powers2 = [\n    new Uint8Array([\n        1\n    ])\n];\nconst digitsString = \"0123456789\";\nconst NAME = \"name\";\nconst VALUE_HEX_VIEW = \"valueHexView\";\nconst IS_HEX_ONLY = \"isHexOnly\";\nconst ID_BLOCK = \"idBlock\";\nconst TAG_CLASS = \"tagClass\";\nconst TAG_NUMBER = \"tagNumber\";\nconst IS_CONSTRUCTED = \"isConstructed\";\nconst FROM_BER = \"fromBER\";\nconst TO_BER = \"toBER\";\nconst LOCAL = \"local\";\nconst EMPTY_STRING = \"\";\nconst EMPTY_BUFFER = new ArrayBuffer(0);\nconst EMPTY_VIEW = new Uint8Array(0);\nconst END_OF_CONTENT_NAME = \"EndOfContent\";\nconst OCTET_STRING_NAME = \"OCTET STRING\";\nconst BIT_STRING_NAME = \"BIT STRING\";\nfunction HexBlock(BaseClass) {\n    var _a;\n    return _a = class Some extends BaseClass {\n        constructor(...args){\n            var _a;\n            super(...args);\n            const params = args[0] || {};\n            this.isHexOnly = (_a = params.isHexOnly) !== null && _a !== void 0 ? _a : false;\n            this.valueHexView = params.valueHex ? pvtsutils__namespace.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;\n        }\n        get valueHex() {\n            return this.valueHexView.slice().buffer;\n        }\n        set valueHex(value) {\n            this.valueHexView = new Uint8Array(value);\n        }\n        fromBER(inputBuffer, inputOffset, inputLength) {\n            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\n            if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n                return -1;\n            }\n            const endLength = inputOffset + inputLength;\n            this.valueHexView = view.subarray(inputOffset, endLength);\n            if (!this.valueHexView.length) {\n                this.warnings.push(\"Zero buffer length\");\n                return inputOffset;\n            }\n            this.blockLength = inputLength;\n            return endLength;\n        }\n        toBER(sizeOnly = false) {\n            if (!this.isHexOnly) {\n                this.error = \"Flag 'isHexOnly' is not set, abort\";\n                return EMPTY_BUFFER;\n            }\n            if (sizeOnly) {\n                return new ArrayBuffer(this.valueHexView.byteLength);\n            }\n            return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;\n        }\n        toJSON() {\n            return {\n                ...super.toJSON(),\n                isHexOnly: this.isHexOnly,\n                valueHex: pvtsutils__namespace.Convert.ToHex(this.valueHexView)\n            };\n        }\n    }, _a.NAME = \"hexBlock\", _a;\n}\nclass LocalBaseBlock {\n    constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}){\n        this.blockLength = blockLength;\n        this.error = error;\n        this.warnings = warnings;\n        this.valueBeforeDecodeView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(valueBeforeDecode);\n    }\n    static blockName() {\n        return this.NAME;\n    }\n    get valueBeforeDecode() {\n        return this.valueBeforeDecodeView.slice().buffer;\n    }\n    set valueBeforeDecode(value) {\n        this.valueBeforeDecodeView = new Uint8Array(value);\n    }\n    toJSON() {\n        return {\n            blockName: this.constructor.NAME,\n            blockLength: this.blockLength,\n            error: this.error,\n            warnings: this.warnings,\n            valueBeforeDecode: pvtsutils__namespace.Convert.ToHex(this.valueBeforeDecodeView)\n        };\n    }\n}\nLocalBaseBlock.NAME = \"baseBlock\";\nclass ValueBlock extends LocalBaseBlock {\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\n    }\n    toBER(sizeOnly, writer) {\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\n    }\n}\nValueBlock.NAME = \"valueBlock\";\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {\n    constructor({ idBlock = {} } = {}){\n        var _a, _b, _c, _d;\n        super();\n        if (idBlock) {\n            this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;\n            this.valueHexView = idBlock.valueHex ? pvtsutils__namespace.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;\n            this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;\n            this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;\n            this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;\n        } else {\n            this.tagClass = -1;\n            this.tagNumber = -1;\n            this.isConstructed = false;\n        }\n    }\n    toBER(sizeOnly = false) {\n        let firstOctet = 0;\n        switch(this.tagClass){\n            case 1:\n                firstOctet |= 0x00;\n                break;\n            case 2:\n                firstOctet |= 0x40;\n                break;\n            case 3:\n                firstOctet |= 0x80;\n                break;\n            case 4:\n                firstOctet |= 0xC0;\n                break;\n            default:\n                this.error = \"Unknown tag class\";\n                return EMPTY_BUFFER;\n        }\n        if (this.isConstructed) firstOctet |= 0x20;\n        if (this.tagNumber < 31 && !this.isHexOnly) {\n            const retView = new Uint8Array(1);\n            if (!sizeOnly) {\n                let number = this.tagNumber;\n                number &= 0x1F;\n                firstOctet |= number;\n                retView[0] = firstOctet;\n            }\n            return retView.buffer;\n        }\n        if (!this.isHexOnly) {\n            const encodedBuf = pvutils__namespace.utilToBase(this.tagNumber, 7);\n            const encodedView = new Uint8Array(encodedBuf);\n            const size = encodedBuf.byteLength;\n            const retView = new Uint8Array(size + 1);\n            retView[0] = firstOctet | 0x1F;\n            if (!sizeOnly) {\n                for(let i = 0; i < size - 1; i++)retView[i + 1] = encodedView[i] | 0x80;\n                retView[size] = encodedView[size - 1];\n            }\n            return retView.buffer;\n        }\n        const retView = new Uint8Array(this.valueHexView.byteLength + 1);\n        retView[0] = firstOctet | 0x1F;\n        if (!sizeOnly) {\n            const curView = this.valueHexView;\n            for(let i = 0; i < curView.length - 1; i++)retView[i + 1] = curView[i] | 0x80;\n            retView[this.valueHexView.byteLength] = curView[curView.length - 1];\n        }\n        return retView.buffer;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n            return -1;\n        }\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n        if (intBuffer.length === 0) {\n            this.error = \"Zero buffer length\";\n            return -1;\n        }\n        const tagClassMask = intBuffer[0] & 0xC0;\n        switch(tagClassMask){\n            case 0x00:\n                this.tagClass = 1;\n                break;\n            case 0x40:\n                this.tagClass = 2;\n                break;\n            case 0x80:\n                this.tagClass = 3;\n                break;\n            case 0xC0:\n                this.tagClass = 4;\n                break;\n            default:\n                this.error = \"Unknown tag class\";\n                return -1;\n        }\n        this.isConstructed = (intBuffer[0] & 0x20) === 0x20;\n        this.isHexOnly = false;\n        const tagNumberMask = intBuffer[0] & 0x1F;\n        if (tagNumberMask !== 0x1F) {\n            this.tagNumber = tagNumberMask;\n            this.blockLength = 1;\n        } else {\n            let count = 1;\n            let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);\n            let tagNumberBufferMaxLength = 255;\n            while(intBuffer[count] & 0x80){\n                intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n                count++;\n                if (count >= intBuffer.length) {\n                    this.error = \"End of input reached before message was fully decoded\";\n                    return -1;\n                }\n                if (count === tagNumberBufferMaxLength) {\n                    tagNumberBufferMaxLength += 255;\n                    const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);\n                    for(let i = 0; i < intTagNumberBuffer.length; i++)tempBufferView[i] = intTagNumberBuffer[i];\n                    intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);\n                }\n            }\n            this.blockLength = count + 1;\n            intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n            const tempBufferView = new Uint8Array(count);\n            for(let i = 0; i < count; i++)tempBufferView[i] = intTagNumberBuffer[i];\n            intTagNumberBuffer = this.valueHexView = new Uint8Array(count);\n            intTagNumberBuffer.set(tempBufferView);\n            if (this.blockLength <= 9) this.tagNumber = pvutils__namespace.utilFromBase(intTagNumberBuffer, 7);\n            else {\n                this.isHexOnly = true;\n                this.warnings.push(\"Tag too long, represented as hex-coded\");\n            }\n        }\n        if (this.tagClass === 1 && this.isConstructed) {\n            switch(this.tagNumber){\n                case 1:\n                case 2:\n                case 5:\n                case 6:\n                case 9:\n                case 13:\n                case 14:\n                case 23:\n                case 24:\n                case 31:\n                case 32:\n                case 33:\n                case 34:\n                    this.error = \"Constructed encoding used for primitive type\";\n                    return -1;\n            }\n        }\n        return inputOffset + this.blockLength;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            tagClass: this.tagClass,\n            tagNumber: this.tagNumber,\n            isConstructed: this.isConstructed\n        };\n    }\n}\nLocalIdentificationBlock.NAME = \"identificationBlock\";\nclass LocalLengthBlock extends LocalBaseBlock {\n    constructor({ lenBlock = {} } = {}){\n        var _a, _b, _c;\n        super();\n        this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;\n        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;\n        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const view = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n            return -1;\n        }\n        const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);\n        if (intBuffer.length === 0) {\n            this.error = \"Zero buffer length\";\n            return -1;\n        }\n        if (intBuffer[0] === 0xFF) {\n            this.error = \"Length block 0xFF is reserved by standard\";\n            return -1;\n        }\n        this.isIndefiniteForm = intBuffer[0] === 0x80;\n        if (this.isIndefiniteForm) {\n            this.blockLength = 1;\n            return inputOffset + this.blockLength;\n        }\n        this.longFormUsed = !!(intBuffer[0] & 0x80);\n        if (this.longFormUsed === false) {\n            this.length = intBuffer[0];\n            this.blockLength = 1;\n            return inputOffset + this.blockLength;\n        }\n        const count = intBuffer[0] & 0x7F;\n        if (count > 8) {\n            this.error = \"Too big integer\";\n            return -1;\n        }\n        if (count + 1 > intBuffer.length) {\n            this.error = \"End of input reached before message was fully decoded\";\n            return -1;\n        }\n        const lenOffset = inputOffset + 1;\n        const lengthBufferView = view.subarray(lenOffset, lenOffset + count);\n        if (lengthBufferView[count - 1] === 0x00) this.warnings.push(\"Needlessly long encoded length\");\n        this.length = pvutils__namespace.utilFromBase(lengthBufferView, 8);\n        if (this.longFormUsed && this.length <= 127) this.warnings.push(\"Unnecessary usage of long length form\");\n        this.blockLength = count + 1;\n        return inputOffset + this.blockLength;\n    }\n    toBER(sizeOnly = false) {\n        let retBuf;\n        let retView;\n        if (this.length > 127) this.longFormUsed = true;\n        if (this.isIndefiniteForm) {\n            retBuf = new ArrayBuffer(1);\n            if (sizeOnly === false) {\n                retView = new Uint8Array(retBuf);\n                retView[0] = 0x80;\n            }\n            return retBuf;\n        }\n        if (this.longFormUsed) {\n            const encodedBuf = pvutils__namespace.utilToBase(this.length, 8);\n            if (encodedBuf.byteLength > 127) {\n                this.error = \"Too big length\";\n                return EMPTY_BUFFER;\n            }\n            retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n            if (sizeOnly) return retBuf;\n            const encodedView = new Uint8Array(encodedBuf);\n            retView = new Uint8Array(retBuf);\n            retView[0] = encodedBuf.byteLength | 0x80;\n            for(let i = 0; i < encodedBuf.byteLength; i++)retView[i + 1] = encodedView[i];\n            return retBuf;\n        }\n        retBuf = new ArrayBuffer(1);\n        if (sizeOnly === false) {\n            retView = new Uint8Array(retBuf);\n            retView[0] = this.length;\n        }\n        return retBuf;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            isIndefiniteForm: this.isIndefiniteForm,\n            longFormUsed: this.longFormUsed,\n            length: this.length\n        };\n    }\n}\nLocalLengthBlock.NAME = \"lengthBlock\";\nconst typeStore = {};\nclass BaseBlock extends LocalBaseBlock {\n    constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType){\n        super(parameters);\n        this.name = name;\n        this.optional = optional;\n        if (primitiveSchema) {\n            this.primitiveSchema = primitiveSchema;\n        }\n        this.idBlock = new LocalIdentificationBlock(parameters);\n        this.lenBlock = new LocalLengthBlock(parameters);\n        this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n        if (resultOffset === -1) {\n            this.error = this.valueBlock.error;\n            return resultOffset;\n        }\n        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;\n        return resultOffset;\n    }\n    toBER(sizeOnly, writer) {\n        const _writer = writer || new ViewWriter();\n        if (!writer) {\n            prepareIndefiniteForm(this);\n        }\n        const idBlockBuf = this.idBlock.toBER(sizeOnly);\n        _writer.write(idBlockBuf);\n        if (this.lenBlock.isIndefiniteForm) {\n            _writer.write(new Uint8Array([\n                0x80\n            ]).buffer);\n            this.valueBlock.toBER(sizeOnly, _writer);\n            _writer.write(new ArrayBuffer(2));\n        } else {\n            const valueBlockBuf = this.valueBlock.toBER(sizeOnly);\n            this.lenBlock.length = valueBlockBuf.byteLength;\n            const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n            _writer.write(lenBlockBuf);\n            _writer.write(valueBlockBuf);\n        }\n        if (!writer) {\n            return _writer.final();\n        }\n        return EMPTY_BUFFER;\n    }\n    toJSON() {\n        const object = {\n            ...super.toJSON(),\n            idBlock: this.idBlock.toJSON(),\n            lenBlock: this.lenBlock.toJSON(),\n            valueBlock: this.valueBlock.toJSON(),\n            name: this.name,\n            optional: this.optional\n        };\n        if (this.primitiveSchema) object.primitiveSchema = this.primitiveSchema.toJSON();\n        return object;\n    }\n    toString(encoding = \"ascii\") {\n        if (encoding === \"ascii\") {\n            return this.onAsciiEncoding();\n        }\n        return pvtsutils__namespace.Convert.ToHex(this.toBER());\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME} : ${pvtsutils__namespace.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;\n    }\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof this.constructor)) {\n            return false;\n        }\n        const thisRaw = this.toBER();\n        const otherRaw = other.toBER();\n        return pvutils__namespace.isEqualBuffer(thisRaw, otherRaw);\n    }\n}\nBaseBlock.NAME = \"BaseBlock\";\nfunction prepareIndefiniteForm(baseBlock) {\n    if (baseBlock instanceof typeStore.Constructed) {\n        for (const value of baseBlock.valueBlock.value){\n            if (prepareIndefiniteForm(value)) {\n                baseBlock.lenBlock.isIndefiniteForm = true;\n            }\n        }\n    }\n    return !!baseBlock.lenBlock.isIndefiniteForm;\n}\nclass BaseStringBlock extends BaseBlock {\n    constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType){\n        super(parameters, stringValueBlockType);\n        if (value) {\n            this.fromString(value);\n        }\n    }\n    getValue() {\n        return this.valueBlock.value;\n    }\n    setValue(value) {\n        this.valueBlock.value = value;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n        if (resultOffset === -1) {\n            this.error = this.valueBlock.error;\n            return resultOffset;\n        }\n        this.fromBuffer(this.valueBlock.valueHexView);\n        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;\n        return resultOffset;\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;\n    }\n}\nBaseStringBlock.NAME = \"BaseStringBlock\";\nclass LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {\n    constructor({ isHexOnly = true, ...parameters } = {}){\n        super(parameters);\n        this.isHexOnly = isHexOnly;\n    }\n}\nLocalPrimitiveValueBlock.NAME = \"PrimitiveValueBlock\";\nvar _a$w;\nclass Primitive extends BaseBlock {\n    constructor(parameters = {}){\n        super(parameters, LocalPrimitiveValueBlock);\n        this.idBlock.isConstructed = false;\n    }\n}\n_a$w = Primitive;\n(()=>{\n    typeStore.Primitive = _a$w;\n})();\nPrimitive.NAME = \"PRIMITIVE\";\nfunction localChangeType(inputObject, newType) {\n    if (inputObject instanceof newType) {\n        return inputObject;\n    }\n    const newObject = new newType();\n    newObject.idBlock = inputObject.idBlock;\n    newObject.lenBlock = inputObject.lenBlock;\n    newObject.warnings = inputObject.warnings;\n    newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;\n    return newObject;\n}\nfunction localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {\n    const incomingOffset = inputOffset;\n    let returnObject = new BaseBlock({}, ValueBlock);\n    const baseBlock = new LocalBaseBlock();\n    if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {\n        returnObject.error = baseBlock.error;\n        return {\n            offset: -1,\n            result: returnObject\n        };\n    }\n    const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);\n    if (!intBuffer.length) {\n        returnObject.error = \"Zero buffer length\";\n        return {\n            offset: -1,\n            result: returnObject\n        };\n    }\n    let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n    if (returnObject.idBlock.warnings.length) {\n        returnObject.warnings.concat(returnObject.idBlock.warnings);\n    }\n    if (resultOffset === -1) {\n        returnObject.error = returnObject.idBlock.error;\n        return {\n            offset: -1,\n            result: returnObject\n        };\n    }\n    inputOffset = resultOffset;\n    inputLength -= returnObject.idBlock.blockLength;\n    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n    if (returnObject.lenBlock.warnings.length) {\n        returnObject.warnings.concat(returnObject.lenBlock.warnings);\n    }\n    if (resultOffset === -1) {\n        returnObject.error = returnObject.lenBlock.error;\n        return {\n            offset: -1,\n            result: returnObject\n        };\n    }\n    inputOffset = resultOffset;\n    inputLength -= returnObject.lenBlock.blockLength;\n    if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {\n        returnObject.error = \"Indefinite length form used for primitive encoding form\";\n        return {\n            offset: -1,\n            result: returnObject\n        };\n    }\n    let newASN1Type = BaseBlock;\n    switch(returnObject.idBlock.tagClass){\n        case 1:\n            if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {\n                returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\n                return {\n                    offset: -1,\n                    result: returnObject\n                };\n            }\n            switch(returnObject.idBlock.tagNumber){\n                case 0:\n                    if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {\n                        returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\n                        return {\n                            offset: -1,\n                            result: returnObject\n                        };\n                    }\n                    newASN1Type = typeStore.EndOfContent;\n                    break;\n                case 1:\n                    newASN1Type = typeStore.Boolean;\n                    break;\n                case 2:\n                    newASN1Type = typeStore.Integer;\n                    break;\n                case 3:\n                    newASN1Type = typeStore.BitString;\n                    break;\n                case 4:\n                    newASN1Type = typeStore.OctetString;\n                    break;\n                case 5:\n                    newASN1Type = typeStore.Null;\n                    break;\n                case 6:\n                    newASN1Type = typeStore.ObjectIdentifier;\n                    break;\n                case 10:\n                    newASN1Type = typeStore.Enumerated;\n                    break;\n                case 12:\n                    newASN1Type = typeStore.Utf8String;\n                    break;\n                case 13:\n                    newASN1Type = typeStore.RelativeObjectIdentifier;\n                    break;\n                case 14:\n                    newASN1Type = typeStore.TIME;\n                    break;\n                case 15:\n                    returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\n                    return {\n                        offset: -1,\n                        result: returnObject\n                    };\n                case 16:\n                    newASN1Type = typeStore.Sequence;\n                    break;\n                case 17:\n                    newASN1Type = typeStore.Set;\n                    break;\n                case 18:\n                    newASN1Type = typeStore.NumericString;\n                    break;\n                case 19:\n                    newASN1Type = typeStore.PrintableString;\n                    break;\n                case 20:\n                    newASN1Type = typeStore.TeletexString;\n                    break;\n                case 21:\n                    newASN1Type = typeStore.VideotexString;\n                    break;\n                case 22:\n                    newASN1Type = typeStore.IA5String;\n                    break;\n                case 23:\n                    newASN1Type = typeStore.UTCTime;\n                    break;\n                case 24:\n                    newASN1Type = typeStore.GeneralizedTime;\n                    break;\n                case 25:\n                    newASN1Type = typeStore.GraphicString;\n                    break;\n                case 26:\n                    newASN1Type = typeStore.VisibleString;\n                    break;\n                case 27:\n                    newASN1Type = typeStore.GeneralString;\n                    break;\n                case 28:\n                    newASN1Type = typeStore.UniversalString;\n                    break;\n                case 29:\n                    newASN1Type = typeStore.CharacterString;\n                    break;\n                case 30:\n                    newASN1Type = typeStore.BmpString;\n                    break;\n                case 31:\n                    newASN1Type = typeStore.DATE;\n                    break;\n                case 32:\n                    newASN1Type = typeStore.TimeOfDay;\n                    break;\n                case 33:\n                    newASN1Type = typeStore.DateTime;\n                    break;\n                case 34:\n                    newASN1Type = typeStore.Duration;\n                    break;\n                default:\n                    {\n                        const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();\n                        newObject.idBlock = returnObject.idBlock;\n                        newObject.lenBlock = returnObject.lenBlock;\n                        newObject.warnings = returnObject.warnings;\n                        returnObject = newObject;\n                    }\n            }\n            break;\n        case 2:\n        case 3:\n        case 4:\n        default:\n            {\n                newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;\n            }\n    }\n    returnObject = localChangeType(returnObject, newASN1Type);\n    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);\n    returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);\n    return {\n        offset: resultOffset,\n        result: returnObject\n    };\n}\nfunction fromBER(inputBuffer) {\n    if (!inputBuffer.byteLength) {\n        const result = new BaseBlock({}, ValueBlock);\n        result.error = \"Input buffer has zero length\";\n        return {\n            offset: -1,\n            result\n        };\n    }\n    return localFromBER(pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);\n}\nfunction checkLen(indefiniteLength, length) {\n    if (indefiniteLength) {\n        return 1;\n    }\n    return length;\n}\nclass LocalConstructedValueBlock extends ValueBlock {\n    constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}){\n        super(parameters);\n        this.value = value;\n        this.isIndefiniteForm = isIndefiniteForm;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const view = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n            return -1;\n        }\n        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);\n        if (this.valueBeforeDecodeView.length === 0) {\n            this.warnings.push(\"Zero buffer length\");\n            return inputOffset;\n        }\n        let currentOffset = inputOffset;\n        while(checkLen(this.isIndefiniteForm, inputLength) > 0){\n            const returnObject = localFromBER(view, currentOffset, inputLength);\n            if (returnObject.offset === -1) {\n                this.error = returnObject.result.error;\n                this.warnings.concat(returnObject.result.warnings);\n                return -1;\n            }\n            currentOffset = returnObject.offset;\n            this.blockLength += returnObject.result.blockLength;\n            inputLength -= returnObject.result.blockLength;\n            this.value.push(returnObject.result);\n            if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {\n                break;\n            }\n        }\n        if (this.isIndefiniteForm) {\n            if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {\n                this.value.pop();\n            } else {\n                this.warnings.push(\"No EndOfContent block encoded\");\n            }\n        }\n        return currentOffset;\n    }\n    toBER(sizeOnly, writer) {\n        const _writer = writer || new ViewWriter();\n        for(let i = 0; i < this.value.length; i++){\n            this.value[i].toBER(sizeOnly, _writer);\n        }\n        if (!writer) {\n            return _writer.final();\n        }\n        return EMPTY_BUFFER;\n    }\n    toJSON() {\n        const object = {\n            ...super.toJSON(),\n            isIndefiniteForm: this.isIndefiniteForm,\n            value: []\n        };\n        for (const value of this.value){\n            object.value.push(value.toJSON());\n        }\n        return object;\n    }\n}\nLocalConstructedValueBlock.NAME = \"ConstructedValueBlock\";\nvar _a$v;\nclass Constructed extends BaseBlock {\n    constructor(parameters = {}){\n        super(parameters, LocalConstructedValueBlock);\n        this.idBlock.isConstructed = true;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n        if (resultOffset === -1) {\n            this.error = this.valueBlock.error;\n            return resultOffset;\n        }\n        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;\n        return resultOffset;\n    }\n    onAsciiEncoding() {\n        const values = [];\n        for (const value of this.valueBlock.value){\n            values.push(value.toString(\"ascii\").split(\"\\n\").map((o)=>`  ${o}`).join(\"\\n\"));\n        }\n        const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;\n        return values.length ? `${blockName} :\\n${values.join(\"\\n\")}` : `${blockName} :`;\n    }\n}\n_a$v = Constructed;\n(()=>{\n    typeStore.Constructed = _a$v;\n})();\nConstructed.NAME = \"CONSTRUCTED\";\nclass LocalEndOfContentValueBlock extends ValueBlock {\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        return inputOffset;\n    }\n    toBER(sizeOnly) {\n        return EMPTY_BUFFER;\n    }\n}\nLocalEndOfContentValueBlock.override = \"EndOfContentValueBlock\";\nvar _a$u;\nclass EndOfContent extends BaseBlock {\n    constructor(parameters = {}){\n        super(parameters, LocalEndOfContentValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 0;\n    }\n}\n_a$u = EndOfContent;\n(()=>{\n    typeStore.EndOfContent = _a$u;\n})();\nEndOfContent.NAME = END_OF_CONTENT_NAME;\nvar _a$t;\nclass Null extends BaseBlock {\n    constructor(parameters = {}){\n        super(parameters, ValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 5;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        if (this.lenBlock.length > 0) this.warnings.push(\"Non-zero length of value block for Null type\");\n        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n        this.blockLength += inputLength;\n        if (inputOffset + inputLength > inputBuffer.byteLength) {\n            this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n            return -1;\n        }\n        return inputOffset + inputLength;\n    }\n    toBER(sizeOnly, writer) {\n        const retBuf = new ArrayBuffer(2);\n        if (!sizeOnly) {\n            const retView = new Uint8Array(retBuf);\n            retView[0] = 0x05;\n            retView[1] = 0x00;\n        }\n        if (writer) {\n            writer.write(retBuf);\n        }\n        return retBuf;\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME}`;\n    }\n}\n_a$t = Null;\n(()=>{\n    typeStore.Null = _a$t;\n})();\nNull.NAME = \"NULL\";\nclass LocalBooleanValueBlock extends HexBlock(ValueBlock) {\n    constructor({ value, ...parameters } = {}){\n        super(parameters);\n        if (parameters.valueHex) {\n            this.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(parameters.valueHex);\n        } else {\n            this.valueHexView = new Uint8Array(1);\n        }\n        if (value) {\n            this.value = value;\n        }\n    }\n    get value() {\n        for (const octet of this.valueHexView){\n            if (octet > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    set value(value) {\n        this.valueHexView[0] = value ? 0xFF : 0x00;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n            return -1;\n        }\n        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);\n        if (inputLength > 1) this.warnings.push(\"Boolean value encoded in more then 1 octet\");\n        this.isHexOnly = true;\n        pvutils__namespace.utilDecodeTC.call(this);\n        this.blockLength = inputLength;\n        return inputOffset + inputLength;\n    }\n    toBER() {\n        return this.valueHexView.slice();\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            value: this.value\n        };\n    }\n}\nLocalBooleanValueBlock.NAME = \"BooleanValueBlock\";\nvar _a$s;\nclass Boolean extends BaseBlock {\n    constructor(parameters = {}){\n        super(parameters, LocalBooleanValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 1;\n    }\n    getValue() {\n        return this.valueBlock.value;\n    }\n    setValue(value) {\n        this.valueBlock.value = value;\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME} : ${this.getValue}`;\n    }\n}\n_a$s = Boolean;\n(()=>{\n    typeStore.Boolean = _a$s;\n})();\nBoolean.NAME = \"BOOLEAN\";\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n    constructor({ isConstructed = false, ...parameters } = {}){\n        super(parameters);\n        this.isConstructed = isConstructed;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        let resultOffset = 0;\n        if (this.isConstructed) {\n            this.isHexOnly = false;\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n            if (resultOffset === -1) return resultOffset;\n            for(let i = 0; i < this.value.length; i++){\n                const currentBlockName = this.value[i].constructor.NAME;\n                if (currentBlockName === END_OF_CONTENT_NAME) {\n                    if (this.isIndefiniteForm) break;\n                    else {\n                        this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\n                        return -1;\n                    }\n                }\n                if (currentBlockName !== OCTET_STRING_NAME) {\n                    this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\n                    return -1;\n                }\n            }\n        } else {\n            this.isHexOnly = true;\n            resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n            this.blockLength = inputLength;\n        }\n        return resultOffset;\n    }\n    toBER(sizeOnly, writer) {\n        if (this.isConstructed) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\n        return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            isConstructed: this.isConstructed\n        };\n    }\n}\nLocalOctetStringValueBlock.NAME = \"OctetStringValueBlock\";\nvar _a$r;\nclass OctetString extends BaseBlock {\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}){\n        var _b, _c;\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);\n        super({\n            idBlock: {\n                isConstructed: parameters.isConstructed,\n                ...idBlock\n            },\n            lenBlock: {\n                ...lenBlock,\n                isIndefiniteForm: !!parameters.isIndefiniteForm\n            },\n            ...parameters\n        }, LocalOctetStringValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 4;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n        if (inputLength === 0) {\n            if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n            if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n            return inputOffset;\n        }\n        if (!this.valueBlock.isConstructed) {\n            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\n            const buf = view.subarray(inputOffset, inputOffset + inputLength);\n            try {\n                if (buf.byteLength) {\n                    const asn = localFromBER(buf, 0, buf.byteLength);\n                    if (asn.offset !== -1 && asn.offset === inputLength) {\n                        this.valueBlock.value = [\n                            asn.result\n                        ];\n                    }\n                }\n            } catch (e) {}\n        }\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\n    }\n    onAsciiEncoding() {\n        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n            return Constructed.prototype.onAsciiEncoding.call(this);\n        }\n        return `${this.constructor.NAME} : ${pvtsutils__namespace.Convert.ToHex(this.valueBlock.valueHexView)}`;\n    }\n    getValue() {\n        if (!this.idBlock.isConstructed) {\n            return this.valueBlock.valueHexView.slice().buffer;\n        }\n        const array = [];\n        for (const content of this.valueBlock.value){\n            if (content instanceof OctetString) {\n                array.push(content.valueBlock.valueHexView);\n            }\n        }\n        return pvtsutils__namespace.BufferSourceConverter.concat(array);\n    }\n}\n_a$r = OctetString;\n(()=>{\n    typeStore.OctetString = _a$r;\n})();\nOctetString.NAME = OCTET_STRING_NAME;\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n    constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}){\n        super(parameters);\n        this.unusedBits = unusedBits;\n        this.isConstructed = isConstructed;\n        this.blockLength = this.valueHexView.byteLength;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        if (!inputLength) {\n            return inputOffset;\n        }\n        let resultOffset = -1;\n        if (this.isConstructed) {\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n            if (resultOffset === -1) return resultOffset;\n            for (const value of this.value){\n                const currentBlockName = value.constructor.NAME;\n                if (currentBlockName === END_OF_CONTENT_NAME) {\n                    if (this.isIndefiniteForm) break;\n                    else {\n                        this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\n                        return -1;\n                    }\n                }\n                if (currentBlockName !== BIT_STRING_NAME) {\n                    this.error = \"BIT STRING may consists of BIT STRINGs only\";\n                    return -1;\n                }\n                const valueBlock = value.valueBlock;\n                if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {\n                    this.error = 'Using of \"unused bits\" inside constructive BIT STRING allowed for least one only';\n                    return -1;\n                }\n                this.unusedBits = valueBlock.unusedBits;\n            }\n            return resultOffset;\n        }\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n            return -1;\n        }\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n        this.unusedBits = intBuffer[0];\n        if (this.unusedBits > 7) {\n            this.error = \"Unused bits for BitString must be in range 0-7\";\n            return -1;\n        }\n        if (!this.unusedBits) {\n            const buf = intBuffer.subarray(1);\n            try {\n                if (buf.byteLength) {\n                    const asn = localFromBER(buf, 0, buf.byteLength);\n                    if (asn.offset !== -1 && asn.offset === inputLength - 1) {\n                        this.value = [\n                            asn.result\n                        ];\n                    }\n                }\n            } catch (e) {}\n        }\n        this.valueHexView = intBuffer.subarray(1);\n        this.blockLength = intBuffer.length;\n        return inputOffset + inputLength;\n    }\n    toBER(sizeOnly, writer) {\n        if (this.isConstructed) {\n            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\n        }\n        if (sizeOnly) {\n            return new ArrayBuffer(this.valueHexView.byteLength + 1);\n        }\n        if (!this.valueHexView.byteLength) {\n            return EMPTY_BUFFER;\n        }\n        const retView = new Uint8Array(this.valueHexView.length + 1);\n        retView[0] = this.unusedBits;\n        retView.set(this.valueHexView, 1);\n        return retView.buffer;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            unusedBits: this.unusedBits,\n            isConstructed: this.isConstructed\n        };\n    }\n}\nLocalBitStringValueBlock.NAME = \"BitStringValueBlock\";\nvar _a$q;\nclass BitString extends BaseBlock {\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}){\n        var _b, _c;\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);\n        super({\n            idBlock: {\n                isConstructed: parameters.isConstructed,\n                ...idBlock\n            },\n            lenBlock: {\n                ...lenBlock,\n                isIndefiniteForm: !!parameters.isIndefiniteForm\n            },\n            ...parameters\n        }, LocalBitStringValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 3;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\n    }\n    onAsciiEncoding() {\n        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n            return Constructed.prototype.onAsciiEncoding.call(this);\n        } else {\n            const bits = [];\n            const valueHex = this.valueBlock.valueHexView;\n            for (const byte of valueHex){\n                bits.push(byte.toString(2).padStart(8, \"0\"));\n            }\n            const bitsStr = bits.join(\"\");\n            return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;\n        }\n    }\n}\n_a$q = BitString;\n(()=>{\n    typeStore.BitString = _a$q;\n})();\nBitString.NAME = BIT_STRING_NAME;\nvar _a$p;\nfunction viewAdd(first, second) {\n    const c = new Uint8Array([\n        0\n    ]);\n    const firstView = new Uint8Array(first);\n    const secondView = new Uint8Array(second);\n    let firstViewCopy = firstView.slice(0);\n    const firstViewCopyLength = firstViewCopy.length - 1;\n    const secondViewCopy = secondView.slice(0);\n    const secondViewCopyLength = secondViewCopy.length - 1;\n    let value = 0;\n    const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;\n    let counter = 0;\n    for(let i = max; i >= 0; i--, counter++){\n        switch(true){\n            case counter < secondViewCopy.length:\n                value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n                break;\n            default:\n                value = firstViewCopy[firstViewCopyLength - counter] + c[0];\n        }\n        c[0] = value / 10;\n        switch(true){\n            case counter >= firstViewCopy.length:\n                firstViewCopy = pvutils__namespace.utilConcatView(new Uint8Array([\n                    value % 10\n                ]), firstViewCopy);\n                break;\n            default:\n                firstViewCopy[firstViewCopyLength - counter] = value % 10;\n        }\n    }\n    if (c[0] > 0) firstViewCopy = pvutils__namespace.utilConcatView(c, firstViewCopy);\n    return firstViewCopy;\n}\nfunction power2(n) {\n    if (n >= powers2.length) {\n        for(let p = powers2.length; p <= n; p++){\n            const c = new Uint8Array([\n                0\n            ]);\n            let digits = powers2[p - 1].slice(0);\n            for(let i = digits.length - 1; i >= 0; i--){\n                const newValue = new Uint8Array([\n                    (digits[i] << 1) + c[0]\n                ]);\n                c[0] = newValue[0] / 10;\n                digits[i] = newValue[0] % 10;\n            }\n            if (c[0] > 0) digits = pvutils__namespace.utilConcatView(c, digits);\n            powers2.push(digits);\n        }\n    }\n    return powers2[n];\n}\nfunction viewSub(first, second) {\n    let b = 0;\n    const firstView = new Uint8Array(first);\n    const secondView = new Uint8Array(second);\n    const firstViewCopy = firstView.slice(0);\n    const firstViewCopyLength = firstViewCopy.length - 1;\n    const secondViewCopy = secondView.slice(0);\n    const secondViewCopyLength = secondViewCopy.length - 1;\n    let value;\n    let counter = 0;\n    for(let i = secondViewCopyLength; i >= 0; i--, counter++){\n        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n        switch(true){\n            case value < 0:\n                b = 1;\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\n                break;\n            default:\n                b = 0;\n                firstViewCopy[firstViewCopyLength - counter] = value;\n        }\n    }\n    if (b > 0) {\n        for(let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++){\n            value = firstViewCopy[firstViewCopyLength - counter] - b;\n            if (value < 0) {\n                b = 1;\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\n            } else {\n                b = 0;\n                firstViewCopy[firstViewCopyLength - counter] = value;\n                break;\n            }\n        }\n    }\n    return firstViewCopy.slice();\n}\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock) {\n    constructor({ value, ...parameters } = {}){\n        super(parameters);\n        this._valueDec = 0;\n        if (parameters.valueHex) {\n            this.setValueHex();\n        }\n        if (value !== undefined) {\n            this.valueDec = value;\n        }\n    }\n    setValueHex() {\n        if (this.valueHexView.length >= 4) {\n            this.warnings.push(\"Too big Integer for decoding, hex only\");\n            this.isHexOnly = true;\n            this._valueDec = 0;\n        } else {\n            this.isHexOnly = false;\n            if (this.valueHexView.length > 0) {\n                this._valueDec = pvutils__namespace.utilDecodeTC.call(this);\n            }\n        }\n    }\n    set valueDec(v) {\n        this._valueDec = v;\n        this.isHexOnly = false;\n        this.valueHexView = new Uint8Array(pvutils__namespace.utilEncodeTC(v));\n    }\n    get valueDec() {\n        return this._valueDec;\n    }\n    fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\n        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n        if (offset === -1) return offset;\n        const view = this.valueHexView;\n        if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {\n            this.valueHexView = view.subarray(1);\n        } else {\n            if (expectedLength !== 0) {\n                if (view.length < expectedLength) {\n                    if (expectedLength - view.length > 1) expectedLength = view.length + 1;\n                    this.valueHexView = view.subarray(expectedLength - view.length);\n                }\n            }\n        }\n        return offset;\n    }\n    toDER(sizeOnly = false) {\n        const view = this.valueHexView;\n        switch(true){\n            case (view[0] & 0x80) !== 0:\n                {\n                    const updatedView = new Uint8Array(this.valueHexView.length + 1);\n                    updatedView[0] = 0x00;\n                    updatedView.set(view, 1);\n                    this.valueHexView = updatedView;\n                }\n                break;\n            case view[0] === 0x00 && (view[1] & 0x80) === 0:\n                {\n                    this.valueHexView = this.valueHexView.subarray(1);\n                }\n                break;\n        }\n        return this.toBER(sizeOnly);\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n        if (resultOffset === -1) {\n            return resultOffset;\n        }\n        this.setValueHex();\n        return resultOffset;\n    }\n    toBER(sizeOnly) {\n        return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            valueDec: this.valueDec\n        };\n    }\n    toString() {\n        const firstBit = this.valueHexView.length * 8 - 1;\n        let digits = new Uint8Array(this.valueHexView.length * 8 / 3);\n        let bitNumber = 0;\n        let currentByte;\n        const asn1View = this.valueHexView;\n        let result = \"\";\n        let flag = false;\n        for(let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--){\n            currentByte = asn1View[byteNumber];\n            for(let i = 0; i < 8; i++){\n                if ((currentByte & 1) === 1) {\n                    switch(bitNumber){\n                        case firstBit:\n                            digits = viewSub(power2(bitNumber), digits);\n                            result = \"-\";\n                            break;\n                        default:\n                            digits = viewAdd(digits, power2(bitNumber));\n                    }\n                }\n                bitNumber++;\n                currentByte >>= 1;\n            }\n        }\n        for(let i = 0; i < digits.length; i++){\n            if (digits[i]) flag = true;\n            if (flag) result += digitsString.charAt(digits[i]);\n        }\n        if (flag === false) result += digitsString.charAt(0);\n        return result;\n    }\n}\n_a$p = LocalIntegerValueBlock;\nLocalIntegerValueBlock.NAME = \"IntegerValueBlock\";\n(()=>{\n    Object.defineProperty(_a$p.prototype, \"valueHex\", {\n        set: function(v) {\n            this.valueHexView = new Uint8Array(v);\n            this.setValueHex();\n        },\n        get: function() {\n            return this.valueHexView.slice().buffer;\n        }\n    });\n})();\nvar _a$o;\nclass Integer extends BaseBlock {\n    constructor(parameters = {}){\n        super(parameters, LocalIntegerValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 2;\n    }\n    toBigInt() {\n        assertBigInt();\n        return BigInt(this.valueBlock.toString());\n    }\n    static fromBigInt(value) {\n        assertBigInt();\n        const bigIntValue = BigInt(value);\n        const writer = new ViewWriter();\n        const hex = bigIntValue.toString(16).replace(/^-/, \"\");\n        const view = new Uint8Array(pvtsutils__namespace.Convert.FromHex(hex));\n        if (bigIntValue < 0) {\n            const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));\n            first[0] |= 0x80;\n            const firstInt = BigInt(`0x${pvtsutils__namespace.Convert.ToHex(first)}`);\n            const secondInt = firstInt + bigIntValue;\n            const second = pvtsutils__namespace.BufferSourceConverter.toUint8Array(pvtsutils__namespace.Convert.FromHex(secondInt.toString(16)));\n            second[0] |= 0x80;\n            writer.write(second);\n        } else {\n            if (view[0] & 0x80) {\n                writer.write(new Uint8Array([\n                    0\n                ]));\n            }\n            writer.write(view);\n        }\n        const res = new Integer({\n            valueHex: writer.final()\n        });\n        return res;\n    }\n    convertToDER() {\n        const integer = new Integer({\n            valueHex: this.valueBlock.valueHexView\n        });\n        integer.valueBlock.toDER();\n        return integer;\n    }\n    convertFromDER() {\n        return new Integer({\n            valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView\n        });\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;\n    }\n}\n_a$o = Integer;\n(()=>{\n    typeStore.Integer = _a$o;\n})();\nInteger.NAME = \"INTEGER\";\nvar _a$n;\nclass Enumerated extends Integer {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 10;\n    }\n}\n_a$n = Enumerated;\n(()=>{\n    typeStore.Enumerated = _a$n;\n})();\nEnumerated.NAME = \"ENUMERATED\";\nclass LocalSidValueBlock extends HexBlock(ValueBlock) {\n    constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}){\n        super(parameters);\n        this.valueDec = valueDec;\n        this.isFirstSid = isFirstSid;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        if (!inputLength) {\n            return inputOffset;\n        }\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n            return -1;\n        }\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n        this.valueHexView = new Uint8Array(inputLength);\n        for(let i = 0; i < inputLength; i++){\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\n            this.blockLength++;\n            if ((intBuffer[i] & 0x80) === 0x00) break;\n        }\n        const tempView = new Uint8Array(this.blockLength);\n        for(let i = 0; i < this.blockLength; i++){\n            tempView[i] = this.valueHexView[i];\n        }\n        this.valueHexView = tempView;\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n            this.error = \"End of input reached before message was fully decoded\";\n            return -1;\n        }\n        if (this.valueHexView[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n        if (this.blockLength <= 8) this.valueDec = pvutils__namespace.utilFromBase(this.valueHexView, 7);\n        else {\n            this.isHexOnly = true;\n            this.warnings.push(\"Too big SID for decoding, hex only\");\n        }\n        return inputOffset + this.blockLength;\n    }\n    set valueBigInt(value) {\n        assertBigInt();\n        let bits = BigInt(value).toString(2);\n        while(bits.length % 7){\n            bits = \"0\" + bits;\n        }\n        const bytes = new Uint8Array(bits.length / 7);\n        for(let i = 0; i < bytes.length; i++){\n            bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);\n        }\n        this.fromBER(bytes.buffer, 0, bytes.length);\n    }\n    toBER(sizeOnly) {\n        if (this.isHexOnly) {\n            if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);\n            const curView = this.valueHexView;\n            const retView = new Uint8Array(this.blockLength);\n            for(let i = 0; i < this.blockLength - 1; i++)retView[i] = curView[i] | 0x80;\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\n            return retView.buffer;\n        }\n        const encodedBuf = pvutils__namespace.utilToBase(this.valueDec, 7);\n        if (encodedBuf.byteLength === 0) {\n            this.error = \"Error during encoding SID value\";\n            return EMPTY_BUFFER;\n        }\n        const retView = new Uint8Array(encodedBuf.byteLength);\n        if (!sizeOnly) {\n            const encodedView = new Uint8Array(encodedBuf);\n            const len = encodedBuf.byteLength - 1;\n            for(let i = 0; i < len; i++)retView[i] = encodedView[i] | 0x80;\n            retView[len] = encodedView[len];\n        }\n        return retView;\n    }\n    toString() {\n        let result = \"\";\n        if (this.isHexOnly) result = pvtsutils__namespace.Convert.ToHex(this.valueHexView);\n        else {\n            if (this.isFirstSid) {\n                let sidValue = this.valueDec;\n                if (this.valueDec <= 39) result = \"0.\";\n                else {\n                    if (this.valueDec <= 79) {\n                        result = \"1.\";\n                        sidValue -= 40;\n                    } else {\n                        result = \"2.\";\n                        sidValue -= 80;\n                    }\n                }\n                result += sidValue.toString();\n            } else result = this.valueDec.toString();\n        }\n        return result;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            valueDec: this.valueDec,\n            isFirstSid: this.isFirstSid\n        };\n    }\n}\nLocalSidValueBlock.NAME = \"sidBlock\";\nclass LocalObjectIdentifierValueBlock extends ValueBlock {\n    constructor({ value = EMPTY_STRING, ...parameters } = {}){\n        super(parameters);\n        this.value = [];\n        if (value) {\n            this.fromString(value);\n        }\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        let resultOffset = inputOffset;\n        while(inputLength > 0){\n            const sidBlock = new LocalSidValueBlock();\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n            if (resultOffset === -1) {\n                this.blockLength = 0;\n                this.error = sidBlock.error;\n                return resultOffset;\n            }\n            if (this.value.length === 0) sidBlock.isFirstSid = true;\n            this.blockLength += sidBlock.blockLength;\n            inputLength -= sidBlock.blockLength;\n            this.value.push(sidBlock);\n        }\n        return resultOffset;\n    }\n    toBER(sizeOnly) {\n        const retBuffers = [];\n        for(let i = 0; i < this.value.length; i++){\n            const valueBuf = this.value[i].toBER(sizeOnly);\n            if (valueBuf.byteLength === 0) {\n                this.error = this.value[i].error;\n                return EMPTY_BUFFER;\n            }\n            retBuffers.push(valueBuf);\n        }\n        return concat(retBuffers);\n    }\n    fromString(string) {\n        this.value = [];\n        let pos1 = 0;\n        let pos2 = 0;\n        let sid = \"\";\n        let flag = false;\n        do {\n            pos2 = string.indexOf(\".\", pos1);\n            if (pos2 === -1) sid = string.substring(pos1);\n            else sid = string.substring(pos1, pos2);\n            pos1 = pos2 + 1;\n            if (flag) {\n                const sidBlock = this.value[0];\n                let plus = 0;\n                switch(sidBlock.valueDec){\n                    case 0:\n                        break;\n                    case 1:\n                        plus = 40;\n                        break;\n                    case 2:\n                        plus = 80;\n                        break;\n                    default:\n                        this.value = [];\n                        return;\n                }\n                const parsedSID = parseInt(sid, 10);\n                if (isNaN(parsedSID)) return;\n                sidBlock.valueDec = parsedSID + plus;\n                flag = false;\n            } else {\n                const sidBlock = new LocalSidValueBlock();\n                if (sid > Number.MAX_SAFE_INTEGER) {\n                    assertBigInt();\n                    const sidValue = BigInt(sid);\n                    sidBlock.valueBigInt = sidValue;\n                } else {\n                    sidBlock.valueDec = parseInt(sid, 10);\n                    if (isNaN(sidBlock.valueDec)) return;\n                }\n                if (!this.value.length) {\n                    sidBlock.isFirstSid = true;\n                    flag = true;\n                }\n                this.value.push(sidBlock);\n            }\n        }while (pos2 !== -1);\n    }\n    toString() {\n        let result = \"\";\n        let isHexOnly = false;\n        for(let i = 0; i < this.value.length; i++){\n            isHexOnly = this.value[i].isHexOnly;\n            let sidStr = this.value[i].toString();\n            if (i !== 0) result = `${result}.`;\n            if (isHexOnly) {\n                sidStr = `{${sidStr}}`;\n                if (this.value[i].isFirstSid) result = `2.{${sidStr} - 80}`;\n                else result += sidStr;\n            } else result += sidStr;\n        }\n        return result;\n    }\n    toJSON() {\n        const object = {\n            ...super.toJSON(),\n            value: this.toString(),\n            sidArray: []\n        };\n        for(let i = 0; i < this.value.length; i++){\n            object.sidArray.push(this.value[i].toJSON());\n        }\n        return object;\n    }\n}\nLocalObjectIdentifierValueBlock.NAME = \"ObjectIdentifierValueBlock\";\nvar _a$m;\nclass ObjectIdentifier extends BaseBlock {\n    constructor(parameters = {}){\n        super(parameters, LocalObjectIdentifierValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 6;\n    }\n    getValue() {\n        return this.valueBlock.toString();\n    }\n    setValue(value) {\n        this.valueBlock.fromString(value);\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            value: this.getValue()\n        };\n    }\n}\n_a$m = ObjectIdentifier;\n(()=>{\n    typeStore.ObjectIdentifier = _a$m;\n})();\nObjectIdentifier.NAME = \"OBJECT IDENTIFIER\";\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {\n    constructor({ valueDec = 0, ...parameters } = {}){\n        super(parameters);\n        this.valueDec = valueDec;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        if (inputLength === 0) return inputOffset;\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) return -1;\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n        this.valueHexView = new Uint8Array(inputLength);\n        for(let i = 0; i < inputLength; i++){\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\n            this.blockLength++;\n            if ((intBuffer[i] & 0x80) === 0x00) break;\n        }\n        const tempView = new Uint8Array(this.blockLength);\n        for(let i = 0; i < this.blockLength; i++)tempView[i] = this.valueHexView[i];\n        this.valueHexView = tempView;\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n            this.error = \"End of input reached before message was fully decoded\";\n            return -1;\n        }\n        if (this.valueHexView[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n        if (this.blockLength <= 8) this.valueDec = pvutils__namespace.utilFromBase(this.valueHexView, 7);\n        else {\n            this.isHexOnly = true;\n            this.warnings.push(\"Too big SID for decoding, hex only\");\n        }\n        return inputOffset + this.blockLength;\n    }\n    toBER(sizeOnly) {\n        if (this.isHexOnly) {\n            if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);\n            const curView = this.valueHexView;\n            const retView = new Uint8Array(this.blockLength);\n            for(let i = 0; i < this.blockLength - 1; i++)retView[i] = curView[i] | 0x80;\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\n            return retView.buffer;\n        }\n        const encodedBuf = pvutils__namespace.utilToBase(this.valueDec, 7);\n        if (encodedBuf.byteLength === 0) {\n            this.error = \"Error during encoding SID value\";\n            return EMPTY_BUFFER;\n        }\n        const retView = new Uint8Array(encodedBuf.byteLength);\n        if (!sizeOnly) {\n            const encodedView = new Uint8Array(encodedBuf);\n            const len = encodedBuf.byteLength - 1;\n            for(let i = 0; i < len; i++)retView[i] = encodedView[i] | 0x80;\n            retView[len] = encodedView[len];\n        }\n        return retView.buffer;\n    }\n    toString() {\n        let result = \"\";\n        if (this.isHexOnly) result = pvtsutils__namespace.Convert.ToHex(this.valueHexView);\n        else {\n            result = this.valueDec.toString();\n        }\n        return result;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            valueDec: this.valueDec\n        };\n    }\n}\nLocalRelativeSidValueBlock.NAME = \"relativeSidBlock\";\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\n    constructor({ value = EMPTY_STRING, ...parameters } = {}){\n        super(parameters);\n        this.value = [];\n        if (value) {\n            this.fromString(value);\n        }\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        let resultOffset = inputOffset;\n        while(inputLength > 0){\n            const sidBlock = new LocalRelativeSidValueBlock();\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n            if (resultOffset === -1) {\n                this.blockLength = 0;\n                this.error = sidBlock.error;\n                return resultOffset;\n            }\n            this.blockLength += sidBlock.blockLength;\n            inputLength -= sidBlock.blockLength;\n            this.value.push(sidBlock);\n        }\n        return resultOffset;\n    }\n    toBER(sizeOnly, writer) {\n        const retBuffers = [];\n        for(let i = 0; i < this.value.length; i++){\n            const valueBuf = this.value[i].toBER(sizeOnly);\n            if (valueBuf.byteLength === 0) {\n                this.error = this.value[i].error;\n                return EMPTY_BUFFER;\n            }\n            retBuffers.push(valueBuf);\n        }\n        return concat(retBuffers);\n    }\n    fromString(string) {\n        this.value = [];\n        let pos1 = 0;\n        let pos2 = 0;\n        let sid = \"\";\n        do {\n            pos2 = string.indexOf(\".\", pos1);\n            if (pos2 === -1) sid = string.substring(pos1);\n            else sid = string.substring(pos1, pos2);\n            pos1 = pos2 + 1;\n            const sidBlock = new LocalRelativeSidValueBlock();\n            sidBlock.valueDec = parseInt(sid, 10);\n            if (isNaN(sidBlock.valueDec)) return true;\n            this.value.push(sidBlock);\n        }while (pos2 !== -1);\n        return true;\n    }\n    toString() {\n        let result = \"\";\n        let isHexOnly = false;\n        for(let i = 0; i < this.value.length; i++){\n            isHexOnly = this.value[i].isHexOnly;\n            let sidStr = this.value[i].toString();\n            if (i !== 0) result = `${result}.`;\n            if (isHexOnly) {\n                sidStr = `{${sidStr}}`;\n                result += sidStr;\n            } else result += sidStr;\n        }\n        return result;\n    }\n    toJSON() {\n        const object = {\n            ...super.toJSON(),\n            value: this.toString(),\n            sidArray: []\n        };\n        for(let i = 0; i < this.value.length; i++)object.sidArray.push(this.value[i].toJSON());\n        return object;\n    }\n}\nLocalRelativeObjectIdentifierValueBlock.NAME = \"RelativeObjectIdentifierValueBlock\";\nvar _a$l;\nclass RelativeObjectIdentifier extends BaseBlock {\n    constructor(parameters = {}){\n        super(parameters, LocalRelativeObjectIdentifierValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 13;\n    }\n    getValue() {\n        return this.valueBlock.toString();\n    }\n    setValue(value) {\n        this.valueBlock.fromString(value);\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            value: this.getValue()\n        };\n    }\n}\n_a$l = RelativeObjectIdentifier;\n(()=>{\n    typeStore.RelativeObjectIdentifier = _a$l;\n})();\nRelativeObjectIdentifier.NAME = \"RelativeObjectIdentifier\";\nvar _a$k;\nclass Sequence extends Constructed {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 16;\n    }\n}\n_a$k = Sequence;\n(()=>{\n    typeStore.Sequence = _a$k;\n})();\nSequence.NAME = \"SEQUENCE\";\nvar _a$j;\nclass Set extends Constructed {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 17;\n    }\n}\n_a$j = Set;\n(()=>{\n    typeStore.Set = _a$j;\n})();\nSet.NAME = \"SET\";\nclass LocalStringValueBlock extends HexBlock(ValueBlock) {\n    constructor({ ...parameters } = {}){\n        super(parameters);\n        this.isHexOnly = true;\n        this.value = EMPTY_STRING;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            value: this.value\n        };\n    }\n}\nLocalStringValueBlock.NAME = \"StringValueBlock\";\nclass LocalSimpleStringValueBlock extends LocalStringValueBlock {\n}\nLocalSimpleStringValueBlock.NAME = \"SimpleStringValueBlock\";\nclass LocalSimpleStringBlock extends BaseStringBlock {\n    constructor({ ...parameters } = {}){\n        super(parameters, LocalSimpleStringValueBlock);\n    }\n    fromBuffer(inputBuffer) {\n        this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer));\n    }\n    fromString(inputString) {\n        const strLen = inputString.length;\n        const view = this.valueBlock.valueHexView = new Uint8Array(strLen);\n        for(let i = 0; i < strLen; i++)view[i] = inputString.charCodeAt(i);\n        this.valueBlock.value = inputString;\n    }\n}\nLocalSimpleStringBlock.NAME = \"SIMPLE STRING\";\nclass LocalUtf8StringValueBlock extends LocalSimpleStringBlock {\n    fromBuffer(inputBuffer) {\n        this.valueBlock.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        try {\n            this.valueBlock.value = pvtsutils__namespace.Convert.ToUtf8String(inputBuffer);\n        } catch (ex) {\n            this.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\n            this.valueBlock.value = pvtsutils__namespace.Convert.ToBinary(inputBuffer);\n        }\n    }\n    fromString(inputString) {\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__namespace.Convert.FromUtf8String(inputString));\n        this.valueBlock.value = inputString;\n    }\n}\nLocalUtf8StringValueBlock.NAME = \"Utf8StringValueBlock\";\nvar _a$i;\nclass Utf8String extends LocalUtf8StringValueBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 12;\n    }\n}\n_a$i = Utf8String;\n(()=>{\n    typeStore.Utf8String = _a$i;\n})();\nUtf8String.NAME = \"UTF8String\";\nclass LocalBmpStringValueBlock extends LocalSimpleStringBlock {\n    fromBuffer(inputBuffer) {\n        this.valueBlock.value = pvtsutils__namespace.Convert.ToUtf16String(inputBuffer);\n        this.valueBlock.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n    }\n    fromString(inputString) {\n        this.valueBlock.value = inputString;\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__namespace.Convert.FromUtf16String(inputString));\n    }\n}\nLocalBmpStringValueBlock.NAME = \"BmpStringValueBlock\";\nvar _a$h;\nclass BmpString extends LocalBmpStringValueBlock {\n    constructor({ ...parameters } = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 30;\n    }\n}\n_a$h = BmpString;\n(()=>{\n    typeStore.BmpString = _a$h;\n})();\nBmpString.NAME = \"BMPString\";\nclass LocalUniversalStringValueBlock extends LocalSimpleStringBlock {\n    fromBuffer(inputBuffer) {\n        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);\n        const valueView = new Uint8Array(copyBuffer);\n        for(let i = 0; i < valueView.length; i += 4){\n            valueView[i] = valueView[i + 3];\n            valueView[i + 1] = valueView[i + 2];\n            valueView[i + 2] = 0x00;\n            valueView[i + 3] = 0x00;\n        }\n        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n    }\n    fromString(inputString) {\n        const strLength = inputString.length;\n        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);\n        for(let i = 0; i < strLength; i++){\n            const codeBuf = pvutils__namespace.utilToBase(inputString.charCodeAt(i), 8);\n            const codeView = new Uint8Array(codeBuf);\n            if (codeView.length > 4) continue;\n            const dif = 4 - codeView.length;\n            for(let j = codeView.length - 1; j >= 0; j--)valueHexView[i * 4 + j + dif] = codeView[j];\n        }\n        this.valueBlock.value = inputString;\n    }\n}\nLocalUniversalStringValueBlock.NAME = \"UniversalStringValueBlock\";\nvar _a$g;\nclass UniversalString extends LocalUniversalStringValueBlock {\n    constructor({ ...parameters } = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 28;\n    }\n}\n_a$g = UniversalString;\n(()=>{\n    typeStore.UniversalString = _a$g;\n})();\nUniversalString.NAME = \"UniversalString\";\nvar _a$f;\nclass NumericString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 18;\n    }\n}\n_a$f = NumericString;\n(()=>{\n    typeStore.NumericString = _a$f;\n})();\nNumericString.NAME = \"NumericString\";\nvar _a$e;\nclass PrintableString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 19;\n    }\n}\n_a$e = PrintableString;\n(()=>{\n    typeStore.PrintableString = _a$e;\n})();\nPrintableString.NAME = \"PrintableString\";\nvar _a$d;\nclass TeletexString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 20;\n    }\n}\n_a$d = TeletexString;\n(()=>{\n    typeStore.TeletexString = _a$d;\n})();\nTeletexString.NAME = \"TeletexString\";\nvar _a$c;\nclass VideotexString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 21;\n    }\n}\n_a$c = VideotexString;\n(()=>{\n    typeStore.VideotexString = _a$c;\n})();\nVideotexString.NAME = \"VideotexString\";\nvar _a$b;\nclass IA5String extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 22;\n    }\n}\n_a$b = IA5String;\n(()=>{\n    typeStore.IA5String = _a$b;\n})();\nIA5String.NAME = \"IA5String\";\nvar _a$a;\nclass GraphicString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 25;\n    }\n}\n_a$a = GraphicString;\n(()=>{\n    typeStore.GraphicString = _a$a;\n})();\nGraphicString.NAME = \"GraphicString\";\nvar _a$9;\nclass VisibleString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 26;\n    }\n}\n_a$9 = VisibleString;\n(()=>{\n    typeStore.VisibleString = _a$9;\n})();\nVisibleString.NAME = \"VisibleString\";\nvar _a$8;\nclass GeneralString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 27;\n    }\n}\n_a$8 = GeneralString;\n(()=>{\n    typeStore.GeneralString = _a$8;\n})();\nGeneralString.NAME = \"GeneralString\";\nvar _a$7;\nclass CharacterString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 29;\n    }\n}\n_a$7 = CharacterString;\n(()=>{\n    typeStore.CharacterString = _a$7;\n})();\nCharacterString.NAME = \"CharacterString\";\nvar _a$6;\nclass UTCTime extends VisibleString {\n    constructor({ value, valueDate, ...parameters } = {}){\n        super(parameters);\n        this.year = 0;\n        this.month = 0;\n        this.day = 0;\n        this.hour = 0;\n        this.minute = 0;\n        this.second = 0;\n        if (value) {\n            this.fromString(value);\n            this.valueBlock.valueHexView = new Uint8Array(value.length);\n            for(let i = 0; i < value.length; i++)this.valueBlock.valueHexView[i] = value.charCodeAt(i);\n        }\n        if (valueDate) {\n            this.fromDate(valueDate);\n            this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());\n        }\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 23;\n    }\n    fromBuffer(inputBuffer) {\n        this.fromString(String.fromCharCode.apply(null, pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer)));\n    }\n    toBuffer() {\n        const str = this.toString();\n        const buffer = new ArrayBuffer(str.length);\n        const view = new Uint8Array(buffer);\n        for(let i = 0; i < str.length; i++)view[i] = str.charCodeAt(i);\n        return buffer;\n    }\n    fromDate(inputDate) {\n        this.year = inputDate.getUTCFullYear();\n        this.month = inputDate.getUTCMonth() + 1;\n        this.day = inputDate.getUTCDate();\n        this.hour = inputDate.getUTCHours();\n        this.minute = inputDate.getUTCMinutes();\n        this.second = inputDate.getUTCSeconds();\n    }\n    toDate() {\n        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));\n    }\n    fromString(inputString) {\n        const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n        const parserArray = parser.exec(inputString);\n        if (parserArray === null) {\n            this.error = \"Wrong input string for conversion\";\n            return;\n        }\n        const year = parseInt(parserArray[1], 10);\n        if (year >= 50) this.year = 1900 + year;\n        else this.year = 2000 + year;\n        this.month = parseInt(parserArray[2], 10);\n        this.day = parseInt(parserArray[3], 10);\n        this.hour = parseInt(parserArray[4], 10);\n        this.minute = parseInt(parserArray[5], 10);\n        this.second = parseInt(parserArray[6], 10);\n    }\n    toString(encoding = \"iso\") {\n        if (encoding === \"iso\") {\n            const outputArray = new Array(7);\n            outputArray[0] = pvutils__namespace.padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);\n            outputArray[1] = pvutils__namespace.padNumber(this.month, 2);\n            outputArray[2] = pvutils__namespace.padNumber(this.day, 2);\n            outputArray[3] = pvutils__namespace.padNumber(this.hour, 2);\n            outputArray[4] = pvutils__namespace.padNumber(this.minute, 2);\n            outputArray[5] = pvutils__namespace.padNumber(this.second, 2);\n            outputArray[6] = \"Z\";\n            return outputArray.join(\"\");\n        }\n        return super.toString(encoding);\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            year: this.year,\n            month: this.month,\n            day: this.day,\n            hour: this.hour,\n            minute: this.minute,\n            second: this.second\n        };\n    }\n}\n_a$6 = UTCTime;\n(()=>{\n    typeStore.UTCTime = _a$6;\n})();\nUTCTime.NAME = \"UTCTime\";\nvar _a$5;\nclass GeneralizedTime extends UTCTime {\n    constructor(parameters = {}){\n        var _b;\n        super(parameters);\n        (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 24;\n    }\n    fromDate(inputDate) {\n        super.fromDate(inputDate);\n        this.millisecond = inputDate.getUTCMilliseconds();\n    }\n    toDate() {\n        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));\n    }\n    fromString(inputString) {\n        let isUTC = false;\n        let timeString = \"\";\n        let dateTimeString = \"\";\n        let fractionPart = 0;\n        let parser;\n        let hourDifference = 0;\n        let minuteDifference = 0;\n        if (inputString[inputString.length - 1] === \"Z\") {\n            timeString = inputString.substring(0, inputString.length - 1);\n            isUTC = true;\n        } else {\n            const number = new Number(inputString[inputString.length - 1]);\n            if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for conversion\");\n            timeString = inputString;\n        }\n        if (isUTC) {\n            if (timeString.indexOf(\"+\") !== -1) throw new Error(\"Wrong input string for conversion\");\n            if (timeString.indexOf(\"-\") !== -1) throw new Error(\"Wrong input string for conversion\");\n        } else {\n            let multiplier = 1;\n            let differencePosition = timeString.indexOf(\"+\");\n            let differenceString = \"\";\n            if (differencePosition === -1) {\n                differencePosition = timeString.indexOf(\"-\");\n                multiplier = -1;\n            }\n            if (differencePosition !== -1) {\n                differenceString = timeString.substring(differencePosition + 1);\n                timeString = timeString.substring(0, differencePosition);\n                if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error(\"Wrong input string for conversion\");\n                let number = parseInt(differenceString.substring(0, 2), 10);\n                if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for conversion\");\n                hourDifference = multiplier * number;\n                if (differenceString.length === 4) {\n                    number = parseInt(differenceString.substring(2, 4), 10);\n                    if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for conversion\");\n                    minuteDifference = multiplier * number;\n                }\n            }\n        }\n        let fractionPointPosition = timeString.indexOf(\".\");\n        if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(\",\");\n        if (fractionPointPosition !== -1) {\n            const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);\n            if (isNaN(fractionPartCheck.valueOf())) throw new Error(\"Wrong input string for conversion\");\n            fractionPart = fractionPartCheck.valueOf();\n            dateTimeString = timeString.substring(0, fractionPointPosition);\n        } else dateTimeString = timeString;\n        switch(true){\n            case dateTimeString.length === 8:\n                parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n                if (fractionPointPosition !== -1) throw new Error(\"Wrong input string for conversion\");\n                break;\n            case dateTimeString.length === 10:\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n                if (fractionPointPosition !== -1) {\n                    let fractionResult = 60 * fractionPart;\n                    this.minute = Math.floor(fractionResult);\n                    fractionResult = 60 * (fractionResult - this.minute);\n                    this.second = Math.floor(fractionResult);\n                    fractionResult = 1000 * (fractionResult - this.second);\n                    this.millisecond = Math.floor(fractionResult);\n                }\n                break;\n            case dateTimeString.length === 12:\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n                if (fractionPointPosition !== -1) {\n                    let fractionResult = 60 * fractionPart;\n                    this.second = Math.floor(fractionResult);\n                    fractionResult = 1000 * (fractionResult - this.second);\n                    this.millisecond = Math.floor(fractionResult);\n                }\n                break;\n            case dateTimeString.length === 14:\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n                if (fractionPointPosition !== -1) {\n                    const fractionResult = 1000 * fractionPart;\n                    this.millisecond = Math.floor(fractionResult);\n                }\n                break;\n            default:\n                throw new Error(\"Wrong input string for conversion\");\n        }\n        const parserArray = parser.exec(dateTimeString);\n        if (parserArray === null) throw new Error(\"Wrong input string for conversion\");\n        for(let j = 1; j < parserArray.length; j++){\n            switch(j){\n                case 1:\n                    this.year = parseInt(parserArray[j], 10);\n                    break;\n                case 2:\n                    this.month = parseInt(parserArray[j], 10);\n                    break;\n                case 3:\n                    this.day = parseInt(parserArray[j], 10);\n                    break;\n                case 4:\n                    this.hour = parseInt(parserArray[j], 10) + hourDifference;\n                    break;\n                case 5:\n                    this.minute = parseInt(parserArray[j], 10) + minuteDifference;\n                    break;\n                case 6:\n                    this.second = parseInt(parserArray[j], 10);\n                    break;\n                default:\n                    throw new Error(\"Wrong input string for conversion\");\n            }\n        }\n        if (isUTC === false) {\n            const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n            this.year = tempDate.getUTCFullYear();\n            this.month = tempDate.getUTCMonth();\n            this.day = tempDate.getUTCDay();\n            this.hour = tempDate.getUTCHours();\n            this.minute = tempDate.getUTCMinutes();\n            this.second = tempDate.getUTCSeconds();\n            this.millisecond = tempDate.getUTCMilliseconds();\n        }\n    }\n    toString(encoding = \"iso\") {\n        if (encoding === \"iso\") {\n            const outputArray = [];\n            outputArray.push(pvutils__namespace.padNumber(this.year, 4));\n            outputArray.push(pvutils__namespace.padNumber(this.month, 2));\n            outputArray.push(pvutils__namespace.padNumber(this.day, 2));\n            outputArray.push(pvutils__namespace.padNumber(this.hour, 2));\n            outputArray.push(pvutils__namespace.padNumber(this.minute, 2));\n            outputArray.push(pvutils__namespace.padNumber(this.second, 2));\n            if (this.millisecond !== 0) {\n                outputArray.push(\".\");\n                outputArray.push(pvutils__namespace.padNumber(this.millisecond, 3));\n            }\n            outputArray.push(\"Z\");\n            return outputArray.join(\"\");\n        }\n        return super.toString(encoding);\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            millisecond: this.millisecond\n        };\n    }\n}\n_a$5 = GeneralizedTime;\n(()=>{\n    typeStore.GeneralizedTime = _a$5;\n})();\nGeneralizedTime.NAME = \"GeneralizedTime\";\nvar _a$4;\nclass DATE extends Utf8String {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 31;\n    }\n}\n_a$4 = DATE;\n(()=>{\n    typeStore.DATE = _a$4;\n})();\nDATE.NAME = \"DATE\";\nvar _a$3;\nclass TimeOfDay extends Utf8String {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 32;\n    }\n}\n_a$3 = TimeOfDay;\n(()=>{\n    typeStore.TimeOfDay = _a$3;\n})();\nTimeOfDay.NAME = \"TimeOfDay\";\nvar _a$2;\nclass DateTime extends Utf8String {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 33;\n    }\n}\n_a$2 = DateTime;\n(()=>{\n    typeStore.DateTime = _a$2;\n})();\nDateTime.NAME = \"DateTime\";\nvar _a$1;\nclass Duration extends Utf8String {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 34;\n    }\n}\n_a$1 = Duration;\n(()=>{\n    typeStore.Duration = _a$1;\n})();\nDuration.NAME = \"Duration\";\nvar _a;\nclass TIME extends Utf8String {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 14;\n    }\n}\n_a = TIME;\n(()=>{\n    typeStore.TIME = _a;\n})();\nTIME.NAME = \"TIME\";\nclass Any {\n    constructor({ name = EMPTY_STRING, optional = false } = {}){\n        this.name = name;\n        this.optional = optional;\n    }\n}\nclass Choice extends Any {\n    constructor({ value = [], ...parameters } = {}){\n        super(parameters);\n        this.value = value;\n    }\n}\nclass Repeated extends Any {\n    constructor({ value = new Any(), local = false, ...parameters } = {}){\n        super(parameters);\n        this.value = value;\n        this.local = local;\n    }\n}\nclass RawData {\n    constructor({ data = EMPTY_VIEW } = {}){\n        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(data);\n    }\n    get data() {\n        return this.dataView.slice().buffer;\n    }\n    set data(value) {\n        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(value);\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const endLength = inputOffset + inputLength;\n        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);\n        return endLength;\n    }\n    toBER(sizeOnly) {\n        return this.dataView.slice().buffer;\n    }\n}\nfunction compareSchema(root, inputData, inputSchema) {\n    if (inputSchema instanceof Choice) {\n        for(let j = 0; j < inputSchema.value.length; j++){\n            const result = compareSchema(root, inputData, inputSchema.value[j]);\n            if (result.verified) {\n                return {\n                    verified: true,\n                    result: root\n                };\n            }\n        }\n        {\n            const _result = {\n                verified: false,\n                result: {\n                    error: \"Wrong values for Choice type\"\n                }\n            };\n            if (inputSchema.hasOwnProperty(NAME)) _result.name = inputSchema.name;\n            return _result;\n        }\n    }\n    if (inputSchema instanceof Any) {\n        if (inputSchema.hasOwnProperty(NAME)) root[inputSchema.name] = inputData;\n        return {\n            verified: true,\n            result: root\n        };\n    }\n    if (root instanceof Object === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong root object\"\n            }\n        };\n    }\n    if (inputData instanceof Object === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 data\"\n            }\n        };\n    }\n    if (inputSchema instanceof Object === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (ID_BLOCK in inputSchema === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (FROM_BER in inputSchema.idBlock === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (TO_BER in inputSchema.idBlock === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    const encodedId = inputSchema.idBlock.toBER(false);\n    if (encodedId.byteLength === 0) {\n        return {\n            verified: false,\n            result: {\n                error: \"Error encoding idBlock for ASN.1 schema\"\n            }\n        };\n    }\n    const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n    if (decodedOffset === -1) {\n        return {\n            verified: false,\n            result: {\n                error: \"Error decoding idBlock for ASN.1 schema\"\n            }\n        };\n    }\n    if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\n        return {\n            verified: false,\n            result: root\n        };\n    }\n    if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\n        return {\n            verified: false,\n            result: root\n        };\n    }\n    if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\n        return {\n            verified: false,\n            result: root\n        };\n    }\n    if (!(IS_HEX_ONLY in inputSchema.idBlock)) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\n        return {\n            verified: false,\n            result: root\n        };\n    }\n    if (inputSchema.idBlock.isHexOnly) {\n        if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {\n            return {\n                verified: false,\n                result: {\n                    error: \"Wrong ASN.1 schema\"\n                }\n            };\n        }\n        const schemaView = inputSchema.idBlock.valueHexView;\n        const asn1View = inputData.idBlock.valueHexView;\n        if (schemaView.length !== asn1View.length) {\n            return {\n                verified: false,\n                result: root\n            };\n        }\n        for(let i = 0; i < schemaView.length; i++){\n            if (schemaView[i] !== asn1View[1]) {\n                return {\n                    verified: false,\n                    result: root\n                };\n            }\n        }\n    }\n    if (inputSchema.name) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n        if (inputSchema.name) root[inputSchema.name] = inputData;\n    }\n    if (inputSchema instanceof typeStore.Constructed) {\n        let admission = 0;\n        let result = {\n            verified: false,\n            result: {\n                error: \"Unknown error\"\n            }\n        };\n        let maxLength = inputSchema.valueBlock.value.length;\n        if (maxLength > 0) {\n            if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n                maxLength = inputData.valueBlock.value.length;\n            }\n        }\n        if (maxLength === 0) {\n            return {\n                verified: true,\n                result: root\n            };\n        }\n        if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {\n            let _optional = true;\n            for(let i = 0; i < inputSchema.valueBlock.value.length; i++)_optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\n            if (_optional) {\n                return {\n                    verified: true,\n                    result: root\n                };\n            }\n            if (inputSchema.name) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                if (inputSchema.name) delete root[inputSchema.name];\n            }\n            root.error = \"Inconsistent object length\";\n            return {\n                verified: false,\n                result: root\n            };\n        }\n        for(let i = 0; i < maxLength; i++){\n            if (i - admission >= inputData.valueBlock.value.length) {\n                if (inputSchema.valueBlock.value[i].optional === false) {\n                    const _result = {\n                        verified: false,\n                        result: root\n                    };\n                    root.error = \"Inconsistent length between ASN.1 data and schema\";\n                    if (inputSchema.name) {\n                        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                        if (inputSchema.name) {\n                            delete root[inputSchema.name];\n                            _result.name = inputSchema.name;\n                        }\n                    }\n                    return _result;\n                }\n            } else {\n                if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n                    result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\n                    if (result.verified === false) {\n                        if (inputSchema.valueBlock.value[0].optional) admission++;\n                        else {\n                            if (inputSchema.name) {\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                                if (inputSchema.name) delete root[inputSchema.name];\n                            }\n                            return result;\n                        }\n                    }\n                    if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {\n                        let arrayRoot = {};\n                        if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local) arrayRoot = inputData;\n                        else arrayRoot = root;\n                        if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\") arrayRoot[inputSchema.valueBlock.value[0].name] = [];\n                        arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\n                    }\n                } else {\n                    result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\n                    if (result.verified === false) {\n                        if (inputSchema.valueBlock.value[i].optional) admission++;\n                        else {\n                            if (inputSchema.name) {\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                                if (inputSchema.name) delete root[inputSchema.name];\n                            }\n                            return result;\n                        }\n                    }\n                }\n            }\n        }\n        if (result.verified === false) {\n            const _result = {\n                verified: false,\n                result: root\n            };\n            if (inputSchema.name) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                if (inputSchema.name) {\n                    delete root[inputSchema.name];\n                    _result.name = inputSchema.name;\n                }\n            }\n            return _result;\n        }\n        return {\n            verified: true,\n            result: root\n        };\n    }\n    if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {\n        const asn1 = localFromBER(inputData.valueBlock.valueHexView);\n        if (asn1.offset === -1) {\n            const _result = {\n                verified: false,\n                result: asn1.result\n            };\n            if (inputSchema.name) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                if (inputSchema.name) {\n                    delete root[inputSchema.name];\n                    _result.name = inputSchema.name;\n                }\n            }\n            return _result;\n        }\n        return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n    }\n    return {\n        verified: true,\n        result: root\n    };\n}\nfunction verifySchema(inputBuffer, inputSchema) {\n    if (inputSchema instanceof Object === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema type\"\n            }\n        };\n    }\n    const asn1 = localFromBER(pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer));\n    if (asn1.offset === -1) {\n        return {\n            verified: false,\n            result: asn1.result\n        };\n    }\n    return compareSchema(asn1.result, asn1.result, inputSchema);\n}\nexports.Any = Any;\nexports.BaseBlock = BaseBlock;\nexports.BaseStringBlock = BaseStringBlock;\nexports.BitString = BitString;\nexports.BmpString = BmpString;\nexports.Boolean = Boolean;\nexports.CharacterString = CharacterString;\nexports.Choice = Choice;\nexports.Constructed = Constructed;\nexports.DATE = DATE;\nexports.DateTime = DateTime;\nexports.Duration = Duration;\nexports.EndOfContent = EndOfContent;\nexports.Enumerated = Enumerated;\nexports.GeneralString = GeneralString;\nexports.GeneralizedTime = GeneralizedTime;\nexports.GraphicString = GraphicString;\nexports.HexBlock = HexBlock;\nexports.IA5String = IA5String;\nexports.Integer = Integer;\nexports.Null = Null;\nexports.NumericString = NumericString;\nexports.ObjectIdentifier = ObjectIdentifier;\nexports.OctetString = OctetString;\nexports.Primitive = Primitive;\nexports.PrintableString = PrintableString;\nexports.RawData = RawData;\nexports.RelativeObjectIdentifier = RelativeObjectIdentifier;\nexports.Repeated = Repeated;\nexports.Sequence = Sequence;\nexports.Set = Set;\nexports.TIME = TIME;\nexports.TeletexString = TeletexString;\nexports.TimeOfDay = TimeOfDay;\nexports.UTCTime = UTCTime;\nexports.UniversalString = UniversalString;\nexports.Utf8String = Utf8String;\nexports.ValueBlock = ValueBlock;\nexports.VideotexString = VideotexString;\nexports.ViewWriter = ViewWriter;\nexports.VisibleString = VisibleString;\nexports.compareSchema = compareSchema;\nexports.fromBER = fromBER;\nexports.verifySchema = verifySchema;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXNuMWpzL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdDQyxHQUVEO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLFlBQVlDLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlDLFVBQVVELG1CQUFPQSxDQUFDO0FBRXRCLFNBQVNFLGtCQUFrQkMsQ0FBQztJQUMxQixJQUFJQSxLQUFLQSxFQUFFQyxVQUFVLEVBQUUsT0FBT0Q7SUFDOUIsSUFBSUUsSUFBSVYsT0FBT1csTUFBTSxDQUFDO0lBQ3RCLElBQUlILEdBQUc7UUFDTFIsT0FBT1ksSUFBSSxDQUFDSixHQUFHSyxPQUFPLENBQUMsU0FBVUMsQ0FBQztZQUNoQyxJQUFJQSxNQUFNLFdBQVc7Z0JBQ25CLElBQUlDLElBQUlmLE9BQU9nQix3QkFBd0IsQ0FBQ1IsR0FBR007Z0JBQzNDZCxPQUFPQyxjQUFjLENBQUNTLEdBQUdJLEdBQUdDLEVBQUVFLEdBQUcsR0FBR0YsSUFBSTtvQkFDdENHLFlBQVk7b0JBQ1pELEtBQUs7d0JBQWMsT0FBT1QsQ0FBQyxDQUFDTSxFQUFFO29CQUFFO2dCQUNsQztZQUNGO1FBQ0Y7SUFDRjtJQUNBSixDQUFDLENBQUMsVUFBVSxHQUFHRjtJQUNmLE9BQU9SLE9BQU9tQixNQUFNLENBQUNUO0FBQ3ZCO0FBRUEsSUFBSVUsdUJBQXVCLFdBQVcsR0FBRWIsa0JBQWtCSDtBQUMxRCxJQUFJaUIscUJBQXFCLFdBQVcsR0FBRWQsa0JBQWtCRDtBQUV4RCxTQUFTZ0I7SUFDTCxJQUFJLE9BQU9DLFdBQVcsYUFBYTtRQUMvQixNQUFNLElBQUlDLE1BQU07SUFDcEI7QUFDSjtBQUNBLFNBQVNDLE9BQU9DLE9BQU87SUFDbkIsSUFBSUMsZUFBZTtJQUNuQixJQUFJQyxhQUFhO0lBQ2pCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxRQUFRSSxNQUFNLEVBQUVELElBQUs7UUFDckMsTUFBTUUsU0FBU0wsT0FBTyxDQUFDRyxFQUFFO1FBQ3pCRixnQkFBZ0JJLE9BQU9DLFVBQVU7SUFDckM7SUFDQSxNQUFNQyxVQUFVLElBQUlDLFdBQVdQO0lBQy9CLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJSCxRQUFRSSxNQUFNLEVBQUVELElBQUs7UUFDckMsTUFBTUUsU0FBU0wsT0FBTyxDQUFDRyxFQUFFO1FBQ3pCSSxRQUFRRSxHQUFHLENBQUMsSUFBSUQsV0FBV0gsU0FBU0g7UUFDcENBLGNBQWNHLE9BQU9DLFVBQVU7SUFDbkM7SUFDQSxPQUFPQyxRQUFRRixNQUFNO0FBQ3pCO0FBQ0EsU0FBU0ssa0JBQWtCQyxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXO0lBQ3ZFLElBQUksQ0FBRUYsQ0FBQUEsdUJBQXVCSixVQUFTLEdBQUk7UUFDdENHLFVBQVVJLEtBQUssR0FBRztRQUNsQixPQUFPO0lBQ1g7SUFDQSxJQUFJLENBQUNILFlBQVlOLFVBQVUsRUFBRTtRQUN6QkssVUFBVUksS0FBSyxHQUFHO1FBQ2xCLE9BQU87SUFDWDtJQUNBLElBQUlGLGNBQWMsR0FBRztRQUNqQkYsVUFBVUksS0FBSyxHQUFHO1FBQ2xCLE9BQU87SUFDWDtJQUNBLElBQUlELGNBQWMsR0FBRztRQUNqQkgsVUFBVUksS0FBSyxHQUFHO1FBQ2xCLE9BQU87SUFDWDtJQUNBLElBQUksWUFBYVQsVUFBVSxHQUFHTyxjQUFjQyxjQUFlLEdBQUc7UUFDMURILFVBQVVJLEtBQUssR0FBRztRQUNsQixPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFFQSxNQUFNQztJQUNGQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtJQUNuQjtJQUNBQyxNQUFNQyxHQUFHLEVBQUU7UUFDUCxJQUFJLENBQUNGLEtBQUssQ0FBQ0csSUFBSSxDQUFDRDtJQUNwQjtJQUNBRSxRQUFRO1FBQ0osT0FBT3ZCLE9BQU8sSUFBSSxDQUFDbUIsS0FBSztJQUM1QjtBQUNKO0FBRUEsTUFBTUssVUFBVTtJQUFDLElBQUlmLFdBQVc7UUFBQztLQUFFO0NBQUU7QUFDckMsTUFBTWdCLGVBQWU7QUFDckIsTUFBTUMsT0FBTztBQUNiLE1BQU1DLGlCQUFpQjtBQUN2QixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxhQUFhO0FBQ25CLE1BQU1DLGlCQUFpQjtBQUN2QixNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLFNBQVM7QUFDZixNQUFNQyxRQUFRO0FBQ2QsTUFBTUMsZUFBZTtBQUNyQixNQUFNQyxlQUFlLElBQUlDLFlBQVk7QUFDckMsTUFBTUMsYUFBYSxJQUFJOUIsV0FBVztBQUNsQyxNQUFNK0Isc0JBQXNCO0FBQzVCLE1BQU1DLG9CQUFvQjtBQUMxQixNQUFNQyxrQkFBa0I7QUFFeEIsU0FBU0MsU0FBU0MsU0FBUztJQUN2QixJQUFJQztJQUNKLE9BQU9BLEtBQUssTUFBTUMsYUFBYUY7UUFDdkIxQixZQUFZLEdBQUc2QixJQUFJLENBQUU7WUFDakIsSUFBSUY7WUFDSixLQUFLLElBQUlFO1lBQ1QsTUFBTUMsU0FBU0QsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDO1lBQzNCLElBQUksQ0FBQ0UsU0FBUyxHQUFHLENBQUNKLEtBQUtHLE9BQU9DLFNBQVMsTUFBTSxRQUFRSixPQUFPLEtBQUssSUFBSUEsS0FBSztZQUMxRSxJQUFJLENBQUNLLFlBQVksR0FBR0YsT0FBT0csUUFBUSxHQUFHeEQscUJBQXFCeUQscUJBQXFCLENBQUNDLFlBQVksQ0FBQ0wsT0FBT0csUUFBUSxJQUFJWjtRQUNySDtRQUNBLElBQUlZLFdBQVc7WUFDWCxPQUFPLElBQUksQ0FBQ0QsWUFBWSxDQUFDSSxLQUFLLEdBQUdoRCxNQUFNO1FBQzNDO1FBQ0EsSUFBSTZDLFNBQVN6RSxLQUFLLEVBQUU7WUFDaEIsSUFBSSxDQUFDd0UsWUFBWSxHQUFHLElBQUl6QyxXQUFXL0I7UUFDdkM7UUFDQTZFLFFBQVExQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFO1lBQzNDLE1BQU15QyxPQUFPM0MsdUJBQXVCeUIsY0FBYyxJQUFJN0IsV0FBV0ksZUFBZUE7WUFDaEYsSUFBSSxDQUFDRixrQkFBa0IsSUFBSSxFQUFFNkMsTUFBTTFDLGFBQWFDLGNBQWM7Z0JBQzFELE9BQU8sQ0FBQztZQUNaO1lBQ0EsTUFBTTBDLFlBQVkzQyxjQUFjQztZQUNoQyxJQUFJLENBQUNtQyxZQUFZLEdBQUdNLEtBQUtFLFFBQVEsQ0FBQzVDLGFBQWEyQztZQUMvQyxJQUFJLENBQUMsSUFBSSxDQUFDUCxZQUFZLENBQUM3QyxNQUFNLEVBQUU7Z0JBQzNCLElBQUksQ0FBQ3NELFFBQVEsQ0FBQ3JDLElBQUksQ0FBQztnQkFDbkIsT0FBT1I7WUFDWDtZQUNBLElBQUksQ0FBQzhDLFdBQVcsR0FBRzdDO1lBQ25CLE9BQU8wQztRQUNYO1FBQ0FJLE1BQU1DLFdBQVcsS0FBSyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUNiLFNBQVMsRUFBRTtnQkFDakIsSUFBSSxDQUFDakMsS0FBSyxHQUFHO2dCQUNiLE9BQU9xQjtZQUNYO1lBQ0EsSUFBSXlCLFVBQVU7Z0JBQ1YsT0FBTyxJQUFJeEIsWUFBWSxJQUFJLENBQUNZLFlBQVksQ0FBQzNDLFVBQVU7WUFDdkQ7WUFDQSxPQUFPLElBQUssQ0FBQzJDLFlBQVksQ0FBQzNDLFVBQVUsS0FBSyxJQUFJLENBQUMyQyxZQUFZLENBQUM1QyxNQUFNLENBQUNDLFVBQVUsR0FDdEUsSUFBSSxDQUFDMkMsWUFBWSxDQUFDNUMsTUFBTSxHQUN4QixJQUFJLENBQUM0QyxZQUFZLENBQUNJLEtBQUssR0FBR2hELE1BQU07UUFDMUM7UUFDQXlELFNBQVM7WUFDTCxPQUFPO2dCQUNILEdBQUcsS0FBSyxDQUFDQSxRQUFRO2dCQUNqQmQsV0FBVyxJQUFJLENBQUNBLFNBQVM7Z0JBQ3pCRSxVQUFVeEQscUJBQXFCcUUsT0FBTyxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDZixZQUFZO1lBQ2xFO1FBQ0o7SUFDSixHQUNBTCxHQUFHbkIsSUFBSSxHQUFHLFlBQ1ZtQjtBQUNSO0FBRUEsTUFBTXFCO0lBQ0ZoRCxZQUFZLEVBQUUwQyxjQUFjLENBQUMsRUFBRTVDLFFBQVFvQixZQUFZLEVBQUV1QixXQUFXLEVBQUUsRUFBRVEsb0JBQW9CNUIsVUFBVSxFQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDeEcsSUFBSSxDQUFDcUIsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUM1QyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDMkMsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNTLHFCQUFxQixHQUFHekUscUJBQXFCeUQscUJBQXFCLENBQUNDLFlBQVksQ0FBQ2M7SUFDekY7SUFDQSxPQUFPRSxZQUFZO1FBQ2YsT0FBTyxJQUFJLENBQUMzQyxJQUFJO0lBQ3BCO0lBQ0EsSUFBSXlDLG9CQUFvQjtRQUNwQixPQUFPLElBQUksQ0FBQ0MscUJBQXFCLENBQUNkLEtBQUssR0FBR2hELE1BQU07SUFDcEQ7SUFDQSxJQUFJNkQsa0JBQWtCekYsS0FBSyxFQUFFO1FBQ3pCLElBQUksQ0FBQzBGLHFCQUFxQixHQUFHLElBQUkzRCxXQUFXL0I7SUFDaEQ7SUFDQXFGLFNBQVM7UUFDTCxPQUFPO1lBQ0hNLFdBQVcsSUFBSSxDQUFDbkQsV0FBVyxDQUFDUSxJQUFJO1lBQ2hDa0MsYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFDN0I1QyxPQUFPLElBQUksQ0FBQ0EsS0FBSztZQUNqQjJDLFVBQVUsSUFBSSxDQUFDQSxRQUFRO1lBQ3ZCUSxtQkFBbUJ4RSxxQkFBcUJxRSxPQUFPLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUNHLHFCQUFxQjtRQUNwRjtJQUNKO0FBQ0o7QUFDQUYsZUFBZXhDLElBQUksR0FBRztBQUV0QixNQUFNNEMsbUJBQW1CSjtJQUNyQlgsUUFBUTFDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUU7UUFDM0MsTUFBTXdELFVBQVU7SUFDcEI7SUFDQVYsTUFBTUMsUUFBUSxFQUFFVSxNQUFNLEVBQUU7UUFDcEIsTUFBTUQsVUFBVTtJQUNwQjtBQUNKO0FBQ0FELFdBQVc1QyxJQUFJLEdBQUc7QUFFbEIsTUFBTStDLGlDQUFpQzlCLFNBQVN1QjtJQUM1Q2hELFlBQVksRUFBRXdELFVBQVUsQ0FBQyxDQUFDLEVBQUcsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNoQyxJQUFJN0IsSUFBSThCLElBQUlDLElBQUlDO1FBQ2hCLEtBQUs7UUFDTCxJQUFJSCxTQUFTO1lBQ1QsSUFBSSxDQUFDekIsU0FBUyxHQUFHLENBQUNKLEtBQUs2QixRQUFRekIsU0FBUyxNQUFNLFFBQVFKLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1lBQzNFLElBQUksQ0FBQ0ssWUFBWSxHQUFHd0IsUUFBUXZCLFFBQVEsR0FBR3hELHFCQUFxQnlELHFCQUFxQixDQUFDQyxZQUFZLENBQUNxQixRQUFRdkIsUUFBUSxJQUFJWjtZQUNuSCxJQUFJLENBQUN1QyxRQUFRLEdBQUcsQ0FBQ0gsS0FBS0QsUUFBUUksUUFBUSxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJQSxLQUFLLENBQUM7WUFDMUUsSUFBSSxDQUFDSSxTQUFTLEdBQUcsQ0FBQ0gsS0FBS0YsUUFBUUssU0FBUyxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJQSxLQUFLLENBQUM7WUFDNUUsSUFBSSxDQUFDSSxhQUFhLEdBQUcsQ0FBQ0gsS0FBS0gsUUFBUU0sYUFBYSxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ3ZGLE9BQ0s7WUFDRCxJQUFJLENBQUNDLFFBQVEsR0FBRyxDQUFDO1lBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHLENBQUM7WUFDbEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDekI7SUFDSjtJQUNBbkIsTUFBTUMsV0FBVyxLQUFLLEVBQUU7UUFDcEIsSUFBSW1CLGFBQWE7UUFDakIsT0FBUSxJQUFJLENBQUNILFFBQVE7WUFDakIsS0FBSztnQkFDREcsY0FBYztnQkFDZDtZQUNKLEtBQUs7Z0JBQ0RBLGNBQWM7Z0JBQ2Q7WUFDSixLQUFLO2dCQUNEQSxjQUFjO2dCQUNkO1lBQ0osS0FBSztnQkFDREEsY0FBYztnQkFDZDtZQUNKO2dCQUNJLElBQUksQ0FBQ2pFLEtBQUssR0FBRztnQkFDYixPQUFPcUI7UUFDZjtRQUNBLElBQUksSUFBSSxDQUFDMkMsYUFBYSxFQUNsQkMsY0FBYztRQUNsQixJQUFJLElBQUksQ0FBQ0YsU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUM5QixTQUFTLEVBQUU7WUFDeEMsTUFBTXpDLFVBQVUsSUFBSUMsV0FBVztZQUMvQixJQUFJLENBQUNxRCxVQUFVO2dCQUNYLElBQUlvQixTQUFTLElBQUksQ0FBQ0gsU0FBUztnQkFDM0JHLFVBQVU7Z0JBQ1ZELGNBQWNDO2dCQUNkMUUsT0FBTyxDQUFDLEVBQUUsR0FBR3lFO1lBQ2pCO1lBQ0EsT0FBT3pFLFFBQVFGLE1BQU07UUFDekI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDMkMsU0FBUyxFQUFFO1lBQ2pCLE1BQU1rQyxhQUFhdkYsbUJBQW1Cd0YsVUFBVSxDQUFDLElBQUksQ0FBQ0wsU0FBUyxFQUFFO1lBQ2pFLE1BQU1NLGNBQWMsSUFBSTVFLFdBQVcwRTtZQUNuQyxNQUFNRyxPQUFPSCxXQUFXNUUsVUFBVTtZQUNsQyxNQUFNQyxVQUFVLElBQUlDLFdBQVc2RSxPQUFPO1lBQ3RDOUUsT0FBTyxDQUFDLEVBQUUsR0FBSXlFLGFBQWE7WUFDM0IsSUFBSSxDQUFDbkIsVUFBVTtnQkFDWCxJQUFLLElBQUkxRCxJQUFJLEdBQUdBLElBQUtrRixPQUFPLEdBQUlsRixJQUM1QkksT0FBTyxDQUFDSixJQUFJLEVBQUUsR0FBR2lGLFdBQVcsQ0FBQ2pGLEVBQUUsR0FBRztnQkFDdENJLE9BQU8sQ0FBQzhFLEtBQUssR0FBR0QsV0FBVyxDQUFDQyxPQUFPLEVBQUU7WUFDekM7WUFDQSxPQUFPOUUsUUFBUUYsTUFBTTtRQUN6QjtRQUNBLE1BQU1FLFVBQVUsSUFBSUMsV0FBVyxJQUFJLENBQUN5QyxZQUFZLENBQUMzQyxVQUFVLEdBQUc7UUFDOURDLE9BQU8sQ0FBQyxFQUFFLEdBQUl5RSxhQUFhO1FBQzNCLElBQUksQ0FBQ25CLFVBQVU7WUFDWCxNQUFNeUIsVUFBVSxJQUFJLENBQUNyQyxZQUFZO1lBQ2pDLElBQUssSUFBSTlDLElBQUksR0FBR0EsSUFBS21GLFFBQVFsRixNQUFNLEdBQUcsR0FBSUQsSUFDdENJLE9BQU8sQ0FBQ0osSUFBSSxFQUFFLEdBQUdtRixPQUFPLENBQUNuRixFQUFFLEdBQUc7WUFDbENJLE9BQU8sQ0FBQyxJQUFJLENBQUMwQyxZQUFZLENBQUMzQyxVQUFVLENBQUMsR0FBR2dGLE9BQU8sQ0FBQ0EsUUFBUWxGLE1BQU0sR0FBRyxFQUFFO1FBQ3ZFO1FBQ0EsT0FBT0csUUFBUUYsTUFBTTtJQUN6QjtJQUNBaUQsUUFBUTFDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUU7UUFDM0MsTUFBTXlFLFlBQVk3RixxQkFBcUJ5RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDeEM7UUFDMUUsSUFBSSxDQUFDRixrQkFBa0IsSUFBSSxFQUFFNkUsV0FBVzFFLGFBQWFDLGNBQWM7WUFDL0QsT0FBTyxDQUFDO1FBQ1o7UUFDQSxNQUFNMEUsWUFBWUQsVUFBVTlCLFFBQVEsQ0FBQzVDLGFBQWFBLGNBQWNDO1FBQ2hFLElBQUkwRSxVQUFVcEYsTUFBTSxLQUFLLEdBQUc7WUFDeEIsSUFBSSxDQUFDVyxLQUFLLEdBQUc7WUFDYixPQUFPLENBQUM7UUFDWjtRQUNBLE1BQU0wRSxlQUFlRCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3BDLE9BQVFDO1lBQ0osS0FBSztnQkFDRCxJQUFJLENBQUNaLFFBQVEsR0FBSTtnQkFDakI7WUFDSixLQUFLO2dCQUNELElBQUksQ0FBQ0EsUUFBUSxHQUFJO2dCQUNqQjtZQUNKLEtBQUs7Z0JBQ0QsSUFBSSxDQUFDQSxRQUFRLEdBQUk7Z0JBQ2pCO1lBQ0osS0FBSztnQkFDRCxJQUFJLENBQUNBLFFBQVEsR0FBSTtnQkFDakI7WUFDSjtnQkFDSSxJQUFJLENBQUM5RCxLQUFLLEdBQUc7Z0JBQ2IsT0FBTyxDQUFDO1FBQ2hCO1FBQ0EsSUFBSSxDQUFDZ0UsYUFBYSxHQUFHLENBQUNTLFNBQVMsQ0FBQyxFQUFFLEdBQUcsSUFBRyxNQUFPO1FBQy9DLElBQUksQ0FBQ3hDLFNBQVMsR0FBRztRQUNqQixNQUFNMEMsZ0JBQWdCRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3JDLElBQUlFLGtCQUFrQixNQUFNO1lBQ3hCLElBQUksQ0FBQ1osU0FBUyxHQUFJWTtZQUNsQixJQUFJLENBQUMvQixXQUFXLEdBQUc7UUFDdkIsT0FDSztZQUNELElBQUlnQyxRQUFRO1lBQ1osSUFBSUMscUJBQXFCLElBQUksQ0FBQzNDLFlBQVksR0FBRyxJQUFJekMsV0FBVztZQUM1RCxJQUFJcUYsMkJBQTJCO1lBQy9CLE1BQU9MLFNBQVMsQ0FBQ0csTUFBTSxHQUFHLEtBQU07Z0JBQzVCQyxrQkFBa0IsQ0FBQ0QsUUFBUSxFQUFFLEdBQUdILFNBQVMsQ0FBQ0csTUFBTSxHQUFHO2dCQUNuREE7Z0JBQ0EsSUFBSUEsU0FBU0gsVUFBVXBGLE1BQU0sRUFBRTtvQkFDM0IsSUFBSSxDQUFDVyxLQUFLLEdBQUc7b0JBQ2IsT0FBTyxDQUFDO2dCQUNaO2dCQUNBLElBQUk0RSxVQUFVRSwwQkFBMEI7b0JBQ3BDQSw0QkFBNEI7b0JBQzVCLE1BQU1DLGlCQUFpQixJQUFJdEYsV0FBV3FGO29CQUN0QyxJQUFLLElBQUkxRixJQUFJLEdBQUdBLElBQUl5RixtQkFBbUJ4RixNQUFNLEVBQUVELElBQzNDMkYsY0FBYyxDQUFDM0YsRUFBRSxHQUFHeUYsa0JBQWtCLENBQUN6RixFQUFFO29CQUM3Q3lGLHFCQUFxQixJQUFJLENBQUMzQyxZQUFZLEdBQUcsSUFBSXpDLFdBQVdxRjtnQkFDNUQ7WUFDSjtZQUNBLElBQUksQ0FBQ2xDLFdBQVcsR0FBSWdDLFFBQVE7WUFDNUJDLGtCQUFrQixDQUFDRCxRQUFRLEVBQUUsR0FBR0gsU0FBUyxDQUFDRyxNQUFNLEdBQUc7WUFDbkQsTUFBTUcsaUJBQWlCLElBQUl0RixXQUFXbUY7WUFDdEMsSUFBSyxJQUFJeEYsSUFBSSxHQUFHQSxJQUFJd0YsT0FBT3hGLElBQ3ZCMkYsY0FBYyxDQUFDM0YsRUFBRSxHQUFHeUYsa0JBQWtCLENBQUN6RixFQUFFO1lBQzdDeUYscUJBQXFCLElBQUksQ0FBQzNDLFlBQVksR0FBRyxJQUFJekMsV0FBV21GO1lBQ3hEQyxtQkFBbUJuRixHQUFHLENBQUNxRjtZQUN2QixJQUFJLElBQUksQ0FBQ25DLFdBQVcsSUFBSSxHQUNwQixJQUFJLENBQUNtQixTQUFTLEdBQUduRixtQkFBbUJvRyxZQUFZLENBQUNILG9CQUFvQjtpQkFDcEU7Z0JBQ0QsSUFBSSxDQUFDNUMsU0FBUyxHQUFHO2dCQUNqQixJQUFJLENBQUNVLFFBQVEsQ0FBQ3JDLElBQUksQ0FBQztZQUN2QjtRQUNKO1FBQ0EsSUFBSSxJQUFNLENBQUN3RCxRQUFRLEtBQUssS0FDbkIsSUFBSSxDQUFDRSxhQUFhLEVBQUc7WUFDdEIsT0FBUSxJQUFJLENBQUNELFNBQVM7Z0JBQ2xCLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0QsSUFBSSxDQUFDL0QsS0FBSyxHQUFHO29CQUNiLE9BQU8sQ0FBQztZQUNoQjtRQUNKO1FBQ0EsT0FBUUYsY0FBYyxJQUFJLENBQUM4QyxXQUFXO0lBQzFDO0lBQ0FHLFNBQVM7UUFDTCxPQUFPO1lBQ0gsR0FBRyxLQUFLLENBQUNBLFFBQVE7WUFDakJlLFVBQVUsSUFBSSxDQUFDQSxRQUFRO1lBQ3ZCQyxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QkMsZUFBZSxJQUFJLENBQUNBLGFBQWE7UUFDckM7SUFDSjtBQUNKO0FBQ0FQLHlCQUF5Qi9DLElBQUksR0FBRztBQUVoQyxNQUFNdUUseUJBQXlCL0I7SUFDM0JoRCxZQUFZLEVBQUVnRixXQUFXLENBQUMsQ0FBQyxFQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDakMsSUFBSXJELElBQUk4QixJQUFJQztRQUNaLEtBQUs7UUFDTCxJQUFJLENBQUN1QixnQkFBZ0IsR0FBRyxDQUFDdEQsS0FBS3FELFNBQVNDLGdCQUFnQixNQUFNLFFBQVF0RCxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUMxRixJQUFJLENBQUN1RCxZQUFZLEdBQUcsQ0FBQ3pCLEtBQUt1QixTQUFTRSxZQUFZLE1BQU0sUUFBUXpCLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ2xGLElBQUksQ0FBQ3RFLE1BQU0sR0FBRyxDQUFDdUUsS0FBS3NCLFNBQVM3RixNQUFNLE1BQU0sUUFBUXVFLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0lBQzFFO0lBQ0FyQixRQUFRMUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxNQUFNeUMsT0FBTzdELHFCQUFxQnlELHFCQUFxQixDQUFDQyxZQUFZLENBQUN4QztRQUNyRSxJQUFJLENBQUNGLGtCQUFrQixJQUFJLEVBQUU2QyxNQUFNMUMsYUFBYUMsY0FBYztZQUMxRCxPQUFPLENBQUM7UUFDWjtRQUNBLE1BQU0wRSxZQUFZakMsS0FBS0UsUUFBUSxDQUFDNUMsYUFBYUEsY0FBY0M7UUFDM0QsSUFBSTBFLFVBQVVwRixNQUFNLEtBQUssR0FBRztZQUN4QixJQUFJLENBQUNXLEtBQUssR0FBRztZQUNiLE9BQU8sQ0FBQztRQUNaO1FBQ0EsSUFBSXlFLFNBQVMsQ0FBQyxFQUFFLEtBQUssTUFBTTtZQUN2QixJQUFJLENBQUN6RSxLQUFLLEdBQUc7WUFDYixPQUFPLENBQUM7UUFDWjtRQUNBLElBQUksQ0FBQ21GLGdCQUFnQixHQUFHVixTQUFTLENBQUMsRUFBRSxLQUFLO1FBQ3pDLElBQUksSUFBSSxDQUFDVSxnQkFBZ0IsRUFBRTtZQUN2QixJQUFJLENBQUN2QyxXQUFXLEdBQUc7WUFDbkIsT0FBUTlDLGNBQWMsSUFBSSxDQUFDOEMsV0FBVztRQUMxQztRQUNBLElBQUksQ0FBQ3dDLFlBQVksR0FBRyxDQUFDLENBQUVYLENBQUFBLFNBQVMsQ0FBQyxFQUFFLEdBQUcsSUFBRztRQUN6QyxJQUFJLElBQUksQ0FBQ1csWUFBWSxLQUFLLE9BQU87WUFDN0IsSUFBSSxDQUFDL0YsTUFBTSxHQUFJb0YsU0FBUyxDQUFDLEVBQUU7WUFDM0IsSUFBSSxDQUFDN0IsV0FBVyxHQUFHO1lBQ25CLE9BQVE5QyxjQUFjLElBQUksQ0FBQzhDLFdBQVc7UUFDMUM7UUFDQSxNQUFNZ0MsUUFBUUgsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUM3QixJQUFJRyxRQUFRLEdBQUc7WUFDWCxJQUFJLENBQUM1RSxLQUFLLEdBQUc7WUFDYixPQUFPLENBQUM7UUFDWjtRQUNBLElBQUksUUFBUyxJQUFLeUUsVUFBVXBGLE1BQU0sRUFBRTtZQUNoQyxJQUFJLENBQUNXLEtBQUssR0FBRztZQUNiLE9BQU8sQ0FBQztRQUNaO1FBQ0EsTUFBTXFGLFlBQVl2RixjQUFjO1FBQ2hDLE1BQU13RixtQkFBbUI5QyxLQUFLRSxRQUFRLENBQUMyQyxXQUFXQSxZQUFZVDtRQUM5RCxJQUFJVSxnQkFBZ0IsQ0FBQ1YsUUFBUSxFQUFFLEtBQUssTUFDaEMsSUFBSSxDQUFDakMsUUFBUSxDQUFDckMsSUFBSSxDQUFDO1FBQ3ZCLElBQUksQ0FBQ2pCLE1BQU0sR0FBR1QsbUJBQW1Cb0csWUFBWSxDQUFDTSxrQkFBa0I7UUFDaEUsSUFBSSxJQUFJLENBQUNGLFlBQVksSUFBSyxJQUFJLENBQUMvRixNQUFNLElBQUksS0FDckMsSUFBSSxDQUFDc0QsUUFBUSxDQUFDckMsSUFBSSxDQUFDO1FBQ3ZCLElBQUksQ0FBQ3NDLFdBQVcsR0FBR2dDLFFBQVE7UUFDM0IsT0FBUTlFLGNBQWMsSUFBSSxDQUFDOEMsV0FBVztJQUMxQztJQUNBQyxNQUFNQyxXQUFXLEtBQUssRUFBRTtRQUNwQixJQUFJeUM7UUFDSixJQUFJL0Y7UUFDSixJQUFJLElBQUksQ0FBQ0gsTUFBTSxHQUFHLEtBQ2QsSUFBSSxDQUFDK0YsWUFBWSxHQUFHO1FBQ3hCLElBQUksSUFBSSxDQUFDRCxnQkFBZ0IsRUFBRTtZQUN2QkksU0FBUyxJQUFJakUsWUFBWTtZQUN6QixJQUFJd0IsYUFBYSxPQUFPO2dCQUNwQnRELFVBQVUsSUFBSUMsV0FBVzhGO2dCQUN6Qi9GLE9BQU8sQ0FBQyxFQUFFLEdBQUc7WUFDakI7WUFDQSxPQUFPK0Y7UUFDWDtRQUNBLElBQUksSUFBSSxDQUFDSCxZQUFZLEVBQUU7WUFDbkIsTUFBTWpCLGFBQWF2RixtQkFBbUJ3RixVQUFVLENBQUMsSUFBSSxDQUFDL0UsTUFBTSxFQUFFO1lBQzlELElBQUk4RSxXQUFXNUUsVUFBVSxHQUFHLEtBQUs7Z0JBQzdCLElBQUksQ0FBQ1MsS0FBSyxHQUFHO2dCQUNiLE9BQVFxQjtZQUNaO1lBQ0FrRSxTQUFTLElBQUlqRSxZQUFZNkMsV0FBVzVFLFVBQVUsR0FBRztZQUNqRCxJQUFJdUQsVUFDQSxPQUFPeUM7WUFDWCxNQUFNbEIsY0FBYyxJQUFJNUUsV0FBVzBFO1lBQ25DM0UsVUFBVSxJQUFJQyxXQUFXOEY7WUFDekIvRixPQUFPLENBQUMsRUFBRSxHQUFHMkUsV0FBVzVFLFVBQVUsR0FBRztZQUNyQyxJQUFLLElBQUlILElBQUksR0FBR0EsSUFBSStFLFdBQVc1RSxVQUFVLEVBQUVILElBQ3ZDSSxPQUFPLENBQUNKLElBQUksRUFBRSxHQUFHaUYsV0FBVyxDQUFDakYsRUFBRTtZQUNuQyxPQUFPbUc7UUFDWDtRQUNBQSxTQUFTLElBQUlqRSxZQUFZO1FBQ3pCLElBQUl3QixhQUFhLE9BQU87WUFDcEJ0RCxVQUFVLElBQUlDLFdBQVc4RjtZQUN6Qi9GLE9BQU8sQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDSCxNQUFNO1FBQzVCO1FBQ0EsT0FBT2tHO0lBQ1g7SUFDQXhDLFNBQVM7UUFDTCxPQUFPO1lBQ0gsR0FBRyxLQUFLLENBQUNBLFFBQVE7WUFDakJvQyxrQkFBa0IsSUFBSSxDQUFDQSxnQkFBZ0I7WUFDdkNDLGNBQWMsSUFBSSxDQUFDQSxZQUFZO1lBQy9CL0YsUUFBUSxJQUFJLENBQUNBLE1BQU07UUFDdkI7SUFDSjtBQUNKO0FBQ0E0RixpQkFBaUJ2RSxJQUFJLEdBQUc7QUFFeEIsTUFBTThFLFlBQVksQ0FBQztBQUVuQixNQUFNQyxrQkFBa0J2QztJQUNwQmhELFlBQVksRUFBRXdGLE9BQU90RSxZQUFZLEVBQUV1RSxXQUFXLEtBQUssRUFBRUMsZUFBZSxFQUFFLEdBQUdDLFlBQVksR0FBRyxDQUFDLENBQUMsRUFBRUMsY0FBYyxDQUFFO1FBQ3hHLEtBQUssQ0FBQ0Q7UUFDTixJQUFJLENBQUNILElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSUMsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQ0EsZUFBZSxHQUFHQTtRQUMzQjtRQUNBLElBQUksQ0FBQ2xDLE9BQU8sR0FBRyxJQUFJRCx5QkFBeUJvQztRQUM1QyxJQUFJLENBQUNYLFFBQVEsR0FBRyxJQUFJRCxpQkFBaUJZO1FBQ3JDLElBQUksQ0FBQ0UsVUFBVSxHQUFHRCxpQkFBaUIsSUFBSUEsZUFBZUQsY0FBYyxJQUFJdkMsV0FBV3VDO0lBQ3ZGO0lBQ0F0RCxRQUFRMUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxNQUFNaUcsZUFBZSxJQUFJLENBQUNELFVBQVUsQ0FBQ3hELE9BQU8sQ0FBQzFDLGFBQWFDLGFBQWEsSUFBSyxDQUFDb0YsUUFBUSxDQUFDQyxnQkFBZ0IsR0FBSXBGLGNBQWMsSUFBSSxDQUFDbUYsUUFBUSxDQUFDN0YsTUFBTTtRQUM1SSxJQUFJMkcsaUJBQWlCLENBQUMsR0FBRztZQUNyQixJQUFJLENBQUNoRyxLQUFLLEdBQUcsSUFBSSxDQUFDK0YsVUFBVSxDQUFDL0YsS0FBSztZQUNsQyxPQUFPZ0c7UUFDWDtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUN0QyxPQUFPLENBQUMxRCxLQUFLLENBQUNYLE1BQU0sRUFDMUIsSUFBSSxDQUFDdUQsV0FBVyxJQUFJLElBQUksQ0FBQ2MsT0FBTyxDQUFDZCxXQUFXO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUNzQyxRQUFRLENBQUNsRixLQUFLLENBQUNYLE1BQU0sRUFDM0IsSUFBSSxDQUFDdUQsV0FBVyxJQUFJLElBQUksQ0FBQ3NDLFFBQVEsQ0FBQ3RDLFdBQVc7UUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQ21ELFVBQVUsQ0FBQy9GLEtBQUssQ0FBQ1gsTUFBTSxFQUM3QixJQUFJLENBQUN1RCxXQUFXLElBQUksSUFBSSxDQUFDbUQsVUFBVSxDQUFDbkQsV0FBVztRQUNuRCxPQUFPb0Q7SUFDWDtJQUNBbkQsTUFBTUMsUUFBUSxFQUFFVSxNQUFNLEVBQUU7UUFDcEIsTUFBTXlDLFVBQVV6QyxVQUFVLElBQUl2RDtRQUM5QixJQUFJLENBQUN1RCxRQUFRO1lBQ1QwQyxzQkFBc0IsSUFBSTtRQUM5QjtRQUNBLE1BQU1DLGFBQWEsSUFBSSxDQUFDekMsT0FBTyxDQUFDYixLQUFLLENBQUNDO1FBQ3RDbUQsUUFBUTdGLEtBQUssQ0FBQytGO1FBQ2QsSUFBSSxJQUFJLENBQUNqQixRQUFRLENBQUNDLGdCQUFnQixFQUFFO1lBQ2hDYyxRQUFRN0YsS0FBSyxDQUFDLElBQUlYLFdBQVc7Z0JBQUM7YUFBSyxFQUFFSCxNQUFNO1lBQzNDLElBQUksQ0FBQ3lHLFVBQVUsQ0FBQ2xELEtBQUssQ0FBQ0MsVUFBVW1EO1lBQ2hDQSxRQUFRN0YsS0FBSyxDQUFDLElBQUlrQixZQUFZO1FBQ2xDLE9BQ0s7WUFDRCxNQUFNOEUsZ0JBQWdCLElBQUksQ0FBQ0wsVUFBVSxDQUFDbEQsS0FBSyxDQUFDQztZQUM1QyxJQUFJLENBQUNvQyxRQUFRLENBQUM3RixNQUFNLEdBQUcrRyxjQUFjN0csVUFBVTtZQUMvQyxNQUFNOEcsY0FBYyxJQUFJLENBQUNuQixRQUFRLENBQUNyQyxLQUFLLENBQUNDO1lBQ3hDbUQsUUFBUTdGLEtBQUssQ0FBQ2lHO1lBQ2RKLFFBQVE3RixLQUFLLENBQUNnRztRQUNsQjtRQUNBLElBQUksQ0FBQzVDLFFBQVE7WUFDVCxPQUFPeUMsUUFBUTFGLEtBQUs7UUFDeEI7UUFDQSxPQUFPYztJQUNYO0lBQ0EwQixTQUFTO1FBQ0wsTUFBTXVELFNBQVM7WUFDWCxHQUFHLEtBQUssQ0FBQ3ZELFFBQVE7WUFDakJXLFNBQVMsSUFBSSxDQUFDQSxPQUFPLENBQUNYLE1BQU07WUFDNUJtQyxVQUFVLElBQUksQ0FBQ0EsUUFBUSxDQUFDbkMsTUFBTTtZQUM5QmdELFlBQVksSUFBSSxDQUFDQSxVQUFVLENBQUNoRCxNQUFNO1lBQ2xDMkMsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkMsVUFBVSxJQUFJLENBQUNBLFFBQVE7UUFDM0I7UUFDQSxJQUFJLElBQUksQ0FBQ0MsZUFBZSxFQUNwQlUsT0FBT1YsZUFBZSxHQUFHLElBQUksQ0FBQ0EsZUFBZSxDQUFDN0MsTUFBTTtRQUN4RCxPQUFPdUQ7SUFDWDtJQUNBQyxTQUFTQyxXQUFXLE9BQU8sRUFBRTtRQUN6QixJQUFJQSxhQUFhLFNBQVM7WUFDdEIsT0FBTyxJQUFJLENBQUNDLGVBQWU7UUFDL0I7UUFDQSxPQUFPOUgscUJBQXFCcUUsT0FBTyxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDSixLQUFLO0lBQ3hEO0lBQ0E0RCxrQkFBa0I7UUFDZCxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUN2RyxXQUFXLENBQUNRLElBQUksQ0FBQyxHQUFHLEVBQUUvQixxQkFBcUJxRSxPQUFPLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUM4QyxVQUFVLENBQUMzQyxxQkFBcUIsRUFBRSxDQUFDO0lBQ3BIO0lBQ0FzRCxRQUFRQyxLQUFLLEVBQUU7UUFDWCxJQUFJLElBQUksS0FBS0EsT0FBTztZQUNoQixPQUFPO1FBQ1g7UUFDQSxJQUFJLENBQUVBLENBQUFBLGlCQUFpQixJQUFJLENBQUN6RyxXQUFXLEdBQUc7WUFDdEMsT0FBTztRQUNYO1FBQ0EsTUFBTTBHLFVBQVUsSUFBSSxDQUFDL0QsS0FBSztRQUMxQixNQUFNZ0UsV0FBV0YsTUFBTTlELEtBQUs7UUFDNUIsT0FBT2pFLG1CQUFtQmtJLGFBQWEsQ0FBQ0YsU0FBU0M7SUFDckQ7QUFDSjtBQUNBcEIsVUFBVS9FLElBQUksR0FBRztBQUNqQixTQUFTd0Ysc0JBQXNCdEcsU0FBUztJQUNwQyxJQUFJQSxxQkFBcUI0RixVQUFVdUIsV0FBVyxFQUFFO1FBQzVDLEtBQUssTUFBTXJKLFNBQVNrQyxVQUFVbUcsVUFBVSxDQUFDckksS0FBSyxDQUFFO1lBQzVDLElBQUl3SSxzQkFBc0J4SSxRQUFRO2dCQUM5QmtDLFVBQVVzRixRQUFRLENBQUNDLGdCQUFnQixHQUFHO1lBQzFDO1FBQ0o7SUFDSjtJQUNBLE9BQU8sQ0FBQyxDQUFDdkYsVUFBVXNGLFFBQVEsQ0FBQ0MsZ0JBQWdCO0FBQ2hEO0FBRUEsTUFBTTZCLHdCQUF3QnZCO0lBQzFCdkYsWUFBWSxFQUFFeEMsUUFBUTBELFlBQVksRUFBRSxHQUFHeUUsWUFBWSxHQUFHLENBQUMsQ0FBQyxFQUFFb0Isb0JBQW9CLENBQUU7UUFDNUUsS0FBSyxDQUFDcEIsWUFBWW9CO1FBQ2xCLElBQUl2SixPQUFPO1lBQ1AsSUFBSSxDQUFDd0osVUFBVSxDQUFDeEo7UUFDcEI7SUFDSjtJQUNBeUosV0FBVztRQUNQLE9BQU8sSUFBSSxDQUFDcEIsVUFBVSxDQUFDckksS0FBSztJQUNoQztJQUNBMEosU0FBUzFKLEtBQUssRUFBRTtRQUNaLElBQUksQ0FBQ3FJLFVBQVUsQ0FBQ3JJLEtBQUssR0FBR0E7SUFDNUI7SUFDQTZFLFFBQVExQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFO1FBQzNDLE1BQU1pRyxlQUFlLElBQUksQ0FBQ0QsVUFBVSxDQUFDeEQsT0FBTyxDQUFDMUMsYUFBYUMsYUFBYSxJQUFLLENBQUNvRixRQUFRLENBQUNDLGdCQUFnQixHQUFJcEYsY0FBYyxJQUFJLENBQUNtRixRQUFRLENBQUM3RixNQUFNO1FBQzVJLElBQUkyRyxpQkFBaUIsQ0FBQyxHQUFHO1lBQ3JCLElBQUksQ0FBQ2hHLEtBQUssR0FBRyxJQUFJLENBQUMrRixVQUFVLENBQUMvRixLQUFLO1lBQ2xDLE9BQU9nRztRQUNYO1FBQ0EsSUFBSSxDQUFDcUIsVUFBVSxDQUFDLElBQUksQ0FBQ3RCLFVBQVUsQ0FBQzdELFlBQVk7UUFDNUMsSUFBSSxDQUFDLElBQUksQ0FBQ3dCLE9BQU8sQ0FBQzFELEtBQUssQ0FBQ1gsTUFBTSxFQUMxQixJQUFJLENBQUN1RCxXQUFXLElBQUksSUFBSSxDQUFDYyxPQUFPLENBQUNkLFdBQVc7UUFDaEQsSUFBSSxDQUFDLElBQUksQ0FBQ3NDLFFBQVEsQ0FBQ2xGLEtBQUssQ0FBQ1gsTUFBTSxFQUMzQixJQUFJLENBQUN1RCxXQUFXLElBQUksSUFBSSxDQUFDc0MsUUFBUSxDQUFDdEMsV0FBVztRQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDbUQsVUFBVSxDQUFDL0YsS0FBSyxDQUFDWCxNQUFNLEVBQzdCLElBQUksQ0FBQ3VELFdBQVcsSUFBSSxJQUFJLENBQUNtRCxVQUFVLENBQUNuRCxXQUFXO1FBQ25ELE9BQU9vRDtJQUNYO0lBQ0FTLGtCQUFrQjtRQUNkLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQ3ZHLFdBQVcsQ0FBQ1EsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUNxRixVQUFVLENBQUNySSxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2xFO0FBQ0o7QUFDQXNKLGdCQUFnQnRHLElBQUksR0FBRztBQUV2QixNQUFNNEcsaUNBQWlDM0YsU0FBUzJCO0lBQzVDcEQsWUFBWSxFQUFFK0IsWUFBWSxJQUFJLEVBQUUsR0FBRzRELFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNsRCxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDNUQsU0FBUyxHQUFHQTtJQUNyQjtBQUNKO0FBQ0FxRix5QkFBeUI1RyxJQUFJLEdBQUc7QUFFaEMsSUFBSTZHO0FBQ0osTUFBTUMsa0JBQWtCL0I7SUFDcEJ2RixZQUFZMkYsYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBLFlBQVl5QjtRQUNsQixJQUFJLENBQUM1RCxPQUFPLENBQUNNLGFBQWEsR0FBRztJQUNqQztBQUNKO0FBQ0F1RCxPQUFPQztBQUNOO0lBQ0doQyxVQUFVZ0MsU0FBUyxHQUFHRDtBQUMxQjtBQUNBQyxVQUFVOUcsSUFBSSxHQUFHO0FBRWpCLFNBQVMrRyxnQkFBZ0JDLFdBQVcsRUFBRUMsT0FBTztJQUN6QyxJQUFJRCx1QkFBdUJDLFNBQVM7UUFDaEMsT0FBT0Q7SUFDWDtJQUNBLE1BQU1FLFlBQVksSUFBSUQ7SUFDdEJDLFVBQVVsRSxPQUFPLEdBQUdnRSxZQUFZaEUsT0FBTztJQUN2Q2tFLFVBQVUxQyxRQUFRLEdBQUd3QyxZQUFZeEMsUUFBUTtJQUN6QzBDLFVBQVVqRixRQUFRLEdBQUcrRSxZQUFZL0UsUUFBUTtJQUN6Q2lGLFVBQVV4RSxxQkFBcUIsR0FBR3NFLFlBQVl0RSxxQkFBcUI7SUFDbkUsT0FBT3dFO0FBQ1g7QUFDQSxTQUFTQyxhQUFhaEksV0FBVyxFQUFFQyxjQUFjLENBQUMsRUFBRUMsY0FBY0YsWUFBWVIsTUFBTTtJQUNoRixNQUFNeUksaUJBQWlCaEk7SUFDdkIsSUFBSWlJLGVBQWUsSUFBSXRDLFVBQVUsQ0FBQyxHQUFHbkM7SUFDckMsTUFBTTFELFlBQVksSUFBSXNEO0lBQ3RCLElBQUksQ0FBQ3ZELGtCQUFrQkMsV0FBV0MsYUFBYUMsYUFBYUMsY0FBYztRQUN0RWdJLGFBQWEvSCxLQUFLLEdBQUdKLFVBQVVJLEtBQUs7UUFDcEMsT0FBTztZQUNIZ0ksUUFBUSxDQUFDO1lBQ1RDLFFBQVFGO1FBQ1o7SUFDSjtJQUNBLE1BQU10RCxZQUFZNUUsWUFBWTZDLFFBQVEsQ0FBQzVDLGFBQWFBLGNBQWNDO0lBQ2xFLElBQUksQ0FBQzBFLFVBQVVwRixNQUFNLEVBQUU7UUFDbkIwSSxhQUFhL0gsS0FBSyxHQUFHO1FBQ3JCLE9BQU87WUFDSGdJLFFBQVEsQ0FBQztZQUNUQyxRQUFRRjtRQUNaO0lBQ0o7SUFDQSxJQUFJL0IsZUFBZStCLGFBQWFyRSxPQUFPLENBQUNuQixPQUFPLENBQUMxQyxhQUFhQyxhQUFhQztJQUMxRSxJQUFJZ0ksYUFBYXJFLE9BQU8sQ0FBQ2YsUUFBUSxDQUFDdEQsTUFBTSxFQUFFO1FBQ3RDMEksYUFBYXBGLFFBQVEsQ0FBQzNELE1BQU0sQ0FBQytJLGFBQWFyRSxPQUFPLENBQUNmLFFBQVE7SUFDOUQ7SUFDQSxJQUFJcUQsaUJBQWlCLENBQUMsR0FBRztRQUNyQitCLGFBQWEvSCxLQUFLLEdBQUcrSCxhQUFhckUsT0FBTyxDQUFDMUQsS0FBSztRQUMvQyxPQUFPO1lBQ0hnSSxRQUFRLENBQUM7WUFDVEMsUUFBUUY7UUFDWjtJQUNKO0lBQ0FqSSxjQUFja0c7SUFDZGpHLGVBQWVnSSxhQUFhckUsT0FBTyxDQUFDZCxXQUFXO0lBQy9Db0QsZUFBZStCLGFBQWE3QyxRQUFRLENBQUMzQyxPQUFPLENBQUMxQyxhQUFhQyxhQUFhQztJQUN2RSxJQUFJZ0ksYUFBYTdDLFFBQVEsQ0FBQ3ZDLFFBQVEsQ0FBQ3RELE1BQU0sRUFBRTtRQUN2QzBJLGFBQWFwRixRQUFRLENBQUMzRCxNQUFNLENBQUMrSSxhQUFhN0MsUUFBUSxDQUFDdkMsUUFBUTtJQUMvRDtJQUNBLElBQUlxRCxpQkFBaUIsQ0FBQyxHQUFHO1FBQ3JCK0IsYUFBYS9ILEtBQUssR0FBRytILGFBQWE3QyxRQUFRLENBQUNsRixLQUFLO1FBQ2hELE9BQU87WUFDSGdJLFFBQVEsQ0FBQztZQUNUQyxRQUFRRjtRQUNaO0lBQ0o7SUFDQWpJLGNBQWNrRztJQUNkakcsZUFBZWdJLGFBQWE3QyxRQUFRLENBQUN0QyxXQUFXO0lBQ2hELElBQUksQ0FBQ21GLGFBQWFyRSxPQUFPLENBQUNNLGFBQWEsSUFDbkMrRCxhQUFhN0MsUUFBUSxDQUFDQyxnQkFBZ0IsRUFBRTtRQUN4QzRDLGFBQWEvSCxLQUFLLEdBQUc7UUFDckIsT0FBTztZQUNIZ0ksUUFBUSxDQUFDO1lBQ1RDLFFBQVFGO1FBQ1o7SUFDSjtJQUNBLElBQUlHLGNBQWN6QztJQUNsQixPQUFRc0MsYUFBYXJFLE9BQU8sQ0FBQ0ksUUFBUTtRQUNqQyxLQUFLO1lBQ0QsSUFBSSxhQUFjSixPQUFPLENBQUNLLFNBQVMsSUFBSSxNQUNsQ2dFLGFBQWFyRSxPQUFPLENBQUN6QixTQUFTLEtBQUssT0FBUTtnQkFDNUM4RixhQUFhL0gsS0FBSyxHQUFHO2dCQUNyQixPQUFPO29CQUNIZ0ksUUFBUSxDQUFDO29CQUNUQyxRQUFRRjtnQkFDWjtZQUNKO1lBQ0EsT0FBUUEsYUFBYXJFLE9BQU8sQ0FBQ0ssU0FBUztnQkFDbEMsS0FBSztvQkFDRCxJQUFJLGFBQWNMLE9BQU8sQ0FBQ00sYUFBYSxJQUNsQytELGFBQWE3QyxRQUFRLENBQUM3RixNQUFNLEdBQUcsR0FBSTt3QkFDcEMwSSxhQUFhL0gsS0FBSyxHQUFHO3dCQUNyQixPQUFPOzRCQUNIZ0ksUUFBUSxDQUFDOzRCQUNUQyxRQUFRRjt3QkFDWjtvQkFDSjtvQkFDQUcsY0FBYzFDLFVBQVUyQyxZQUFZO29CQUNwQztnQkFDSixLQUFLO29CQUNERCxjQUFjMUMsVUFBVTRDLE9BQU87b0JBQy9CO2dCQUNKLEtBQUs7b0JBQ0RGLGNBQWMxQyxVQUFVNkMsT0FBTztvQkFDL0I7Z0JBQ0osS0FBSztvQkFDREgsY0FBYzFDLFVBQVU4QyxTQUFTO29CQUNqQztnQkFDSixLQUFLO29CQUNESixjQUFjMUMsVUFBVStDLFdBQVc7b0JBQ25DO2dCQUNKLEtBQUs7b0JBQ0RMLGNBQWMxQyxVQUFVZ0QsSUFBSTtvQkFDNUI7Z0JBQ0osS0FBSztvQkFDRE4sY0FBYzFDLFVBQVVpRCxnQkFBZ0I7b0JBQ3hDO2dCQUNKLEtBQUs7b0JBQ0RQLGNBQWMxQyxVQUFVa0QsVUFBVTtvQkFDbEM7Z0JBQ0osS0FBSztvQkFDRFIsY0FBYzFDLFVBQVVtRCxVQUFVO29CQUNsQztnQkFDSixLQUFLO29CQUNEVCxjQUFjMUMsVUFBVW9ELHdCQUF3QjtvQkFDaEQ7Z0JBQ0osS0FBSztvQkFDRFYsY0FBYzFDLFVBQVVxRCxJQUFJO29CQUM1QjtnQkFDSixLQUFLO29CQUNEZCxhQUFhL0gsS0FBSyxHQUFHO29CQUNyQixPQUFPO3dCQUNIZ0ksUUFBUSxDQUFDO3dCQUNUQyxRQUFRRjtvQkFDWjtnQkFDSixLQUFLO29CQUNERyxjQUFjMUMsVUFBVXNELFFBQVE7b0JBQ2hDO2dCQUNKLEtBQUs7b0JBQ0RaLGNBQWMxQyxVQUFVdUQsR0FBRztvQkFDM0I7Z0JBQ0osS0FBSztvQkFDRGIsY0FBYzFDLFVBQVV3RCxhQUFhO29CQUNyQztnQkFDSixLQUFLO29CQUNEZCxjQUFjMUMsVUFBVXlELGVBQWU7b0JBQ3ZDO2dCQUNKLEtBQUs7b0JBQ0RmLGNBQWMxQyxVQUFVMEQsYUFBYTtvQkFDckM7Z0JBQ0osS0FBSztvQkFDRGhCLGNBQWMxQyxVQUFVMkQsY0FBYztvQkFDdEM7Z0JBQ0osS0FBSztvQkFDRGpCLGNBQWMxQyxVQUFVNEQsU0FBUztvQkFDakM7Z0JBQ0osS0FBSztvQkFDRGxCLGNBQWMxQyxVQUFVNkQsT0FBTztvQkFDL0I7Z0JBQ0osS0FBSztvQkFDRG5CLGNBQWMxQyxVQUFVOEQsZUFBZTtvQkFDdkM7Z0JBQ0osS0FBSztvQkFDRHBCLGNBQWMxQyxVQUFVK0QsYUFBYTtvQkFDckM7Z0JBQ0osS0FBSztvQkFDRHJCLGNBQWMxQyxVQUFVZ0UsYUFBYTtvQkFDckM7Z0JBQ0osS0FBSztvQkFDRHRCLGNBQWMxQyxVQUFVaUUsYUFBYTtvQkFDckM7Z0JBQ0osS0FBSztvQkFDRHZCLGNBQWMxQyxVQUFVa0UsZUFBZTtvQkFDdkM7Z0JBQ0osS0FBSztvQkFDRHhCLGNBQWMxQyxVQUFVbUUsZUFBZTtvQkFDdkM7Z0JBQ0osS0FBSztvQkFDRHpCLGNBQWMxQyxVQUFVb0UsU0FBUztvQkFDakM7Z0JBQ0osS0FBSztvQkFDRDFCLGNBQWMxQyxVQUFVcUUsSUFBSTtvQkFDNUI7Z0JBQ0osS0FBSztvQkFDRDNCLGNBQWMxQyxVQUFVc0UsU0FBUztvQkFDakM7Z0JBQ0osS0FBSztvQkFDRDVCLGNBQWMxQyxVQUFVdUUsUUFBUTtvQkFDaEM7Z0JBQ0osS0FBSztvQkFDRDdCLGNBQWMxQyxVQUFVd0UsUUFBUTtvQkFDaEM7Z0JBQ0o7b0JBQVM7d0JBQ0wsTUFBTXBDLFlBQVlHLGFBQWFyRSxPQUFPLENBQUNNLGFBQWEsR0FDOUMsSUFBSXdCLFVBQVV1QixXQUFXLEtBQ3pCLElBQUl2QixVQUFVZ0MsU0FBUzt3QkFDN0JJLFVBQVVsRSxPQUFPLEdBQUdxRSxhQUFhckUsT0FBTzt3QkFDeENrRSxVQUFVMUMsUUFBUSxHQUFHNkMsYUFBYTdDLFFBQVE7d0JBQzFDMEMsVUFBVWpGLFFBQVEsR0FBR29GLGFBQWFwRixRQUFRO3dCQUMxQ29GLGVBQWVIO29CQUNuQjtZQUNKO1lBQ0E7UUFDSixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTDtZQUFTO2dCQUNMTSxjQUFjSCxhQUFhckUsT0FBTyxDQUFDTSxhQUFhLEdBQzFDd0IsVUFBVXVCLFdBQVcsR0FDckJ2QixVQUFVZ0MsU0FBUztZQUM3QjtJQUNKO0lBQ0FPLGVBQWVOLGdCQUFnQk0sY0FBY0c7SUFDN0NsQyxlQUFlK0IsYUFBYXhGLE9BQU8sQ0FBQzFDLGFBQWFDLGFBQWFpSSxhQUFhN0MsUUFBUSxDQUFDQyxnQkFBZ0IsR0FBR3BGLGNBQWNnSSxhQUFhN0MsUUFBUSxDQUFDN0YsTUFBTTtJQUNqSjBJLGFBQWEzRSxxQkFBcUIsR0FBR3ZELFlBQVk2QyxRQUFRLENBQUNvRixnQkFBZ0JBLGlCQUFpQkMsYUFBYW5GLFdBQVc7SUFDbkgsT0FBTztRQUNIb0YsUUFBUWhDO1FBQ1JpQyxRQUFRRjtJQUNaO0FBQ0o7QUFDQSxTQUFTeEYsUUFBUTFDLFdBQVc7SUFDeEIsSUFBSSxDQUFDQSxZQUFZTixVQUFVLEVBQUU7UUFDekIsTUFBTTBJLFNBQVMsSUFBSXhDLFVBQVUsQ0FBQyxHQUFHbkM7UUFDakMyRSxPQUFPakksS0FBSyxHQUFHO1FBQ2YsT0FBTztZQUNIZ0ksUUFBUSxDQUFDO1lBQ1RDO1FBQ0o7SUFDSjtJQUNBLE9BQU9KLGFBQWFsSixxQkFBcUJ5RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDeEMsYUFBYXlDLEtBQUssSUFBSSxHQUFHekMsWUFBWU4sVUFBVTtBQUMvSDtBQUVBLFNBQVMwSyxTQUFTQyxnQkFBZ0IsRUFBRTdLLE1BQU07SUFDdEMsSUFBSTZLLGtCQUFrQjtRQUNsQixPQUFPO0lBQ1g7SUFDQSxPQUFPN0s7QUFDWDtBQUNBLE1BQU04SyxtQ0FBbUM3RztJQUNyQ3BELFlBQVksRUFBRXhDLFFBQVEsRUFBRSxFQUFFeUgsbUJBQW1CLEtBQUssRUFBRSxHQUFHVSxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDdEUsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ25JLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUN5SCxnQkFBZ0IsR0FBR0E7SUFDNUI7SUFDQTVDLFFBQVExQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFO1FBQzNDLE1BQU15QyxPQUFPN0QscUJBQXFCeUQscUJBQXFCLENBQUNDLFlBQVksQ0FBQ3hDO1FBQ3JFLElBQUksQ0FBQ0Ysa0JBQWtCLElBQUksRUFBRTZDLE1BQU0xQyxhQUFhQyxjQUFjO1lBQzFELE9BQU8sQ0FBQztRQUNaO1FBQ0EsSUFBSSxDQUFDcUQscUJBQXFCLEdBQUdaLEtBQUtFLFFBQVEsQ0FBQzVDLGFBQWFBLGNBQWNDO1FBQ3RFLElBQUksSUFBSSxDQUFDcUQscUJBQXFCLENBQUMvRCxNQUFNLEtBQUssR0FBRztZQUN6QyxJQUFJLENBQUNzRCxRQUFRLENBQUNyQyxJQUFJLENBQUM7WUFDbkIsT0FBT1I7UUFDWDtRQUNBLElBQUlzSyxnQkFBZ0J0SztRQUNwQixNQUFPbUssU0FBUyxJQUFJLENBQUM5RSxnQkFBZ0IsRUFBRXBGLGVBQWUsRUFBRztZQUNyRCxNQUFNZ0ksZUFBZUYsYUFBYXJGLE1BQU00SCxlQUFlcks7WUFDdkQsSUFBSWdJLGFBQWFDLE1BQU0sS0FBSyxDQUFDLEdBQUc7Z0JBQzVCLElBQUksQ0FBQ2hJLEtBQUssR0FBRytILGFBQWFFLE1BQU0sQ0FBQ2pJLEtBQUs7Z0JBQ3RDLElBQUksQ0FBQzJDLFFBQVEsQ0FBQzNELE1BQU0sQ0FBQytJLGFBQWFFLE1BQU0sQ0FBQ3RGLFFBQVE7Z0JBQ2pELE9BQU8sQ0FBQztZQUNaO1lBQ0F5SCxnQkFBZ0JyQyxhQUFhQyxNQUFNO1lBQ25DLElBQUksQ0FBQ3BGLFdBQVcsSUFBSW1GLGFBQWFFLE1BQU0sQ0FBQ3JGLFdBQVc7WUFDbkQ3QyxlQUFlZ0ksYUFBYUUsTUFBTSxDQUFDckYsV0FBVztZQUM5QyxJQUFJLENBQUNsRixLQUFLLENBQUM0QyxJQUFJLENBQUN5SCxhQUFhRSxNQUFNO1lBQ25DLElBQUksSUFBSSxDQUFDOUMsZ0JBQWdCLElBQUk0QyxhQUFhRSxNQUFNLENBQUMvSCxXQUFXLENBQUNRLElBQUksS0FBS2MscUJBQXFCO2dCQUN2RjtZQUNKO1FBQ0o7UUFDQSxJQUFJLElBQUksQ0FBQzJELGdCQUFnQixFQUFFO1lBQ3ZCLElBQUksSUFBSSxDQUFDekgsS0FBSyxDQUFDLElBQUksQ0FBQ0EsS0FBSyxDQUFDMkIsTUFBTSxHQUFHLEVBQUUsQ0FBQ2EsV0FBVyxDQUFDUSxJQUFJLEtBQUtjLHFCQUFxQjtnQkFDNUUsSUFBSSxDQUFDOUQsS0FBSyxDQUFDMk0sR0FBRztZQUNsQixPQUNLO2dCQUNELElBQUksQ0FBQzFILFFBQVEsQ0FBQ3JDLElBQUksQ0FBQztZQUN2QjtRQUNKO1FBQ0EsT0FBTzhKO0lBQ1g7SUFDQXZILE1BQU1DLFFBQVEsRUFBRVUsTUFBTSxFQUFFO1FBQ3BCLE1BQU15QyxVQUFVekMsVUFBVSxJQUFJdkQ7UUFDOUIsSUFBSyxJQUFJYixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDMUIsS0FBSyxDQUFDMkIsTUFBTSxFQUFFRCxJQUFLO1lBQ3hDLElBQUksQ0FBQzFCLEtBQUssQ0FBQzBCLEVBQUUsQ0FBQ3lELEtBQUssQ0FBQ0MsVUFBVW1EO1FBQ2xDO1FBQ0EsSUFBSSxDQUFDekMsUUFBUTtZQUNULE9BQU95QyxRQUFRMUYsS0FBSztRQUN4QjtRQUNBLE9BQU9jO0lBQ1g7SUFDQTBCLFNBQVM7UUFDTCxNQUFNdUQsU0FBUztZQUNYLEdBQUcsS0FBSyxDQUFDdkQsUUFBUTtZQUNqQm9DLGtCQUFrQixJQUFJLENBQUNBLGdCQUFnQjtZQUN2Q3pILE9BQU8sRUFBRTtRQUNiO1FBQ0EsS0FBSyxNQUFNQSxTQUFTLElBQUksQ0FBQ0EsS0FBSyxDQUFFO1lBQzVCNEksT0FBTzVJLEtBQUssQ0FBQzRDLElBQUksQ0FBQzVDLE1BQU1xRixNQUFNO1FBQ2xDO1FBQ0EsT0FBT3VEO0lBQ1g7QUFDSjtBQUNBNkQsMkJBQTJCekosSUFBSSxHQUFHO0FBRWxDLElBQUk0SjtBQUNKLE1BQU12RCxvQkFBb0J0QjtJQUN0QnZGLFlBQVkyRixhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0EsWUFBWXNFO1FBQ2xCLElBQUksQ0FBQ3pHLE9BQU8sQ0FBQ00sYUFBYSxHQUFHO0lBQ2pDO0lBQ0F6QixRQUFRMUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxJQUFJLENBQUNnRyxVQUFVLENBQUNaLGdCQUFnQixHQUFHLElBQUksQ0FBQ0QsUUFBUSxDQUFDQyxnQkFBZ0I7UUFDakUsTUFBTWEsZUFBZSxJQUFJLENBQUNELFVBQVUsQ0FBQ3hELE9BQU8sQ0FBQzFDLGFBQWFDLGFBQWEsSUFBSyxDQUFDb0YsUUFBUSxDQUFDQyxnQkFBZ0IsR0FBSXBGLGNBQWMsSUFBSSxDQUFDbUYsUUFBUSxDQUFDN0YsTUFBTTtRQUM1SSxJQUFJMkcsaUJBQWlCLENBQUMsR0FBRztZQUNyQixJQUFJLENBQUNoRyxLQUFLLEdBQUcsSUFBSSxDQUFDK0YsVUFBVSxDQUFDL0YsS0FBSztZQUNsQyxPQUFPZ0c7UUFDWDtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUN0QyxPQUFPLENBQUMxRCxLQUFLLENBQUNYLE1BQU0sRUFDMUIsSUFBSSxDQUFDdUQsV0FBVyxJQUFJLElBQUksQ0FBQ2MsT0FBTyxDQUFDZCxXQUFXO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUNzQyxRQUFRLENBQUNsRixLQUFLLENBQUNYLE1BQU0sRUFDM0IsSUFBSSxDQUFDdUQsV0FBVyxJQUFJLElBQUksQ0FBQ3NDLFFBQVEsQ0FBQ3RDLFdBQVc7UUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQ21ELFVBQVUsQ0FBQy9GLEtBQUssQ0FBQ1gsTUFBTSxFQUM3QixJQUFJLENBQUN1RCxXQUFXLElBQUksSUFBSSxDQUFDbUQsVUFBVSxDQUFDbkQsV0FBVztRQUNuRCxPQUFPb0Q7SUFDWDtJQUNBUyxrQkFBa0I7UUFDZCxNQUFNOEQsU0FBUyxFQUFFO1FBQ2pCLEtBQUssTUFBTTdNLFNBQVMsSUFBSSxDQUFDcUksVUFBVSxDQUFDckksS0FBSyxDQUFFO1lBQ3ZDNk0sT0FBT2pLLElBQUksQ0FBQzVDLE1BQU02SSxRQUFRLENBQUMsU0FBU2lFLEtBQUssQ0FBQyxNQUFNQyxHQUFHLENBQUNDLENBQUFBLElBQUssQ0FBQyxFQUFFLEVBQUVBLEVBQUUsQ0FBQyxFQUFFQyxJQUFJLENBQUM7UUFDNUU7UUFDQSxNQUFNdEgsWUFBWSxJQUFJLENBQUNLLE9BQU8sQ0FBQ0ksUUFBUSxLQUFLLElBQ3RDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQzdCLElBQUksQ0FBQzdELFdBQVcsQ0FBQ1EsSUFBSTtRQUMzQixPQUFPNkosT0FBT2xMLE1BQU0sR0FDZCxDQUFDLEVBQUVnRSxVQUFVLElBQUksRUFBRWtILE9BQU9JLElBQUksQ0FBQyxNQUFNLENBQUMsR0FDdEMsQ0FBQyxFQUFFdEgsVUFBVSxFQUFFLENBQUM7SUFDMUI7QUFDSjtBQUNBaUgsT0FBT3ZEO0FBQ047SUFDR3ZCLFVBQVV1QixXQUFXLEdBQUd1RDtBQUM1QjtBQUNBdkQsWUFBWXJHLElBQUksR0FBRztBQUVuQixNQUFNa0ssb0NBQW9DdEg7SUFDdENmLFFBQVExQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFO1FBQzNDLE9BQU9EO0lBQ1g7SUFDQStDLE1BQU1DLFFBQVEsRUFBRTtRQUNaLE9BQU96QjtJQUNYO0FBQ0o7QUFDQXVKLDRCQUE0QkMsUUFBUSxHQUFHO0FBRXZDLElBQUlDO0FBQ0osTUFBTTNDLHFCQUFxQjFDO0lBQ3ZCdkYsWUFBWTJGLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQSxZQUFZK0U7UUFDbEIsSUFBSSxDQUFDbEgsT0FBTyxDQUFDSSxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSixPQUFPLENBQUNLLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0ErRyxPQUFPM0M7QUFDTjtJQUNHM0MsVUFBVTJDLFlBQVksR0FBRzJDO0FBQzdCO0FBQ0EzQyxhQUFhekgsSUFBSSxHQUFHYztBQUVwQixJQUFJdUo7QUFDSixNQUFNdkMsYUFBYS9DO0lBQ2Z2RixZQUFZMkYsYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBLFlBQVl2QztRQUNsQixJQUFJLENBQUNJLE9BQU8sQ0FBQ0ksUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLEdBQUc7SUFDN0I7SUFDQXhCLFFBQVExQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFO1FBQzNDLElBQUksSUFBSSxDQUFDbUYsUUFBUSxDQUFDN0YsTUFBTSxHQUFHLEdBQ3ZCLElBQUksQ0FBQ3NELFFBQVEsQ0FBQ3JDLElBQUksQ0FBQztRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDb0QsT0FBTyxDQUFDMUQsS0FBSyxDQUFDWCxNQUFNLEVBQzFCLElBQUksQ0FBQ3VELFdBQVcsSUFBSSxJQUFJLENBQUNjLE9BQU8sQ0FBQ2QsV0FBVztRQUNoRCxJQUFJLENBQUMsSUFBSSxDQUFDc0MsUUFBUSxDQUFDbEYsS0FBSyxDQUFDWCxNQUFNLEVBQzNCLElBQUksQ0FBQ3VELFdBQVcsSUFBSSxJQUFJLENBQUNzQyxRQUFRLENBQUN0QyxXQUFXO1FBQ2pELElBQUksQ0FBQ0EsV0FBVyxJQUFJN0M7UUFDcEIsSUFBSSxjQUFlQSxjQUFlRixZQUFZTixVQUFVLEVBQUU7WUFDdEQsSUFBSSxDQUFDUyxLQUFLLEdBQUc7WUFDYixPQUFPLENBQUM7UUFDWjtRQUNBLE9BQVFGLGNBQWNDO0lBQzFCO0lBQ0E4QyxNQUFNQyxRQUFRLEVBQUVVLE1BQU0sRUFBRTtRQUNwQixNQUFNK0IsU0FBUyxJQUFJakUsWUFBWTtRQUMvQixJQUFJLENBQUN3QixVQUFVO1lBQ1gsTUFBTXRELFVBQVUsSUFBSUMsV0FBVzhGO1lBQy9CL0YsT0FBTyxDQUFDLEVBQUUsR0FBRztZQUNiQSxPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ2pCO1FBQ0EsSUFBSWdFLFFBQVE7WUFDUkEsT0FBT3BELEtBQUssQ0FBQ21GO1FBQ2pCO1FBQ0EsT0FBT0E7SUFDWDtJQUNBa0Isa0JBQWtCO1FBQ2QsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDdkcsV0FBVyxDQUFDUSxJQUFJLENBQUMsQ0FBQztJQUNyQztBQUNKO0FBQ0FxSyxPQUFPdkM7QUFDTjtJQUNHaEQsVUFBVWdELElBQUksR0FBR3VDO0FBQ3JCO0FBQ0F2QyxLQUFLOUgsSUFBSSxHQUFHO0FBRVosTUFBTXNLLCtCQUErQnJKLFNBQVMyQjtJQUMxQ3BELFlBQVksRUFBRXhDLEtBQUssRUFBRSxHQUFHbUksWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3ZDLEtBQUssQ0FBQ0E7UUFDTixJQUFJQSxXQUFXMUQsUUFBUSxFQUFFO1lBQ3JCLElBQUksQ0FBQ0QsWUFBWSxHQUFHdkQscUJBQXFCeUQscUJBQXFCLENBQUNDLFlBQVksQ0FBQ3dELFdBQVcxRCxRQUFRO1FBQ25HLE9BQ0s7WUFDRCxJQUFJLENBQUNELFlBQVksR0FBRyxJQUFJekMsV0FBVztRQUN2QztRQUNBLElBQUkvQixPQUFPO1lBQ1AsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO1FBQ2pCO0lBQ0o7SUFDQSxJQUFJQSxRQUFRO1FBQ1IsS0FBSyxNQUFNdU4sU0FBUyxJQUFJLENBQUMvSSxZQUFZLENBQUU7WUFDbkMsSUFBSStJLFFBQVEsR0FBRztnQkFDWCxPQUFPO1lBQ1g7UUFDSjtRQUNBLE9BQU87SUFDWDtJQUNBLElBQUl2TixNQUFNQSxLQUFLLEVBQUU7UUFDYixJQUFJLENBQUN3RSxZQUFZLENBQUMsRUFBRSxHQUFHeEUsUUFBUSxPQUFPO0lBQzFDO0lBQ0E2RSxRQUFRMUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxNQUFNeUUsWUFBWTdGLHFCQUFxQnlELHFCQUFxQixDQUFDQyxZQUFZLENBQUN4QztRQUMxRSxJQUFJLENBQUNGLGtCQUFrQixJQUFJLEVBQUU2RSxXQUFXMUUsYUFBYUMsY0FBYztZQUMvRCxPQUFPLENBQUM7UUFDWjtRQUNBLElBQUksQ0FBQ21DLFlBQVksR0FBR3NDLFVBQVU5QixRQUFRLENBQUM1QyxhQUFhQSxjQUFjQztRQUNsRSxJQUFJQSxjQUFjLEdBQ2QsSUFBSSxDQUFDNEMsUUFBUSxDQUFDckMsSUFBSSxDQUFDO1FBQ3ZCLElBQUksQ0FBQzJCLFNBQVMsR0FBRztRQUNqQnJELG1CQUFtQnNNLFlBQVksQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFDekMsSUFBSSxDQUFDdkksV0FBVyxHQUFHN0M7UUFDbkIsT0FBUUQsY0FBY0M7SUFDMUI7SUFDQThDLFFBQVE7UUFDSixPQUFPLElBQUksQ0FBQ1gsWUFBWSxDQUFDSSxLQUFLO0lBQ2xDO0lBQ0FTLFNBQVM7UUFDTCxPQUFPO1lBQ0gsR0FBRyxLQUFLLENBQUNBLFFBQVE7WUFDakJyRixPQUFPLElBQUksQ0FBQ0EsS0FBSztRQUNyQjtJQUNKO0FBQ0o7QUFDQXNOLHVCQUF1QnRLLElBQUksR0FBRztBQUU5QixJQUFJMEs7QUFDSixNQUFNaEQsZ0JBQWdCM0M7SUFDbEJ2RixZQUFZMkYsYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBLFlBQVltRjtRQUNsQixJQUFJLENBQUN0SCxPQUFPLENBQUNJLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNKLE9BQU8sQ0FBQ0ssU0FBUyxHQUFHO0lBQzdCO0lBQ0FvRCxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUNwQixVQUFVLENBQUNySSxLQUFLO0lBQ2hDO0lBQ0EwSixTQUFTMUosS0FBSyxFQUFFO1FBQ1osSUFBSSxDQUFDcUksVUFBVSxDQUFDckksS0FBSyxHQUFHQTtJQUM1QjtJQUNBK0ksa0JBQWtCO1FBQ2QsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDdkcsV0FBVyxDQUFDUSxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQ3lHLFFBQVEsQ0FBQyxDQUFDO0lBQ3hEO0FBQ0o7QUFDQWlFLE9BQU9oRDtBQUNOO0lBQ0c1QyxVQUFVNEMsT0FBTyxHQUFHZ0Q7QUFDeEI7QUFDQWhELFFBQVExSCxJQUFJLEdBQUc7QUFFZixNQUFNMkssbUNBQW1DMUosU0FBU3dJO0lBQzlDakssWUFBWSxFQUFFOEQsZ0JBQWdCLEtBQUssRUFBRSxHQUFHNkIsWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3ZELEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUM3QixhQUFhLEdBQUdBO0lBQ3pCO0lBQ0F6QixRQUFRMUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxJQUFJaUcsZUFBZTtRQUNuQixJQUFJLElBQUksQ0FBQ2hDLGFBQWEsRUFBRTtZQUNwQixJQUFJLENBQUMvQixTQUFTLEdBQUc7WUFDakIrRCxlQUFlbUUsMkJBQTJCbUIsU0FBUyxDQUFDL0ksT0FBTyxDQUFDNEksSUFBSSxDQUFDLElBQUksRUFBRXRMLGFBQWFDLGFBQWFDO1lBQ2pHLElBQUlpRyxpQkFBaUIsQ0FBQyxHQUNsQixPQUFPQTtZQUNYLElBQUssSUFBSTVHLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUMxQixLQUFLLENBQUMyQixNQUFNLEVBQUVELElBQUs7Z0JBQ3hDLE1BQU1tTSxtQkFBbUIsSUFBSSxDQUFDN04sS0FBSyxDQUFDMEIsRUFBRSxDQUFDYyxXQUFXLENBQUNRLElBQUk7Z0JBQ3ZELElBQUk2SyxxQkFBcUIvSixxQkFBcUI7b0JBQzFDLElBQUksSUFBSSxDQUFDMkQsZ0JBQWdCLEVBQ3JCO3lCQUNDO3dCQUNELElBQUksQ0FBQ25GLEtBQUssR0FBRzt3QkFDYixPQUFPLENBQUM7b0JBQ1o7Z0JBQ0o7Z0JBQ0EsSUFBSXVMLHFCQUFxQjlKLG1CQUFtQjtvQkFDeEMsSUFBSSxDQUFDekIsS0FBSyxHQUFHO29CQUNiLE9BQU8sQ0FBQztnQkFDWjtZQUNKO1FBQ0osT0FDSztZQUNELElBQUksQ0FBQ2lDLFNBQVMsR0FBRztZQUNqQitELGVBQWUsS0FBSyxDQUFDekQsUUFBUTFDLGFBQWFDLGFBQWFDO1lBQ3ZELElBQUksQ0FBQzZDLFdBQVcsR0FBRzdDO1FBQ3ZCO1FBQ0EsT0FBT2lHO0lBQ1g7SUFDQW5ELE1BQU1DLFFBQVEsRUFBRVUsTUFBTSxFQUFFO1FBQ3BCLElBQUksSUFBSSxDQUFDUSxhQUFhLEVBQ2xCLE9BQU9tRywyQkFBMkJtQixTQUFTLENBQUN6SSxLQUFLLENBQUNzSSxJQUFJLENBQUMsSUFBSSxFQUFFckksVUFBVVU7UUFDM0UsT0FBT1YsV0FDRCxJQUFJeEIsWUFBWSxJQUFJLENBQUNZLFlBQVksQ0FBQzNDLFVBQVUsSUFDNUMsSUFBSSxDQUFDMkMsWUFBWSxDQUFDSSxLQUFLLEdBQUdoRCxNQUFNO0lBQzFDO0lBQ0F5RCxTQUFTO1FBQ0wsT0FBTztZQUNILEdBQUcsS0FBSyxDQUFDQSxRQUFRO1lBQ2pCaUIsZUFBZSxJQUFJLENBQUNBLGFBQWE7UUFDckM7SUFDSjtBQUNKO0FBQ0FxSCwyQkFBMkIzSyxJQUFJLEdBQUc7QUFFbEMsSUFBSThLO0FBQ0osTUFBTWpELG9CQUFvQjlDO0lBQ3RCdkYsWUFBWSxFQUFFd0QsVUFBVSxDQUFDLENBQUMsRUFBRXdCLFdBQVcsQ0FBQyxDQUFDLEVBQUUsR0FBR1csWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQzdELElBQUlsQyxJQUFJQztRQUNQRCxDQUFBQSxLQUFLa0MsV0FBVzdCLGFBQWEsTUFBTSxRQUFRTCxPQUFPLEtBQUssSUFBSUEsS0FBTWtDLFdBQVc3QixhQUFhLEdBQUcsQ0FBQyxDQUFFLEVBQUNKLEtBQUtpQyxXQUFXbkksS0FBSyxNQUFNLFFBQVFrRyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd2RSxNQUFNO1FBQ3RLLEtBQUssQ0FBQztZQUNGcUUsU0FBUztnQkFDTE0sZUFBZTZCLFdBQVc3QixhQUFhO2dCQUN2QyxHQUFHTixPQUFPO1lBQ2Q7WUFDQXdCLFVBQVU7Z0JBQ04sR0FBR0EsUUFBUTtnQkFDWEMsa0JBQWtCLENBQUMsQ0FBQ1UsV0FBV1YsZ0JBQWdCO1lBQ25EO1lBQ0EsR0FBR1UsVUFBVTtRQUNqQixHQUFHd0Y7UUFDSCxJQUFJLENBQUMzSCxPQUFPLENBQUNJLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNKLE9BQU8sQ0FBQ0ssU0FBUyxHQUFHO0lBQzdCO0lBQ0F4QixRQUFRMUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxJQUFJLENBQUNnRyxVQUFVLENBQUMvQixhQUFhLEdBQUcsSUFBSSxDQUFDTixPQUFPLENBQUNNLGFBQWE7UUFDMUQsSUFBSSxDQUFDK0IsVUFBVSxDQUFDWixnQkFBZ0IsR0FBRyxJQUFJLENBQUNELFFBQVEsQ0FBQ0MsZ0JBQWdCO1FBQ2pFLElBQUlwRixnQkFBZ0IsR0FBRztZQUNuQixJQUFJLElBQUksQ0FBQzJELE9BQU8sQ0FBQzFELEtBQUssQ0FBQ1gsTUFBTSxLQUFLLEdBQzlCLElBQUksQ0FBQ3VELFdBQVcsSUFBSSxJQUFJLENBQUNjLE9BQU8sQ0FBQ2QsV0FBVztZQUNoRCxJQUFJLElBQUksQ0FBQ3NDLFFBQVEsQ0FBQ2xGLEtBQUssQ0FBQ1gsTUFBTSxLQUFLLEdBQy9CLElBQUksQ0FBQ3VELFdBQVcsSUFBSSxJQUFJLENBQUNzQyxRQUFRLENBQUN0QyxXQUFXO1lBQ2pELE9BQU85QztRQUNYO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ2lHLFVBQVUsQ0FBQy9CLGFBQWEsRUFBRTtZQUNoQyxNQUFNeEIsT0FBTzNDLHVCQUF1QnlCLGNBQWMsSUFBSTdCLFdBQVdJLGVBQWVBO1lBQ2hGLE1BQU1RLE1BQU1tQyxLQUFLRSxRQUFRLENBQUM1QyxhQUFhQSxjQUFjQztZQUNyRCxJQUFJO2dCQUNBLElBQUlNLElBQUlkLFVBQVUsRUFBRTtvQkFDaEIsTUFBTWtNLE1BQU01RCxhQUFheEgsS0FBSyxHQUFHQSxJQUFJZCxVQUFVO29CQUMvQyxJQUFJa00sSUFBSXpELE1BQU0sS0FBSyxDQUFDLEtBQUt5RCxJQUFJekQsTUFBTSxLQUFLakksYUFBYTt3QkFDakQsSUFBSSxDQUFDZ0csVUFBVSxDQUFDckksS0FBSyxHQUFHOzRCQUFDK04sSUFBSXhELE1BQU07eUJBQUM7b0JBQ3hDO2dCQUNKO1lBQ0osRUFDQSxPQUFPbEssR0FBRyxDQUNWO1FBQ0o7UUFDQSxPQUFPLEtBQUssQ0FBQ3dFLFFBQVExQyxhQUFhQyxhQUFhQztJQUNuRDtJQUNBMEcsa0JBQWtCO1FBQ2QsSUFBSSxJQUFJLENBQUNWLFVBQVUsQ0FBQy9CLGFBQWEsSUFBSyxJQUFJLENBQUMrQixVQUFVLENBQUNySSxLQUFLLElBQUksSUFBSSxDQUFDcUksVUFBVSxDQUFDckksS0FBSyxDQUFDMkIsTUFBTSxFQUFHO1lBQzFGLE9BQU8wSCxZQUFZdUUsU0FBUyxDQUFDN0UsZUFBZSxDQUFDMEUsSUFBSSxDQUFDLElBQUk7UUFDMUQ7UUFDQSxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUNqTCxXQUFXLENBQUNRLElBQUksQ0FBQyxHQUFHLEVBQUUvQixxQkFBcUJxRSxPQUFPLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUM4QyxVQUFVLENBQUM3RCxZQUFZLEVBQUUsQ0FBQztJQUMzRztJQUNBaUYsV0FBVztRQUNQLElBQUksQ0FBQyxJQUFJLENBQUN6RCxPQUFPLENBQUNNLGFBQWEsRUFBRTtZQUM3QixPQUFPLElBQUksQ0FBQytCLFVBQVUsQ0FBQzdELFlBQVksQ0FBQ0ksS0FBSyxHQUFHaEQsTUFBTTtRQUN0RDtRQUNBLE1BQU1vTSxRQUFRLEVBQUU7UUFDaEIsS0FBSyxNQUFNQyxXQUFXLElBQUksQ0FBQzVGLFVBQVUsQ0FBQ3JJLEtBQUssQ0FBRTtZQUN6QyxJQUFJaU8sbUJBQW1CcEQsYUFBYTtnQkFDaENtRCxNQUFNcEwsSUFBSSxDQUFDcUwsUUFBUTVGLFVBQVUsQ0FBQzdELFlBQVk7WUFDOUM7UUFDSjtRQUNBLE9BQU92RCxxQkFBcUJ5RCxxQkFBcUIsQ0FBQ3BELE1BQU0sQ0FBQzBNO0lBQzdEO0FBQ0o7QUFDQUYsT0FBT2pEO0FBQ047SUFDRy9DLFVBQVUrQyxXQUFXLEdBQUdpRDtBQUM1QjtBQUNBakQsWUFBWTdILElBQUksR0FBR2U7QUFFbkIsTUFBTW1LLGlDQUFpQ2pLLFNBQVN3STtJQUM1Q2pLLFlBQVksRUFBRTJMLGFBQWEsQ0FBQyxFQUFFN0gsZ0JBQWdCLEtBQUssRUFBRSxHQUFHNkIsWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3ZFLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNnRyxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQzdILGFBQWEsR0FBR0E7UUFDckIsSUFBSSxDQUFDcEIsV0FBVyxHQUFHLElBQUksQ0FBQ1YsWUFBWSxDQUFDM0MsVUFBVTtJQUNuRDtJQUNBZ0QsUUFBUTFDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUU7UUFDM0MsSUFBSSxDQUFDQSxhQUFhO1lBQ2QsT0FBT0Q7UUFDWDtRQUNBLElBQUlrRyxlQUFlLENBQUM7UUFDcEIsSUFBSSxJQUFJLENBQUNoQyxhQUFhLEVBQUU7WUFDcEJnQyxlQUFlbUUsMkJBQTJCbUIsU0FBUyxDQUFDL0ksT0FBTyxDQUFDNEksSUFBSSxDQUFDLElBQUksRUFBRXRMLGFBQWFDLGFBQWFDO1lBQ2pHLElBQUlpRyxpQkFBaUIsQ0FBQyxHQUNsQixPQUFPQTtZQUNYLEtBQUssTUFBTXRJLFNBQVMsSUFBSSxDQUFDQSxLQUFLLENBQUU7Z0JBQzVCLE1BQU02TixtQkFBbUI3TixNQUFNd0MsV0FBVyxDQUFDUSxJQUFJO2dCQUMvQyxJQUFJNksscUJBQXFCL0oscUJBQXFCO29CQUMxQyxJQUFJLElBQUksQ0FBQzJELGdCQUFnQixFQUNyQjt5QkFDQzt3QkFDRCxJQUFJLENBQUNuRixLQUFLLEdBQUc7d0JBQ2IsT0FBTyxDQUFDO29CQUNaO2dCQUNKO2dCQUNBLElBQUl1TCxxQkFBcUI3SixpQkFBaUI7b0JBQ3RDLElBQUksQ0FBQzFCLEtBQUssR0FBRztvQkFDYixPQUFPLENBQUM7Z0JBQ1o7Z0JBQ0EsTUFBTStGLGFBQWFySSxNQUFNcUksVUFBVTtnQkFDbkMsSUFBSSxJQUFLLENBQUM4RixVQUFVLEdBQUcsS0FBTzlGLFdBQVc4RixVQUFVLEdBQUcsR0FBSTtvQkFDdEQsSUFBSSxDQUFDN0wsS0FBSyxHQUFHO29CQUNiLE9BQU8sQ0FBQztnQkFDWjtnQkFDQSxJQUFJLENBQUM2TCxVQUFVLEdBQUc5RixXQUFXOEYsVUFBVTtZQUMzQztZQUNBLE9BQU83RjtRQUNYO1FBQ0EsTUFBTXhCLFlBQVk3RixxQkFBcUJ5RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDeEM7UUFDMUUsSUFBSSxDQUFDRixrQkFBa0IsSUFBSSxFQUFFNkUsV0FBVzFFLGFBQWFDLGNBQWM7WUFDL0QsT0FBTyxDQUFDO1FBQ1o7UUFDQSxNQUFNMEUsWUFBWUQsVUFBVTlCLFFBQVEsQ0FBQzVDLGFBQWFBLGNBQWNDO1FBQ2hFLElBQUksQ0FBQzhMLFVBQVUsR0FBR3BILFNBQVMsQ0FBQyxFQUFFO1FBQzlCLElBQUksSUFBSSxDQUFDb0gsVUFBVSxHQUFHLEdBQUc7WUFDckIsSUFBSSxDQUFDN0wsS0FBSyxHQUFHO1lBQ2IsT0FBTyxDQUFDO1FBQ1o7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDNkwsVUFBVSxFQUFFO1lBQ2xCLE1BQU14TCxNQUFNb0UsVUFBVS9CLFFBQVEsQ0FBQztZQUMvQixJQUFJO2dCQUNBLElBQUlyQyxJQUFJZCxVQUFVLEVBQUU7b0JBQ2hCLE1BQU1rTSxNQUFNNUQsYUFBYXhILEtBQUssR0FBR0EsSUFBSWQsVUFBVTtvQkFDL0MsSUFBSWtNLElBQUl6RCxNQUFNLEtBQUssQ0FBQyxLQUFLeUQsSUFBSXpELE1BQU0sS0FBTWpJLGNBQWMsR0FBSTt3QkFDdkQsSUFBSSxDQUFDckMsS0FBSyxHQUFHOzRCQUFDK04sSUFBSXhELE1BQU07eUJBQUM7b0JBQzdCO2dCQUNKO1lBQ0osRUFDQSxPQUFPbEssR0FBRyxDQUNWO1FBQ0o7UUFDQSxJQUFJLENBQUNtRSxZQUFZLEdBQUd1QyxVQUFVL0IsUUFBUSxDQUFDO1FBQ3ZDLElBQUksQ0FBQ0UsV0FBVyxHQUFHNkIsVUFBVXBGLE1BQU07UUFDbkMsT0FBUVMsY0FBY0M7SUFDMUI7SUFDQThDLE1BQU1DLFFBQVEsRUFBRVUsTUFBTSxFQUFFO1FBQ3BCLElBQUksSUFBSSxDQUFDUSxhQUFhLEVBQUU7WUFDcEIsT0FBT21HLDJCQUEyQm1CLFNBQVMsQ0FBQ3pJLEtBQUssQ0FBQ3NJLElBQUksQ0FBQyxJQUFJLEVBQUVySSxVQUFVVTtRQUMzRTtRQUNBLElBQUlWLFVBQVU7WUFDVixPQUFPLElBQUl4QixZQUFZLElBQUksQ0FBQ1ksWUFBWSxDQUFDM0MsVUFBVSxHQUFHO1FBQzFEO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQzJDLFlBQVksQ0FBQzNDLFVBQVUsRUFBRTtZQUMvQixPQUFPOEI7UUFDWDtRQUNBLE1BQU03QixVQUFVLElBQUlDLFdBQVcsSUFBSSxDQUFDeUMsWUFBWSxDQUFDN0MsTUFBTSxHQUFHO1FBQzFERyxPQUFPLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ3FNLFVBQVU7UUFDNUJyTSxRQUFRRSxHQUFHLENBQUMsSUFBSSxDQUFDd0MsWUFBWSxFQUFFO1FBQy9CLE9BQU8xQyxRQUFRRixNQUFNO0lBQ3pCO0lBQ0F5RCxTQUFTO1FBQ0wsT0FBTztZQUNILEdBQUcsS0FBSyxDQUFDQSxRQUFRO1lBQ2pCOEksWUFBWSxJQUFJLENBQUNBLFVBQVU7WUFDM0I3SCxlQUFlLElBQUksQ0FBQ0EsYUFBYTtRQUNyQztJQUNKO0FBQ0o7QUFDQTRILHlCQUF5QmxMLElBQUksR0FBRztBQUVoQyxJQUFJb0w7QUFDSixNQUFNeEQsa0JBQWtCN0M7SUFDcEJ2RixZQUFZLEVBQUV3RCxVQUFVLENBQUMsQ0FBQyxFQUFFd0IsV0FBVyxDQUFDLENBQUMsRUFBRSxHQUFHVyxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDN0QsSUFBSWxDLElBQUlDO1FBQ1BELENBQUFBLEtBQUtrQyxXQUFXN0IsYUFBYSxNQUFNLFFBQVFMLE9BQU8sS0FBSyxJQUFJQSxLQUFNa0MsV0FBVzdCLGFBQWEsR0FBRyxDQUFDLENBQUUsRUFBQ0osS0FBS2lDLFdBQVduSSxLQUFLLE1BQU0sUUFBUWtHLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3ZFLE1BQU07UUFDdEssS0FBSyxDQUFDO1lBQ0ZxRSxTQUFTO2dCQUNMTSxlQUFlNkIsV0FBVzdCLGFBQWE7Z0JBQ3ZDLEdBQUdOLE9BQU87WUFDZDtZQUNBd0IsVUFBVTtnQkFDTixHQUFHQSxRQUFRO2dCQUNYQyxrQkFBa0IsQ0FBQyxDQUFDVSxXQUFXVixnQkFBZ0I7WUFDbkQ7WUFDQSxHQUFHVSxVQUFVO1FBQ2pCLEdBQUcrRjtRQUNILElBQUksQ0FBQ2xJLE9BQU8sQ0FBQ0ksUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLEdBQUc7SUFDN0I7SUFDQXhCLFFBQVExQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFO1FBQzNDLElBQUksQ0FBQ2dHLFVBQVUsQ0FBQy9CLGFBQWEsR0FBRyxJQUFJLENBQUNOLE9BQU8sQ0FBQ00sYUFBYTtRQUMxRCxJQUFJLENBQUMrQixVQUFVLENBQUNaLGdCQUFnQixHQUFHLElBQUksQ0FBQ0QsUUFBUSxDQUFDQyxnQkFBZ0I7UUFDakUsT0FBTyxLQUFLLENBQUM1QyxRQUFRMUMsYUFBYUMsYUFBYUM7SUFDbkQ7SUFDQTBHLGtCQUFrQjtRQUNkLElBQUksSUFBSSxDQUFDVixVQUFVLENBQUMvQixhQUFhLElBQUssSUFBSSxDQUFDK0IsVUFBVSxDQUFDckksS0FBSyxJQUFJLElBQUksQ0FBQ3FJLFVBQVUsQ0FBQ3JJLEtBQUssQ0FBQzJCLE1BQU0sRUFBRztZQUMxRixPQUFPMEgsWUFBWXVFLFNBQVMsQ0FBQzdFLGVBQWUsQ0FBQzBFLElBQUksQ0FBQyxJQUFJO1FBQzFELE9BQ0s7WUFDRCxNQUFNWSxPQUFPLEVBQUU7WUFDZixNQUFNNUosV0FBVyxJQUFJLENBQUM0RCxVQUFVLENBQUM3RCxZQUFZO1lBQzdDLEtBQUssTUFBTThKLFFBQVE3SixTQUFVO2dCQUN6QjRKLEtBQUt6TCxJQUFJLENBQUMwTCxLQUFLekYsUUFBUSxDQUFDLEdBQUcwRixRQUFRLENBQUMsR0FBRztZQUMzQztZQUNBLE1BQU1DLFVBQVVILEtBQUtwQixJQUFJLENBQUM7WUFDMUIsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDekssV0FBVyxDQUFDUSxJQUFJLENBQUMsR0FBRyxFQUFFd0wsUUFBUUMsU0FBUyxDQUFDLEdBQUdELFFBQVE3TSxNQUFNLEdBQUcsSUFBSSxDQUFDMEcsVUFBVSxDQUFDOEYsVUFBVSxFQUFFLENBQUM7UUFDNUc7SUFDSjtBQUNKO0FBQ0FDLE9BQU94RDtBQUNOO0lBQ0c5QyxVQUFVOEMsU0FBUyxHQUFHd0Q7QUFDMUI7QUFDQXhELFVBQVU1SCxJQUFJLEdBQUdnQjtBQUVqQixJQUFJMEs7QUFDSixTQUFTQyxRQUFRQyxLQUFLLEVBQUVDLE1BQU07SUFDMUIsTUFBTUMsSUFBSSxJQUFJL00sV0FBVztRQUFDO0tBQUU7SUFDNUIsTUFBTWdOLFlBQVksSUFBSWhOLFdBQVc2TTtJQUNqQyxNQUFNSSxhQUFhLElBQUlqTixXQUFXOE07SUFDbEMsSUFBSUksZ0JBQWdCRixVQUFVbkssS0FBSyxDQUFDO0lBQ3BDLE1BQU1zSyxzQkFBc0JELGNBQWN0TixNQUFNLEdBQUc7SUFDbkQsTUFBTXdOLGlCQUFpQkgsV0FBV3BLLEtBQUssQ0FBQztJQUN4QyxNQUFNd0ssdUJBQXVCRCxlQUFleE4sTUFBTSxHQUFHO0lBQ3JELElBQUkzQixRQUFRO0lBQ1osTUFBTXFQLE1BQU0sdUJBQXdCSCxzQkFBdUJBLHNCQUFzQkU7SUFDakYsSUFBSUUsVUFBVTtJQUNkLElBQUssSUFBSTVOLElBQUkyTixLQUFLM04sS0FBSyxHQUFHQSxLQUFLNE4sVUFBVztRQUN0QyxPQUFRO1lBQ0osS0FBTUEsVUFBVUgsZUFBZXhOLE1BQU07Z0JBQ2pDM0IsUUFBUWlQLGFBQWEsQ0FBQ0Msc0JBQXNCSSxRQUFRLEdBQUdILGNBQWMsQ0FBQ0MsdUJBQXVCRSxRQUFRLEdBQUdSLENBQUMsQ0FBQyxFQUFFO2dCQUM1RztZQUNKO2dCQUNJOU8sUUFBUWlQLGFBQWEsQ0FBQ0Msc0JBQXNCSSxRQUFRLEdBQUdSLENBQUMsQ0FBQyxFQUFFO1FBQ25FO1FBQ0FBLENBQUMsQ0FBQyxFQUFFLEdBQUc5TyxRQUFRO1FBQ2YsT0FBUTtZQUNKLEtBQU1zUCxXQUFXTCxjQUFjdE4sTUFBTTtnQkFDakNzTixnQkFBZ0IvTixtQkFBbUJxTyxjQUFjLENBQUMsSUFBSXhOLFdBQVc7b0JBQUMvQixRQUFRO2lCQUFHLEdBQUdpUDtnQkFDaEY7WUFDSjtnQkFDSUEsYUFBYSxDQUFDQyxzQkFBc0JJLFFBQVEsR0FBR3RQLFFBQVE7UUFDL0Q7SUFDSjtJQUNBLElBQUk4TyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQ1BHLGdCQUFnQi9OLG1CQUFtQnFPLGNBQWMsQ0FBQ1QsR0FBR0c7SUFDekQsT0FBT0E7QUFDWDtBQUNBLFNBQVNPLE9BQU9qUCxDQUFDO0lBQ2IsSUFBSUEsS0FBS3VDLFFBQVFuQixNQUFNLEVBQUU7UUFDckIsSUFBSyxJQUFJOE4sSUFBSTNNLFFBQVFuQixNQUFNLEVBQUU4TixLQUFLbFAsR0FBR2tQLElBQUs7WUFDdEMsTUFBTVgsSUFBSSxJQUFJL00sV0FBVztnQkFBQzthQUFFO1lBQzVCLElBQUkyTixTQUFTLE9BQVEsQ0FBQ0QsSUFBSSxFQUFFLENBQUU3SyxLQUFLLENBQUM7WUFDcEMsSUFBSyxJQUFJbEQsSUFBS2dPLE9BQU8vTixNQUFNLEdBQUcsR0FBSUQsS0FBSyxHQUFHQSxJQUFLO2dCQUMzQyxNQUFNaU8sV0FBVyxJQUFJNU4sV0FBVztvQkFBRTJOLENBQUFBLE1BQU0sQ0FBQ2hPLEVBQUUsSUFBSSxLQUFLb04sQ0FBQyxDQUFDLEVBQUU7aUJBQUM7Z0JBQ3pEQSxDQUFDLENBQUMsRUFBRSxHQUFHYSxRQUFRLENBQUMsRUFBRSxHQUFHO2dCQUNyQkQsTUFBTSxDQUFDaE8sRUFBRSxHQUFHaU8sUUFBUSxDQUFDLEVBQUUsR0FBRztZQUM5QjtZQUNBLElBQUliLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FDUFksU0FBU3hPLG1CQUFtQnFPLGNBQWMsQ0FBQ1QsR0FBR1k7WUFDbEQ1TSxRQUFRRixJQUFJLENBQUM4TTtRQUNqQjtJQUNKO0lBQ0EsT0FBTzVNLE9BQU8sQ0FBQ3ZDLEVBQUU7QUFDckI7QUFDQSxTQUFTcVAsUUFBUWhCLEtBQUssRUFBRUMsTUFBTTtJQUMxQixJQUFJZ0IsSUFBSTtJQUNSLE1BQU1kLFlBQVksSUFBSWhOLFdBQVc2TTtJQUNqQyxNQUFNSSxhQUFhLElBQUlqTixXQUFXOE07SUFDbEMsTUFBTUksZ0JBQWdCRixVQUFVbkssS0FBSyxDQUFDO0lBQ3RDLE1BQU1zSyxzQkFBc0JELGNBQWN0TixNQUFNLEdBQUc7SUFDbkQsTUFBTXdOLGlCQUFpQkgsV0FBV3BLLEtBQUssQ0FBQztJQUN4QyxNQUFNd0ssdUJBQXVCRCxlQUFleE4sTUFBTSxHQUFHO0lBQ3JELElBQUkzQjtJQUNKLElBQUlzUCxVQUFVO0lBQ2QsSUFBSyxJQUFJNU4sSUFBSTBOLHNCQUFzQjFOLEtBQUssR0FBR0EsS0FBSzROLFVBQVc7UUFDdkR0UCxRQUFRaVAsYUFBYSxDQUFDQyxzQkFBc0JJLFFBQVEsR0FBR0gsY0FBYyxDQUFDQyx1QkFBdUJFLFFBQVEsR0FBR087UUFDeEcsT0FBUTtZQUNKLEtBQU03UCxRQUFRO2dCQUNWNlAsSUFBSTtnQkFDSlosYUFBYSxDQUFDQyxzQkFBc0JJLFFBQVEsR0FBR3RQLFFBQVE7Z0JBQ3ZEO1lBQ0o7Z0JBQ0k2UCxJQUFJO2dCQUNKWixhQUFhLENBQUNDLHNCQUFzQkksUUFBUSxHQUFHdFA7UUFDdkQ7SUFDSjtJQUNBLElBQUk2UCxJQUFJLEdBQUc7UUFDUCxJQUFLLElBQUluTyxJQUFLd04sc0JBQXNCRSx1QkFBdUIsR0FBSTFOLEtBQUssR0FBR0EsS0FBSzROLFVBQVc7WUFDbkZ0UCxRQUFRaVAsYUFBYSxDQUFDQyxzQkFBc0JJLFFBQVEsR0FBR087WUFDdkQsSUFBSTdQLFFBQVEsR0FBRztnQkFDWDZQLElBQUk7Z0JBQ0paLGFBQWEsQ0FBQ0Msc0JBQXNCSSxRQUFRLEdBQUd0UCxRQUFRO1lBQzNELE9BQ0s7Z0JBQ0Q2UCxJQUFJO2dCQUNKWixhQUFhLENBQUNDLHNCQUFzQkksUUFBUSxHQUFHdFA7Z0JBQy9DO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBT2lQLGNBQWNySyxLQUFLO0FBQzlCO0FBQ0EsTUFBTWtMLCtCQUErQjdMLFNBQVMyQjtJQUMxQ3BELFlBQVksRUFBRXhDLEtBQUssRUFBRSxHQUFHbUksWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3ZDLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUM0SCxTQUFTLEdBQUc7UUFDakIsSUFBSTVILFdBQVcxRCxRQUFRLEVBQUU7WUFDckIsSUFBSSxDQUFDdUwsV0FBVztRQUNwQjtRQUNBLElBQUloUSxVQUFVaVEsV0FBVztZQUNyQixJQUFJLENBQUNDLFFBQVEsR0FBR2xRO1FBQ3BCO0lBQ0o7SUFDQWdRLGNBQWM7UUFDVixJQUFJLElBQUksQ0FBQ3hMLFlBQVksQ0FBQzdDLE1BQU0sSUFBSSxHQUFHO1lBQy9CLElBQUksQ0FBQ3NELFFBQVEsQ0FBQ3JDLElBQUksQ0FBQztZQUNuQixJQUFJLENBQUMyQixTQUFTLEdBQUc7WUFDakIsSUFBSSxDQUFDd0wsU0FBUyxHQUFHO1FBQ3JCLE9BQ0s7WUFDRCxJQUFJLENBQUN4TCxTQUFTLEdBQUc7WUFDakIsSUFBSSxJQUFJLENBQUNDLFlBQVksQ0FBQzdDLE1BQU0sR0FBRyxHQUFHO2dCQUM5QixJQUFJLENBQUNvTyxTQUFTLEdBQUc3TyxtQkFBbUJzTSxZQUFZLENBQUNDLElBQUksQ0FBQyxJQUFJO1lBQzlEO1FBQ0o7SUFDSjtJQUNBLElBQUl5QyxTQUFTQyxDQUFDLEVBQUU7UUFDWixJQUFJLENBQUNKLFNBQVMsR0FBR0k7UUFDakIsSUFBSSxDQUFDNUwsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsWUFBWSxHQUFHLElBQUl6QyxXQUFXYixtQkFBbUJrUCxZQUFZLENBQUNEO0lBQ3ZFO0lBQ0EsSUFBSUQsV0FBVztRQUNYLE9BQU8sSUFBSSxDQUFDSCxTQUFTO0lBQ3pCO0lBQ0FNLFFBQVFsTyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFaU8saUJBQWlCLENBQUMsRUFBRTtRQUMvRCxNQUFNaEcsU0FBUyxJQUFJLENBQUN6RixPQUFPLENBQUMxQyxhQUFhQyxhQUFhQztRQUN0RCxJQUFJaUksV0FBVyxDQUFDLEdBQ1osT0FBT0E7UUFDWCxNQUFNeEYsT0FBTyxJQUFJLENBQUNOLFlBQVk7UUFDOUIsSUFBSSxJQUFLLENBQUMsRUFBRSxLQUFLLFFBQVUsQ0FBQ00sSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFHLE1BQU8sR0FBSTtZQUNoRCxJQUFJLENBQUNOLFlBQVksR0FBR00sS0FBS0UsUUFBUSxDQUFDO1FBQ3RDLE9BQ0s7WUFDRCxJQUFJc0wsbUJBQW1CLEdBQUc7Z0JBQ3RCLElBQUl4TCxLQUFLbkQsTUFBTSxHQUFHMk8sZ0JBQWdCO29CQUM5QixJQUFJLGlCQUFrQnhMLEtBQUtuRCxNQUFNLEdBQUksR0FDakMyTyxpQkFBaUJ4TCxLQUFLbkQsTUFBTSxHQUFHO29CQUNuQyxJQUFJLENBQUM2QyxZQUFZLEdBQUdNLEtBQUtFLFFBQVEsQ0FBQ3NMLGlCQUFpQnhMLEtBQUtuRCxNQUFNO2dCQUNsRTtZQUNKO1FBQ0o7UUFDQSxPQUFPMkk7SUFDWDtJQUNBaUcsTUFBTW5MLFdBQVcsS0FBSyxFQUFFO1FBQ3BCLE1BQU1OLE9BQU8sSUFBSSxDQUFDTixZQUFZO1FBQzlCLE9BQVE7WUFDSixLQUFNLENBQUNNLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBRyxNQUFPO2dCQUN2QjtvQkFDSSxNQUFNMEwsY0FBYyxJQUFJek8sV0FBVyxJQUFJLENBQUN5QyxZQUFZLENBQUM3QyxNQUFNLEdBQUc7b0JBQzlENk8sV0FBVyxDQUFDLEVBQUUsR0FBRztvQkFDakJBLFlBQVl4TyxHQUFHLENBQUM4QyxNQUFNO29CQUN0QixJQUFJLENBQUNOLFlBQVksR0FBR2dNO2dCQUN4QjtnQkFDQTtZQUNKLEtBQU0sSUFBSyxDQUFDLEVBQUUsS0FBSyxRQUFVLENBQUMxTCxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUcsTUFBTztnQkFDOUM7b0JBQ0ksSUFBSSxDQUFDTixZQUFZLEdBQUcsSUFBSSxDQUFDQSxZQUFZLENBQUNRLFFBQVEsQ0FBQztnQkFDbkQ7Z0JBQ0E7UUFDUjtRQUNBLE9BQU8sSUFBSSxDQUFDRyxLQUFLLENBQUNDO0lBQ3RCO0lBQ0FQLFFBQVExQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFO1FBQzNDLE1BQU1pRyxlQUFlLEtBQUssQ0FBQ3pELFFBQVExQyxhQUFhQyxhQUFhQztRQUM3RCxJQUFJaUcsaUJBQWlCLENBQUMsR0FBRztZQUNyQixPQUFPQTtRQUNYO1FBQ0EsSUFBSSxDQUFDMEgsV0FBVztRQUNoQixPQUFPMUg7SUFDWDtJQUNBbkQsTUFBTUMsUUFBUSxFQUFFO1FBQ1osT0FBT0EsV0FDRCxJQUFJeEIsWUFBWSxJQUFJLENBQUNZLFlBQVksQ0FBQzdDLE1BQU0sSUFDeEMsSUFBSSxDQUFDNkMsWUFBWSxDQUFDSSxLQUFLLEdBQUdoRCxNQUFNO0lBQzFDO0lBQ0F5RCxTQUFTO1FBQ0wsT0FBTztZQUNILEdBQUcsS0FBSyxDQUFDQSxRQUFRO1lBQ2pCNkssVUFBVSxJQUFJLENBQUNBLFFBQVE7UUFDM0I7SUFDSjtJQUNBckgsV0FBVztRQUNQLE1BQU00SCxXQUFXLElBQUssQ0FBQ2pNLFlBQVksQ0FBQzdDLE1BQU0sR0FBRyxJQUFLO1FBQ2xELElBQUkrTixTQUFTLElBQUkzTixXQUFXLElBQUssQ0FBQ3lDLFlBQVksQ0FBQzdDLE1BQU0sR0FBRyxJQUFLO1FBQzdELElBQUkrTyxZQUFZO1FBQ2hCLElBQUlDO1FBQ0osTUFBTUMsV0FBVyxJQUFJLENBQUNwTSxZQUFZO1FBQ2xDLElBQUkrRixTQUFTO1FBQ2IsSUFBSXNHLE9BQU87UUFDWCxJQUFLLElBQUlDLGFBQWNGLFNBQVMvTyxVQUFVLEdBQUcsR0FBSWlQLGNBQWMsR0FBR0EsYUFBYztZQUM1RUgsY0FBY0MsUUFBUSxDQUFDRSxXQUFXO1lBQ2xDLElBQUssSUFBSXBQLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO2dCQUN4QixJQUFJLENBQUNpUCxjQUFjLE9BQU8sR0FBRztvQkFDekIsT0FBUUQ7d0JBQ0osS0FBS0Q7NEJBQ0RmLFNBQVNFLFFBQVFKLE9BQU9rQixZQUFZaEI7NEJBQ3BDbkYsU0FBUzs0QkFDVDt3QkFDSjs0QkFDSW1GLFNBQVNmLFFBQVFlLFFBQVFGLE9BQU9rQjtvQkFDeEM7Z0JBQ0o7Z0JBQ0FBO2dCQUNBQyxnQkFBZ0I7WUFDcEI7UUFDSjtRQUNBLElBQUssSUFBSWpQLElBQUksR0FBR0EsSUFBSWdPLE9BQU8vTixNQUFNLEVBQUVELElBQUs7WUFDcEMsSUFBSWdPLE1BQU0sQ0FBQ2hPLEVBQUUsRUFDVG1QLE9BQU87WUFDWCxJQUFJQSxNQUNBdEcsVUFBVXhILGFBQWFnTyxNQUFNLENBQUNyQixNQUFNLENBQUNoTyxFQUFFO1FBQy9DO1FBQ0EsSUFBSW1QLFNBQVMsT0FDVHRHLFVBQVV4SCxhQUFhZ08sTUFBTSxDQUFDO1FBQ2xDLE9BQU94RztJQUNYO0FBQ0o7QUFDQW1FLE9BQU9vQjtBQUNQQSx1QkFBdUI5TSxJQUFJLEdBQUc7QUFDN0I7SUFDR25ELE9BQU9DLGNBQWMsQ0FBQzRPLEtBQUtkLFNBQVMsRUFBRSxZQUFZO1FBQzlDNUwsS0FBSyxTQUFVbU8sQ0FBQztZQUNaLElBQUksQ0FBQzNMLFlBQVksR0FBRyxJQUFJekMsV0FBV29PO1lBQ25DLElBQUksQ0FBQ0gsV0FBVztRQUNwQjtRQUNBbFAsS0FBSztZQUNELE9BQU8sSUFBSSxDQUFDMEQsWUFBWSxDQUFDSSxLQUFLLEdBQUdoRCxNQUFNO1FBQzNDO0lBQ0o7QUFDSjtBQUVBLElBQUlvUDtBQUNKLE1BQU1yRyxnQkFBZ0I1QztJQUNsQnZGLFlBQVkyRixhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0EsWUFBWTJIO1FBQ2xCLElBQUksQ0FBQzlKLE9BQU8sQ0FBQ0ksUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLEdBQUc7SUFDN0I7SUFDQTRLLFdBQVc7UUFDUDlQO1FBQ0EsT0FBT0MsT0FBTyxJQUFJLENBQUNpSCxVQUFVLENBQUNRLFFBQVE7SUFDMUM7SUFDQSxPQUFPcUksV0FBV2xSLEtBQUssRUFBRTtRQUNyQm1CO1FBQ0EsTUFBTWdRLGNBQWMvUCxPQUFPcEI7UUFDM0IsTUFBTThGLFNBQVMsSUFBSXZEO1FBQ25CLE1BQU02TyxNQUFNRCxZQUFZdEksUUFBUSxDQUFDLElBQUl3SSxPQUFPLENBQUMsTUFBTTtRQUNuRCxNQUFNdk0sT0FBTyxJQUFJL0MsV0FBV2QscUJBQXFCcUUsT0FBTyxDQUFDZ00sT0FBTyxDQUFDRjtRQUNqRSxJQUFJRCxjQUFjLEdBQUc7WUFDakIsTUFBTXZDLFFBQVEsSUFBSTdNLFdBQVcrQyxLQUFLbkQsTUFBTSxHQUFJbUQsQ0FBQUEsSUFBSSxDQUFDLEVBQUUsR0FBRyxPQUFPLElBQUk7WUFDakU4SixLQUFLLENBQUMsRUFBRSxJQUFJO1lBQ1osTUFBTTJDLFdBQVduUSxPQUFPLENBQUMsRUFBRSxFQUFFSCxxQkFBcUJxRSxPQUFPLENBQUNDLEtBQUssQ0FBQ3FKLE9BQU8sQ0FBQztZQUN4RSxNQUFNNEMsWUFBWUQsV0FBV0o7WUFDN0IsTUFBTXRDLFNBQVM1TixxQkFBcUJ5RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDMUQscUJBQXFCcUUsT0FBTyxDQUFDZ00sT0FBTyxDQUFDRSxVQUFVM0ksUUFBUSxDQUFDO1lBQy9IZ0csTUFBTSxDQUFDLEVBQUUsSUFBSTtZQUNiL0ksT0FBT3BELEtBQUssQ0FBQ21NO1FBQ2pCLE9BQ0s7WUFDRCxJQUFJL0osSUFBSSxDQUFDLEVBQUUsR0FBRyxNQUFNO2dCQUNoQmdCLE9BQU9wRCxLQUFLLENBQUMsSUFBSVgsV0FBVztvQkFBQztpQkFBRTtZQUNuQztZQUNBK0QsT0FBT3BELEtBQUssQ0FBQ29DO1FBQ2pCO1FBQ0EsTUFBTTJNLE1BQU0sSUFBSTlHLFFBQVE7WUFDcEJsRyxVQUFVcUIsT0FBT2pELEtBQUs7UUFDMUI7UUFDQSxPQUFPNE87SUFDWDtJQUNBQyxlQUFlO1FBQ1gsTUFBTUMsVUFBVSxJQUFJaEgsUUFBUTtZQUFFbEcsVUFBVSxJQUFJLENBQUM0RCxVQUFVLENBQUM3RCxZQUFZO1FBQUM7UUFDckVtTixRQUFRdEosVUFBVSxDQUFDa0ksS0FBSztRQUN4QixPQUFPb0I7SUFDWDtJQUNBQyxpQkFBaUI7UUFDYixPQUFPLElBQUlqSCxRQUFRO1lBQ2ZsRyxVQUFVLElBQUksQ0FBQzRELFVBQVUsQ0FBQzdELFlBQVksQ0FBQyxFQUFFLEtBQUssSUFDeEMsSUFBSSxDQUFDNkQsVUFBVSxDQUFDN0QsWUFBWSxDQUFDUSxRQUFRLENBQUMsS0FDdEMsSUFBSSxDQUFDcUQsVUFBVSxDQUFDN0QsWUFBWTtRQUN0QztJQUNKO0lBQ0F1RSxrQkFBa0I7UUFDZCxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUN2RyxXQUFXLENBQUNRLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDcUYsVUFBVSxDQUFDUSxRQUFRLEdBQUcsQ0FBQztJQUNyRTtBQUNKO0FBQ0FtSSxPQUFPckc7QUFDTjtJQUNHN0MsVUFBVTZDLE9BQU8sR0FBR3FHO0FBQ3hCO0FBQ0FyRyxRQUFRM0gsSUFBSSxHQUFHO0FBRWYsSUFBSTZPO0FBQ0osTUFBTTdHLG1CQUFtQkw7SUFDckJuSSxZQUFZMkYsYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbkMsT0FBTyxDQUFDSSxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSixPQUFPLENBQUNLLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0F3TCxPQUFPN0c7QUFDTjtJQUNHbEQsVUFBVWtELFVBQVUsR0FBRzZHO0FBQzNCO0FBQ0E3RyxXQUFXaEksSUFBSSxHQUFHO0FBRWxCLE1BQU04TywyQkFBMkI3TixTQUFTMkI7SUFDdENwRCxZQUFZLEVBQUUwTixXQUFXLENBQUMsQ0FBQyxFQUFFNkIsYUFBYSxLQUFLLEVBQUUsR0FBRzVKLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNuRSxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDK0gsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUM2QixVQUFVLEdBQUdBO0lBQ3RCO0lBQ0FsTixRQUFRMUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxJQUFJLENBQUNBLGFBQWE7WUFDZCxPQUFPRDtRQUNYO1FBQ0EsTUFBTTBFLFlBQVk3RixxQkFBcUJ5RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDeEM7UUFDMUUsSUFBSSxDQUFDRixrQkFBa0IsSUFBSSxFQUFFNkUsV0FBVzFFLGFBQWFDLGNBQWM7WUFDL0QsT0FBTyxDQUFDO1FBQ1o7UUFDQSxNQUFNMEUsWUFBWUQsVUFBVTlCLFFBQVEsQ0FBQzVDLGFBQWFBLGNBQWNDO1FBQ2hFLElBQUksQ0FBQ21DLFlBQVksR0FBRyxJQUFJekMsV0FBV007UUFDbkMsSUFBSyxJQUFJWCxJQUFJLEdBQUdBLElBQUlXLGFBQWFYLElBQUs7WUFDbEMsSUFBSSxDQUFDOEMsWUFBWSxDQUFDOUMsRUFBRSxHQUFHcUYsU0FBUyxDQUFDckYsRUFBRSxHQUFHO1lBQ3RDLElBQUksQ0FBQ3dELFdBQVc7WUFDaEIsSUFBSSxDQUFDNkIsU0FBUyxDQUFDckYsRUFBRSxHQUFHLElBQUcsTUFBTyxNQUMxQjtRQUNSO1FBQ0EsTUFBTXNRLFdBQVcsSUFBSWpRLFdBQVcsSUFBSSxDQUFDbUQsV0FBVztRQUNoRCxJQUFLLElBQUl4RCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDd0QsV0FBVyxFQUFFeEQsSUFBSztZQUN2Q3NRLFFBQVEsQ0FBQ3RRLEVBQUUsR0FBRyxJQUFJLENBQUM4QyxZQUFZLENBQUM5QyxFQUFFO1FBQ3RDO1FBQ0EsSUFBSSxDQUFDOEMsWUFBWSxHQUFHd047UUFDcEIsSUFBSSxDQUFDakwsU0FBUyxDQUFDLElBQUksQ0FBQzdCLFdBQVcsR0FBRyxFQUFFLEdBQUcsSUFBRyxNQUFPLE1BQU07WUFDbkQsSUFBSSxDQUFDNUMsS0FBSyxHQUFHO1lBQ2IsT0FBTyxDQUFDO1FBQ1o7UUFDQSxJQUFJLElBQUksQ0FBQ2tDLFlBQVksQ0FBQyxFQUFFLEtBQUssTUFDekIsSUFBSSxDQUFDUyxRQUFRLENBQUNyQyxJQUFJLENBQUM7UUFDdkIsSUFBSSxJQUFJLENBQUNzQyxXQUFXLElBQUksR0FDcEIsSUFBSSxDQUFDZ0wsUUFBUSxHQUFHaFAsbUJBQW1Cb0csWUFBWSxDQUFDLElBQUksQ0FBQzlDLFlBQVksRUFBRTthQUNsRTtZQUNELElBQUksQ0FBQ0QsU0FBUyxHQUFHO1lBQ2pCLElBQUksQ0FBQ1UsUUFBUSxDQUFDckMsSUFBSSxDQUFDO1FBQ3ZCO1FBQ0EsT0FBUVIsY0FBYyxJQUFJLENBQUM4QyxXQUFXO0lBQzFDO0lBQ0EsSUFBSStNLFlBQVlqUyxLQUFLLEVBQUU7UUFDbkJtQjtRQUNBLElBQUlrTixPQUFPak4sT0FBT3BCLE9BQU82SSxRQUFRLENBQUM7UUFDbEMsTUFBT3dGLEtBQUsxTSxNQUFNLEdBQUcsRUFBRztZQUNwQjBNLE9BQU8sTUFBTUE7UUFDakI7UUFDQSxNQUFNNkQsUUFBUSxJQUFJblEsV0FBV3NNLEtBQUsxTSxNQUFNLEdBQUc7UUFDM0MsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLElBQUl3USxNQUFNdlEsTUFBTSxFQUFFRCxJQUFLO1lBQ25Dd1EsS0FBSyxDQUFDeFEsRUFBRSxHQUFHeVEsU0FBUzlELEtBQUt6SixLQUFLLENBQUNsRCxJQUFJLEdBQUdBLElBQUksSUFBSSxJQUFJLEtBQU1BLENBQUFBLElBQUksSUFBSXdRLE1BQU12USxNQUFNLEdBQUcsT0FBTztRQUMxRjtRQUNBLElBQUksQ0FBQ2tELE9BQU8sQ0FBQ3FOLE1BQU10USxNQUFNLEVBQUUsR0FBR3NRLE1BQU12USxNQUFNO0lBQzlDO0lBQ0F3RCxNQUFNQyxRQUFRLEVBQUU7UUFDWixJQUFJLElBQUksQ0FBQ2IsU0FBUyxFQUFFO1lBQ2hCLElBQUlhLFVBQ0EsT0FBUSxJQUFJeEIsWUFBWSxJQUFJLENBQUNZLFlBQVksQ0FBQzNDLFVBQVU7WUFDeEQsTUFBTWdGLFVBQVUsSUFBSSxDQUFDckMsWUFBWTtZQUNqQyxNQUFNMUMsVUFBVSxJQUFJQyxXQUFXLElBQUksQ0FBQ21ELFdBQVc7WUFDL0MsSUFBSyxJQUFJeEQsSUFBSSxHQUFHQSxJQUFLLElBQUksQ0FBQ3dELFdBQVcsR0FBRyxHQUFJeEQsSUFDeENJLE9BQU8sQ0FBQ0osRUFBRSxHQUFHbUYsT0FBTyxDQUFDbkYsRUFBRSxHQUFHO1lBQzlCSSxPQUFPLENBQUMsSUFBSSxDQUFDb0QsV0FBVyxHQUFHLEVBQUUsR0FBRzJCLE9BQU8sQ0FBQyxJQUFJLENBQUMzQixXQUFXLEdBQUcsRUFBRTtZQUM3RCxPQUFPcEQsUUFBUUYsTUFBTTtRQUN6QjtRQUNBLE1BQU02RSxhQUFhdkYsbUJBQW1Cd0YsVUFBVSxDQUFDLElBQUksQ0FBQ3dKLFFBQVEsRUFBRTtRQUNoRSxJQUFJekosV0FBVzVFLFVBQVUsS0FBSyxHQUFHO1lBQzdCLElBQUksQ0FBQ1MsS0FBSyxHQUFHO1lBQ2IsT0FBT3FCO1FBQ1g7UUFDQSxNQUFNN0IsVUFBVSxJQUFJQyxXQUFXMEUsV0FBVzVFLFVBQVU7UUFDcEQsSUFBSSxDQUFDdUQsVUFBVTtZQUNYLE1BQU11QixjQUFjLElBQUk1RSxXQUFXMEU7WUFDbkMsTUFBTTJMLE1BQU0zTCxXQUFXNUUsVUFBVSxHQUFHO1lBQ3BDLElBQUssSUFBSUgsSUFBSSxHQUFHQSxJQUFJMFEsS0FBSzFRLElBQ3JCSSxPQUFPLENBQUNKLEVBQUUsR0FBR2lGLFdBQVcsQ0FBQ2pGLEVBQUUsR0FBRztZQUNsQ0ksT0FBTyxDQUFDc1EsSUFBSSxHQUFHekwsV0FBVyxDQUFDeUwsSUFBSTtRQUNuQztRQUNBLE9BQU90UTtJQUNYO0lBQ0ErRyxXQUFXO1FBQ1AsSUFBSTBCLFNBQVM7UUFDYixJQUFJLElBQUksQ0FBQ2hHLFNBQVMsRUFDZGdHLFNBQVN0SixxQkFBcUJxRSxPQUFPLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUNmLFlBQVk7YUFDNUQ7WUFDRCxJQUFJLElBQUksQ0FBQ3VOLFVBQVUsRUFBRTtnQkFDakIsSUFBSU0sV0FBVyxJQUFJLENBQUNuQyxRQUFRO2dCQUM1QixJQUFJLElBQUksQ0FBQ0EsUUFBUSxJQUFJLElBQ2pCM0YsU0FBUztxQkFDUjtvQkFDRCxJQUFJLElBQUksQ0FBQzJGLFFBQVEsSUFBSSxJQUFJO3dCQUNyQjNGLFNBQVM7d0JBQ1Q4SCxZQUFZO29CQUNoQixPQUNLO3dCQUNEOUgsU0FBUzt3QkFDVDhILFlBQVk7b0JBQ2hCO2dCQUNKO2dCQUNBOUgsVUFBVThILFNBQVN4SixRQUFRO1lBQy9CLE9BRUkwQixTQUFTLElBQUksQ0FBQzJGLFFBQVEsQ0FBQ3JILFFBQVE7UUFDdkM7UUFDQSxPQUFPMEI7SUFDWDtJQUNBbEYsU0FBUztRQUNMLE9BQU87WUFDSCxHQUFHLEtBQUssQ0FBQ0EsUUFBUTtZQUNqQjZLLFVBQVUsSUFBSSxDQUFDQSxRQUFRO1lBQ3ZCNkIsWUFBWSxJQUFJLENBQUNBLFVBQVU7UUFDL0I7SUFDSjtBQUNKO0FBQ0FELG1CQUFtQjlPLElBQUksR0FBRztBQUUxQixNQUFNc1Asd0NBQXdDMU07SUFDMUNwRCxZQUFZLEVBQUV4QyxRQUFRMEQsWUFBWSxFQUFFLEdBQUd5RSxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDdEQsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ25JLEtBQUssR0FBRyxFQUFFO1FBQ2YsSUFBSUEsT0FBTztZQUNQLElBQUksQ0FBQ3dKLFVBQVUsQ0FBQ3hKO1FBQ3BCO0lBQ0o7SUFDQTZFLFFBQVExQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFO1FBQzNDLElBQUlpRyxlQUFlbEc7UUFDbkIsTUFBT0MsY0FBYyxFQUFHO1lBQ3BCLE1BQU1rUSxXQUFXLElBQUlUO1lBQ3JCeEosZUFBZWlLLFNBQVMxTixPQUFPLENBQUMxQyxhQUFhbUcsY0FBY2pHO1lBQzNELElBQUlpRyxpQkFBaUIsQ0FBQyxHQUFHO2dCQUNyQixJQUFJLENBQUNwRCxXQUFXLEdBQUc7Z0JBQ25CLElBQUksQ0FBQzVDLEtBQUssR0FBR2lRLFNBQVNqUSxLQUFLO2dCQUMzQixPQUFPZ0c7WUFDWDtZQUNBLElBQUksSUFBSSxDQUFDdEksS0FBSyxDQUFDMkIsTUFBTSxLQUFLLEdBQ3RCNFEsU0FBU1IsVUFBVSxHQUFHO1lBQzFCLElBQUksQ0FBQzdNLFdBQVcsSUFBSXFOLFNBQVNyTixXQUFXO1lBQ3hDN0MsZUFBZWtRLFNBQVNyTixXQUFXO1lBQ25DLElBQUksQ0FBQ2xGLEtBQUssQ0FBQzRDLElBQUksQ0FBQzJQO1FBQ3BCO1FBQ0EsT0FBT2pLO0lBQ1g7SUFDQW5ELE1BQU1DLFFBQVEsRUFBRTtRQUNaLE1BQU1vTixhQUFhLEVBQUU7UUFDckIsSUFBSyxJQUFJOVEsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzFCLEtBQUssQ0FBQzJCLE1BQU0sRUFBRUQsSUFBSztZQUN4QyxNQUFNK1EsV0FBVyxJQUFJLENBQUN6UyxLQUFLLENBQUMwQixFQUFFLENBQUN5RCxLQUFLLENBQUNDO1lBQ3JDLElBQUlxTixTQUFTNVEsVUFBVSxLQUFLLEdBQUc7Z0JBQzNCLElBQUksQ0FBQ1MsS0FBSyxHQUFHLElBQUksQ0FBQ3RDLEtBQUssQ0FBQzBCLEVBQUUsQ0FBQ1ksS0FBSztnQkFDaEMsT0FBT3FCO1lBQ1g7WUFDQTZPLFdBQVc1UCxJQUFJLENBQUM2UDtRQUNwQjtRQUNBLE9BQU9uUixPQUFPa1I7SUFDbEI7SUFDQWhKLFdBQVdrSixNQUFNLEVBQUU7UUFDZixJQUFJLENBQUMxUyxLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUkyUyxPQUFPO1FBQ1gsSUFBSUMsT0FBTztRQUNYLElBQUlDLE1BQU07UUFDVixJQUFJaEMsT0FBTztRQUNYLEdBQUc7WUFDQytCLE9BQU9GLE9BQU9JLE9BQU8sQ0FBQyxLQUFLSDtZQUMzQixJQUFJQyxTQUFTLENBQUMsR0FDVkMsTUFBTUgsT0FBT2pFLFNBQVMsQ0FBQ2tFO2lCQUV2QkUsTUFBTUgsT0FBT2pFLFNBQVMsQ0FBQ2tFLE1BQU1DO1lBQ2pDRCxPQUFPQyxPQUFPO1lBQ2QsSUFBSS9CLE1BQU07Z0JBQ04sTUFBTTBCLFdBQVcsSUFBSSxDQUFDdlMsS0FBSyxDQUFDLEVBQUU7Z0JBQzlCLElBQUkrUyxPQUFPO2dCQUNYLE9BQVFSLFNBQVNyQyxRQUFRO29CQUNyQixLQUFLO3dCQUNEO29CQUNKLEtBQUs7d0JBQ0Q2QyxPQUFPO3dCQUNQO29CQUNKLEtBQUs7d0JBQ0RBLE9BQU87d0JBQ1A7b0JBQ0o7d0JBQ0ksSUFBSSxDQUFDL1MsS0FBSyxHQUFHLEVBQUU7d0JBQ2Y7Z0JBQ1I7Z0JBQ0EsTUFBTWdULFlBQVliLFNBQVNVLEtBQUs7Z0JBQ2hDLElBQUlJLE1BQU1ELFlBQ047Z0JBQ0pULFNBQVNyQyxRQUFRLEdBQUc4QyxZQUFZRDtnQkFDaENsQyxPQUFPO1lBQ1gsT0FDSztnQkFDRCxNQUFNMEIsV0FBVyxJQUFJVDtnQkFDckIsSUFBSWUsTUFBTUssT0FBT0MsZ0JBQWdCLEVBQUU7b0JBQy9CaFM7b0JBQ0EsTUFBTWtSLFdBQVdqUixPQUFPeVI7b0JBQ3hCTixTQUFTTixXQUFXLEdBQUdJO2dCQUMzQixPQUNLO29CQUNERSxTQUFTckMsUUFBUSxHQUFHaUMsU0FBU1UsS0FBSztvQkFDbEMsSUFBSUksTUFBTVYsU0FBU3JDLFFBQVEsR0FDdkI7Z0JBQ1I7Z0JBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ2xRLEtBQUssQ0FBQzJCLE1BQU0sRUFBRTtvQkFDcEI0USxTQUFTUixVQUFVLEdBQUc7b0JBQ3RCbEIsT0FBTztnQkFDWDtnQkFDQSxJQUFJLENBQUM3USxLQUFLLENBQUM0QyxJQUFJLENBQUMyUDtZQUNwQjtRQUNKLFFBQVNLLFNBQVMsQ0FBQyxHQUFHO0lBQzFCO0lBQ0EvSixXQUFXO1FBQ1AsSUFBSTBCLFNBQVM7UUFDYixJQUFJaEcsWUFBWTtRQUNoQixJQUFLLElBQUk3QyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDMUIsS0FBSyxDQUFDMkIsTUFBTSxFQUFFRCxJQUFLO1lBQ3hDNkMsWUFBWSxJQUFJLENBQUN2RSxLQUFLLENBQUMwQixFQUFFLENBQUM2QyxTQUFTO1lBQ25DLElBQUk2TyxTQUFTLElBQUksQ0FBQ3BULEtBQUssQ0FBQzBCLEVBQUUsQ0FBQ21ILFFBQVE7WUFDbkMsSUFBSW5ILE1BQU0sR0FDTjZJLFNBQVMsQ0FBQyxFQUFFQSxPQUFPLENBQUMsQ0FBQztZQUN6QixJQUFJaEcsV0FBVztnQkFDWDZPLFNBQVMsQ0FBQyxDQUFDLEVBQUVBLE9BQU8sQ0FBQyxDQUFDO2dCQUN0QixJQUFJLElBQUksQ0FBQ3BULEtBQUssQ0FBQzBCLEVBQUUsQ0FBQ3FRLFVBQVUsRUFDeEJ4SCxTQUFTLENBQUMsR0FBRyxFQUFFNkksT0FBTyxNQUFNLENBQUM7cUJBRTdCN0ksVUFBVTZJO1lBQ2xCLE9BRUk3SSxVQUFVNkk7UUFDbEI7UUFDQSxPQUFPN0k7SUFDWDtJQUNBbEYsU0FBUztRQUNMLE1BQU11RCxTQUFTO1lBQ1gsR0FBRyxLQUFLLENBQUN2RCxRQUFRO1lBQ2pCckYsT0FBTyxJQUFJLENBQUM2SSxRQUFRO1lBQ3BCd0ssVUFBVSxFQUFFO1FBQ2hCO1FBQ0EsSUFBSyxJQUFJM1IsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzFCLEtBQUssQ0FBQzJCLE1BQU0sRUFBRUQsSUFBSztZQUN4Q2tILE9BQU95SyxRQUFRLENBQUN6USxJQUFJLENBQUMsSUFBSSxDQUFDNUMsS0FBSyxDQUFDMEIsRUFBRSxDQUFDMkQsTUFBTTtRQUM3QztRQUNBLE9BQU91RDtJQUNYO0FBQ0o7QUFDQTBKLGdDQUFnQ3RQLElBQUksR0FBRztBQUV2QyxJQUFJc1E7QUFDSixNQUFNdkkseUJBQXlCaEQ7SUFDM0J2RixZQUFZMkYsYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBLFlBQVltSztRQUNsQixJQUFJLENBQUN0TSxPQUFPLENBQUNJLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNKLE9BQU8sQ0FBQ0ssU0FBUyxHQUFHO0lBQzdCO0lBQ0FvRCxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUNwQixVQUFVLENBQUNRLFFBQVE7SUFDbkM7SUFDQWEsU0FBUzFKLEtBQUssRUFBRTtRQUNaLElBQUksQ0FBQ3FJLFVBQVUsQ0FBQ21CLFVBQVUsQ0FBQ3hKO0lBQy9CO0lBQ0ErSSxrQkFBa0I7UUFDZCxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUN2RyxXQUFXLENBQUNRLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDcUYsVUFBVSxDQUFDUSxRQUFRLE1BQU0sUUFBUSxDQUFDO0lBQ2hGO0lBQ0F4RCxTQUFTO1FBQ0wsT0FBTztZQUNILEdBQUcsS0FBSyxDQUFDQSxRQUFRO1lBQ2pCckYsT0FBTyxJQUFJLENBQUN5SixRQUFRO1FBQ3hCO0lBQ0o7QUFDSjtBQUNBNkosT0FBT3ZJO0FBQ047SUFDR2pELFVBQVVpRCxnQkFBZ0IsR0FBR3VJO0FBQ2pDO0FBQ0F2SSxpQkFBaUIvSCxJQUFJLEdBQUc7QUFFeEIsTUFBTXVRLG1DQUFtQ3RQLFNBQVN1QjtJQUM5Q2hELFlBQVksRUFBRTBOLFdBQVcsQ0FBQyxFQUFFLEdBQUcvSCxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDOUMsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQytILFFBQVEsR0FBR0E7SUFDcEI7SUFDQXJMLFFBQVExQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFO1FBQzNDLElBQUlBLGdCQUFnQixHQUNoQixPQUFPRDtRQUNYLE1BQU0wRSxZQUFZN0YscUJBQXFCeUQscUJBQXFCLENBQUNDLFlBQVksQ0FBQ3hDO1FBQzFFLElBQUksQ0FBQ0Ysa0JBQWtCLElBQUksRUFBRTZFLFdBQVcxRSxhQUFhQyxjQUNqRCxPQUFPLENBQUM7UUFDWixNQUFNMEUsWUFBWUQsVUFBVTlCLFFBQVEsQ0FBQzVDLGFBQWFBLGNBQWNDO1FBQ2hFLElBQUksQ0FBQ21DLFlBQVksR0FBRyxJQUFJekMsV0FBV007UUFDbkMsSUFBSyxJQUFJWCxJQUFJLEdBQUdBLElBQUlXLGFBQWFYLElBQUs7WUFDbEMsSUFBSSxDQUFDOEMsWUFBWSxDQUFDOUMsRUFBRSxHQUFHcUYsU0FBUyxDQUFDckYsRUFBRSxHQUFHO1lBQ3RDLElBQUksQ0FBQ3dELFdBQVc7WUFDaEIsSUFBSSxDQUFDNkIsU0FBUyxDQUFDckYsRUFBRSxHQUFHLElBQUcsTUFBTyxNQUMxQjtRQUNSO1FBQ0EsTUFBTXNRLFdBQVcsSUFBSWpRLFdBQVcsSUFBSSxDQUFDbUQsV0FBVztRQUNoRCxJQUFLLElBQUl4RCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDd0QsV0FBVyxFQUFFeEQsSUFDbENzUSxRQUFRLENBQUN0USxFQUFFLEdBQUcsSUFBSSxDQUFDOEMsWUFBWSxDQUFDOUMsRUFBRTtRQUN0QyxJQUFJLENBQUM4QyxZQUFZLEdBQUd3TjtRQUNwQixJQUFJLENBQUNqTCxTQUFTLENBQUMsSUFBSSxDQUFDN0IsV0FBVyxHQUFHLEVBQUUsR0FBRyxJQUFHLE1BQU8sTUFBTTtZQUNuRCxJQUFJLENBQUM1QyxLQUFLLEdBQUc7WUFDYixPQUFPLENBQUM7UUFDWjtRQUNBLElBQUksSUFBSSxDQUFDa0MsWUFBWSxDQUFDLEVBQUUsS0FBSyxNQUN6QixJQUFJLENBQUNTLFFBQVEsQ0FBQ3JDLElBQUksQ0FBQztRQUN2QixJQUFJLElBQUksQ0FBQ3NDLFdBQVcsSUFBSSxHQUNwQixJQUFJLENBQUNnTCxRQUFRLEdBQUdoUCxtQkFBbUJvRyxZQUFZLENBQUMsSUFBSSxDQUFDOUMsWUFBWSxFQUFFO2FBQ2xFO1lBQ0QsSUFBSSxDQUFDRCxTQUFTLEdBQUc7WUFDakIsSUFBSSxDQUFDVSxRQUFRLENBQUNyQyxJQUFJLENBQUM7UUFDdkI7UUFDQSxPQUFRUixjQUFjLElBQUksQ0FBQzhDLFdBQVc7SUFDMUM7SUFDQUMsTUFBTUMsUUFBUSxFQUFFO1FBQ1osSUFBSSxJQUFJLENBQUNiLFNBQVMsRUFBRTtZQUNoQixJQUFJYSxVQUNBLE9BQVEsSUFBSXhCLFlBQVksSUFBSSxDQUFDWSxZQUFZLENBQUMzQyxVQUFVO1lBQ3hELE1BQU1nRixVQUFVLElBQUksQ0FBQ3JDLFlBQVk7WUFDakMsTUFBTTFDLFVBQVUsSUFBSUMsV0FBVyxJQUFJLENBQUNtRCxXQUFXO1lBQy9DLElBQUssSUFBSXhELElBQUksR0FBR0EsSUFBSyxJQUFJLENBQUN3RCxXQUFXLEdBQUcsR0FBSXhELElBQ3hDSSxPQUFPLENBQUNKLEVBQUUsR0FBR21GLE9BQU8sQ0FBQ25GLEVBQUUsR0FBRztZQUM5QkksT0FBTyxDQUFDLElBQUksQ0FBQ29ELFdBQVcsR0FBRyxFQUFFLEdBQUcyQixPQUFPLENBQUMsSUFBSSxDQUFDM0IsV0FBVyxHQUFHLEVBQUU7WUFDN0QsT0FBT3BELFFBQVFGLE1BQU07UUFDekI7UUFDQSxNQUFNNkUsYUFBYXZGLG1CQUFtQndGLFVBQVUsQ0FBQyxJQUFJLENBQUN3SixRQUFRLEVBQUU7UUFDaEUsSUFBSXpKLFdBQVc1RSxVQUFVLEtBQUssR0FBRztZQUM3QixJQUFJLENBQUNTLEtBQUssR0FBRztZQUNiLE9BQU9xQjtRQUNYO1FBQ0EsTUFBTTdCLFVBQVUsSUFBSUMsV0FBVzBFLFdBQVc1RSxVQUFVO1FBQ3BELElBQUksQ0FBQ3VELFVBQVU7WUFDWCxNQUFNdUIsY0FBYyxJQUFJNUUsV0FBVzBFO1lBQ25DLE1BQU0yTCxNQUFNM0wsV0FBVzVFLFVBQVUsR0FBRztZQUNwQyxJQUFLLElBQUlILElBQUksR0FBR0EsSUFBSTBRLEtBQUsxUSxJQUNyQkksT0FBTyxDQUFDSixFQUFFLEdBQUdpRixXQUFXLENBQUNqRixFQUFFLEdBQUc7WUFDbENJLE9BQU8sQ0FBQ3NRLElBQUksR0FBR3pMLFdBQVcsQ0FBQ3lMLElBQUk7UUFDbkM7UUFDQSxPQUFPdFEsUUFBUUYsTUFBTTtJQUN6QjtJQUNBaUgsV0FBVztRQUNQLElBQUkwQixTQUFTO1FBQ2IsSUFBSSxJQUFJLENBQUNoRyxTQUFTLEVBQ2RnRyxTQUFTdEoscUJBQXFCcUUsT0FBTyxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDZixZQUFZO2FBQzVEO1lBQ0QrRixTQUFTLElBQUksQ0FBQzJGLFFBQVEsQ0FBQ3JILFFBQVE7UUFDbkM7UUFDQSxPQUFPMEI7SUFDWDtJQUNBbEYsU0FBUztRQUNMLE9BQU87WUFDSCxHQUFHLEtBQUssQ0FBQ0EsUUFBUTtZQUNqQjZLLFVBQVUsSUFBSSxDQUFDQSxRQUFRO1FBQzNCO0lBQ0o7QUFDSjtBQUNBcUQsMkJBQTJCdlEsSUFBSSxHQUFHO0FBRWxDLE1BQU13USxnREFBZ0Q1TjtJQUNsRHBELFlBQVksRUFBRXhDLFFBQVEwRCxZQUFZLEVBQUUsR0FBR3lFLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUN0RCxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbkksS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJQSxPQUFPO1lBQ1AsSUFBSSxDQUFDd0osVUFBVSxDQUFDeEo7UUFDcEI7SUFDSjtJQUNBNkUsUUFBUTFDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUU7UUFDM0MsSUFBSWlHLGVBQWVsRztRQUNuQixNQUFPQyxjQUFjLEVBQUc7WUFDcEIsTUFBTWtRLFdBQVcsSUFBSWdCO1lBQ3JCakwsZUFBZWlLLFNBQVMxTixPQUFPLENBQUMxQyxhQUFhbUcsY0FBY2pHO1lBQzNELElBQUlpRyxpQkFBaUIsQ0FBQyxHQUFHO2dCQUNyQixJQUFJLENBQUNwRCxXQUFXLEdBQUc7Z0JBQ25CLElBQUksQ0FBQzVDLEtBQUssR0FBR2lRLFNBQVNqUSxLQUFLO2dCQUMzQixPQUFPZ0c7WUFDWDtZQUNBLElBQUksQ0FBQ3BELFdBQVcsSUFBSXFOLFNBQVNyTixXQUFXO1lBQ3hDN0MsZUFBZWtRLFNBQVNyTixXQUFXO1lBQ25DLElBQUksQ0FBQ2xGLEtBQUssQ0FBQzRDLElBQUksQ0FBQzJQO1FBQ3BCO1FBQ0EsT0FBT2pLO0lBQ1g7SUFDQW5ELE1BQU1DLFFBQVEsRUFBRVUsTUFBTSxFQUFFO1FBQ3BCLE1BQU0wTSxhQUFhLEVBQUU7UUFDckIsSUFBSyxJQUFJOVEsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzFCLEtBQUssQ0FBQzJCLE1BQU0sRUFBRUQsSUFBSztZQUN4QyxNQUFNK1EsV0FBVyxJQUFJLENBQUN6UyxLQUFLLENBQUMwQixFQUFFLENBQUN5RCxLQUFLLENBQUNDO1lBQ3JDLElBQUlxTixTQUFTNVEsVUFBVSxLQUFLLEdBQUc7Z0JBQzNCLElBQUksQ0FBQ1MsS0FBSyxHQUFHLElBQUksQ0FBQ3RDLEtBQUssQ0FBQzBCLEVBQUUsQ0FBQ1ksS0FBSztnQkFDaEMsT0FBT3FCO1lBQ1g7WUFDQTZPLFdBQVc1UCxJQUFJLENBQUM2UDtRQUNwQjtRQUNBLE9BQU9uUixPQUFPa1I7SUFDbEI7SUFDQWhKLFdBQVdrSixNQUFNLEVBQUU7UUFDZixJQUFJLENBQUMxUyxLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUkyUyxPQUFPO1FBQ1gsSUFBSUMsT0FBTztRQUNYLElBQUlDLE1BQU07UUFDVixHQUFHO1lBQ0NELE9BQU9GLE9BQU9JLE9BQU8sQ0FBQyxLQUFLSDtZQUMzQixJQUFJQyxTQUFTLENBQUMsR0FDVkMsTUFBTUgsT0FBT2pFLFNBQVMsQ0FBQ2tFO2lCQUV2QkUsTUFBTUgsT0FBT2pFLFNBQVMsQ0FBQ2tFLE1BQU1DO1lBQ2pDRCxPQUFPQyxPQUFPO1lBQ2QsTUFBTUwsV0FBVyxJQUFJZ0I7WUFDckJoQixTQUFTckMsUUFBUSxHQUFHaUMsU0FBU1UsS0FBSztZQUNsQyxJQUFJSSxNQUFNVixTQUFTckMsUUFBUSxHQUN2QixPQUFPO1lBQ1gsSUFBSSxDQUFDbFEsS0FBSyxDQUFDNEMsSUFBSSxDQUFDMlA7UUFDcEIsUUFBU0ssU0FBUyxDQUFDLEdBQUc7UUFDdEIsT0FBTztJQUNYO0lBQ0EvSixXQUFXO1FBQ1AsSUFBSTBCLFNBQVM7UUFDYixJQUFJaEcsWUFBWTtRQUNoQixJQUFLLElBQUk3QyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDMUIsS0FBSyxDQUFDMkIsTUFBTSxFQUFFRCxJQUFLO1lBQ3hDNkMsWUFBWSxJQUFJLENBQUN2RSxLQUFLLENBQUMwQixFQUFFLENBQUM2QyxTQUFTO1lBQ25DLElBQUk2TyxTQUFTLElBQUksQ0FBQ3BULEtBQUssQ0FBQzBCLEVBQUUsQ0FBQ21ILFFBQVE7WUFDbkMsSUFBSW5ILE1BQU0sR0FDTjZJLFNBQVMsQ0FBQyxFQUFFQSxPQUFPLENBQUMsQ0FBQztZQUN6QixJQUFJaEcsV0FBVztnQkFDWDZPLFNBQVMsQ0FBQyxDQUFDLEVBQUVBLE9BQU8sQ0FBQyxDQUFDO2dCQUN0QjdJLFVBQVU2STtZQUNkLE9BRUk3SSxVQUFVNkk7UUFDbEI7UUFDQSxPQUFPN0k7SUFDWDtJQUNBbEYsU0FBUztRQUNMLE1BQU11RCxTQUFTO1lBQ1gsR0FBRyxLQUFLLENBQUN2RCxRQUFRO1lBQ2pCckYsT0FBTyxJQUFJLENBQUM2SSxRQUFRO1lBQ3BCd0ssVUFBVSxFQUFFO1FBQ2hCO1FBQ0EsSUFBSyxJQUFJM1IsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzFCLEtBQUssQ0FBQzJCLE1BQU0sRUFBRUQsSUFDbkNrSCxPQUFPeUssUUFBUSxDQUFDelEsSUFBSSxDQUFDLElBQUksQ0FBQzVDLEtBQUssQ0FBQzBCLEVBQUUsQ0FBQzJELE1BQU07UUFDN0MsT0FBT3VEO0lBQ1g7QUFDSjtBQUNBNEssd0NBQXdDeFEsSUFBSSxHQUFHO0FBRS9DLElBQUl5UTtBQUNKLE1BQU12SSxpQ0FBaUNuRDtJQUNuQ3ZGLFlBQVkyRixhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0EsWUFBWXFMO1FBQ2xCLElBQUksQ0FBQ3hOLE9BQU8sQ0FBQ0ksUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLEdBQUc7SUFDN0I7SUFDQW9ELFdBQVc7UUFDUCxPQUFPLElBQUksQ0FBQ3BCLFVBQVUsQ0FBQ1EsUUFBUTtJQUNuQztJQUNBYSxTQUFTMUosS0FBSyxFQUFFO1FBQ1osSUFBSSxDQUFDcUksVUFBVSxDQUFDbUIsVUFBVSxDQUFDeEo7SUFDL0I7SUFDQStJLGtCQUFrQjtRQUNkLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQ3ZHLFdBQVcsQ0FBQ1EsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUNxRixVQUFVLENBQUNRLFFBQVEsTUFBTSxRQUFRLENBQUM7SUFDaEY7SUFDQXhELFNBQVM7UUFDTCxPQUFPO1lBQ0gsR0FBRyxLQUFLLENBQUNBLFFBQVE7WUFDakJyRixPQUFPLElBQUksQ0FBQ3lKLFFBQVE7UUFDeEI7SUFDSjtBQUNKO0FBQ0FnSyxPQUFPdkk7QUFDTjtJQUNHcEQsVUFBVW9ELHdCQUF3QixHQUFHdUk7QUFDekM7QUFDQXZJLHlCQUF5QmxJLElBQUksR0FBRztBQUVoQyxJQUFJMFE7QUFDSixNQUFNdEksaUJBQWlCL0I7SUFDbkI3RyxZQUFZMkYsYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbkMsT0FBTyxDQUFDSSxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSixPQUFPLENBQUNLLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0FxTixPQUFPdEk7QUFDTjtJQUNHdEQsVUFBVXNELFFBQVEsR0FBR3NJO0FBQ3pCO0FBQ0F0SSxTQUFTcEksSUFBSSxHQUFHO0FBRWhCLElBQUkyUTtBQUNKLE1BQU10SSxZQUFZaEM7SUFDZDdHLFlBQVkyRixhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNuQyxPQUFPLENBQUNJLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNKLE9BQU8sQ0FBQ0ssU0FBUyxHQUFHO0lBQzdCO0FBQ0o7QUFDQXNOLE9BQU90STtBQUNOO0lBQ0d2RCxVQUFVdUQsR0FBRyxHQUFHc0k7QUFDcEI7QUFDQXRJLElBQUlySSxJQUFJLEdBQUc7QUFFWCxNQUFNNFEsOEJBQThCM1AsU0FBUzJCO0lBQ3pDcEQsWUFBWSxFQUFFLEdBQUcyRixZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDaEMsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQzVELFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUN2RSxLQUFLLEdBQUcwRDtJQUNqQjtJQUNBMkIsU0FBUztRQUNMLE9BQU87WUFDSCxHQUFHLEtBQUssQ0FBQ0EsUUFBUTtZQUNqQnJGLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1FBQ3JCO0lBQ0o7QUFDSjtBQUNBNFQsc0JBQXNCNVEsSUFBSSxHQUFHO0FBRTdCLE1BQU02USxvQ0FBb0NEO0FBQzFDO0FBQ0FDLDRCQUE0QjdRLElBQUksR0FBRztBQUVuQyxNQUFNOFEsK0JBQStCeEs7SUFDakM5RyxZQUFZLEVBQUUsR0FBRzJGLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNoQyxLQUFLLENBQUNBLFlBQVkwTDtJQUN0QjtJQUNBbEssV0FBV3hILFdBQVcsRUFBRTtRQUNwQixJQUFJLENBQUNrRyxVQUFVLENBQUNySSxLQUFLLEdBQUcrVCxPQUFPQyxZQUFZLENBQUNDLEtBQUssQ0FBQyxNQUFNaFQscUJBQXFCeUQscUJBQXFCLENBQUNDLFlBQVksQ0FBQ3hDO0lBQ3BIO0lBQ0FxSCxXQUFXMEssV0FBVyxFQUFFO1FBQ3BCLE1BQU1DLFNBQVNELFlBQVl2UyxNQUFNO1FBQ2pDLE1BQU1tRCxPQUFPLElBQUksQ0FBQ3VELFVBQVUsQ0FBQzdELFlBQVksR0FBRyxJQUFJekMsV0FBV29TO1FBQzNELElBQUssSUFBSXpTLElBQUksR0FBR0EsSUFBSXlTLFFBQVF6UyxJQUN4Qm9ELElBQUksQ0FBQ3BELEVBQUUsR0FBR3dTLFlBQVlFLFVBQVUsQ0FBQzFTO1FBQ3JDLElBQUksQ0FBQzJHLFVBQVUsQ0FBQ3JJLEtBQUssR0FBR2tVO0lBQzVCO0FBQ0o7QUFDQUosdUJBQXVCOVEsSUFBSSxHQUFHO0FBRTlCLE1BQU1xUixrQ0FBa0NQO0lBQ3BDbkssV0FBV3hILFdBQVcsRUFBRTtRQUNwQixJQUFJLENBQUNrRyxVQUFVLENBQUM3RCxZQUFZLEdBQUd2RCxxQkFBcUJ5RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDeEM7UUFDdkYsSUFBSTtZQUNBLElBQUksQ0FBQ2tHLFVBQVUsQ0FBQ3JJLEtBQUssR0FBR2lCLHFCQUFxQnFFLE9BQU8sQ0FBQ2dQLFlBQVksQ0FBQ25TO1FBQ3RFLEVBQ0EsT0FBT29TLElBQUk7WUFDUCxJQUFJLENBQUN0UCxRQUFRLENBQUNyQyxJQUFJLENBQUMsQ0FBQyxtQ0FBbUMsRUFBRTJSLEdBQUcsa0JBQWtCLENBQUM7WUFDL0UsSUFBSSxDQUFDbE0sVUFBVSxDQUFDckksS0FBSyxHQUFHaUIscUJBQXFCcUUsT0FBTyxDQUFDa1AsUUFBUSxDQUFDclM7UUFDbEU7SUFDSjtJQUNBcUgsV0FBVzBLLFdBQVcsRUFBRTtRQUNwQixJQUFJLENBQUM3TCxVQUFVLENBQUM3RCxZQUFZLEdBQUcsSUFBSXpDLFdBQVdkLHFCQUFxQnFFLE9BQU8sQ0FBQ21QLGNBQWMsQ0FBQ1A7UUFDMUYsSUFBSSxDQUFDN0wsVUFBVSxDQUFDckksS0FBSyxHQUFHa1U7SUFDNUI7QUFDSjtBQUNBRywwQkFBMEJyUixJQUFJLEdBQUc7QUFFakMsSUFBSTBSO0FBQ0osTUFBTXpKLG1CQUFtQm9KO0lBQ3JCN1IsWUFBWTJGLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ25DLE9BQU8sQ0FBQ0ksUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBcU8sT0FBT3pKO0FBQ047SUFDR25ELFVBQVVtRCxVQUFVLEdBQUd5SjtBQUMzQjtBQUNBekosV0FBV2pJLElBQUksR0FBRztBQUVsQixNQUFNMlIsaUNBQWlDYjtJQUNuQ25LLFdBQVd4SCxXQUFXLEVBQUU7UUFDcEIsSUFBSSxDQUFDa0csVUFBVSxDQUFDckksS0FBSyxHQUFHaUIscUJBQXFCcUUsT0FBTyxDQUFDc1AsYUFBYSxDQUFDelM7UUFDbkUsSUFBSSxDQUFDa0csVUFBVSxDQUFDN0QsWUFBWSxHQUFHdkQscUJBQXFCeUQscUJBQXFCLENBQUNDLFlBQVksQ0FBQ3hDO0lBQzNGO0lBQ0FxSCxXQUFXMEssV0FBVyxFQUFFO1FBQ3BCLElBQUksQ0FBQzdMLFVBQVUsQ0FBQ3JJLEtBQUssR0FBR2tVO1FBQ3hCLElBQUksQ0FBQzdMLFVBQVUsQ0FBQzdELFlBQVksR0FBRyxJQUFJekMsV0FBV2QscUJBQXFCcUUsT0FBTyxDQUFDdVAsZUFBZSxDQUFDWDtJQUMvRjtBQUNKO0FBQ0FTLHlCQUF5QjNSLElBQUksR0FBRztBQUVoQyxJQUFJOFI7QUFDSixNQUFNNUksa0JBQWtCeUk7SUFDcEJuUyxZQUFZLEVBQUUsR0FBRzJGLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNoQyxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbkMsT0FBTyxDQUFDSSxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSixPQUFPLENBQUNLLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0F5TyxPQUFPNUk7QUFDTjtJQUNHcEUsVUFBVW9FLFNBQVMsR0FBRzRJO0FBQzFCO0FBQ0E1SSxVQUFVbEosSUFBSSxHQUFHO0FBRWpCLE1BQU0rUix1Q0FBdUNqQjtJQUN6Q25LLFdBQVd4SCxXQUFXLEVBQUU7UUFDcEIsTUFBTTZTLGFBQWFwUixZQUFZcVIsTUFBTSxDQUFDOVMsZUFBZUEsWUFBWXlDLEtBQUssR0FBR2hELE1BQU0sR0FBR08sWUFBWXlDLEtBQUssQ0FBQztRQUNwRyxNQUFNc1EsWUFBWSxJQUFJblQsV0FBV2lUO1FBQ2pDLElBQUssSUFBSXRULElBQUksR0FBR0EsSUFBSXdULFVBQVV2VCxNQUFNLEVBQUVELEtBQUssRUFBRztZQUMxQ3dULFNBQVMsQ0FBQ3hULEVBQUUsR0FBR3dULFNBQVMsQ0FBQ3hULElBQUksRUFBRTtZQUMvQndULFNBQVMsQ0FBQ3hULElBQUksRUFBRSxHQUFHd1QsU0FBUyxDQUFDeFQsSUFBSSxFQUFFO1lBQ25Dd1QsU0FBUyxDQUFDeFQsSUFBSSxFQUFFLEdBQUc7WUFDbkJ3VCxTQUFTLENBQUN4VCxJQUFJLEVBQUUsR0FBRztRQUN2QjtRQUNBLElBQUksQ0FBQzJHLFVBQVUsQ0FBQ3JJLEtBQUssR0FBRytULE9BQU9DLFlBQVksQ0FBQ0MsS0FBSyxDQUFDLE1BQU0sSUFBSWtCLFlBQVlIO0lBQzVFO0lBQ0F4TCxXQUFXMEssV0FBVyxFQUFFO1FBQ3BCLE1BQU1rQixZQUFZbEIsWUFBWXZTLE1BQU07UUFDcEMsTUFBTTZDLGVBQWUsSUFBSSxDQUFDNkQsVUFBVSxDQUFDN0QsWUFBWSxHQUFHLElBQUl6QyxXQUFXcVQsWUFBWTtRQUMvRSxJQUFLLElBQUkxVCxJQUFJLEdBQUdBLElBQUkwVCxXQUFXMVQsSUFBSztZQUNoQyxNQUFNMlQsVUFBVW5VLG1CQUFtQndGLFVBQVUsQ0FBQ3dOLFlBQVlFLFVBQVUsQ0FBQzFTLElBQUk7WUFDekUsTUFBTTRULFdBQVcsSUFBSXZULFdBQVdzVDtZQUNoQyxJQUFJQyxTQUFTM1QsTUFBTSxHQUFHLEdBQ2xCO1lBQ0osTUFBTTRULE1BQU0sSUFBSUQsU0FBUzNULE1BQU07WUFDL0IsSUFBSyxJQUFJNlQsSUFBS0YsU0FBUzNULE1BQU0sR0FBRyxHQUFJNlQsS0FBSyxHQUFHQSxJQUN4Q2hSLFlBQVksQ0FBQzlDLElBQUksSUFBSThULElBQUlELElBQUksR0FBR0QsUUFBUSxDQUFDRSxFQUFFO1FBQ25EO1FBQ0EsSUFBSSxDQUFDbk4sVUFBVSxDQUFDckksS0FBSyxHQUFHa1U7SUFDNUI7QUFDSjtBQUNBYSwrQkFBK0IvUixJQUFJLEdBQUc7QUFFdEMsSUFBSXlTO0FBQ0osTUFBTXpKLHdCQUF3QitJO0lBQzFCdlMsWUFBWSxFQUFFLEdBQUcyRixZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDaEMsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ25DLE9BQU8sQ0FBQ0ksUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBb1AsT0FBT3pKO0FBQ047SUFDR2xFLFVBQVVrRSxlQUFlLEdBQUd5SjtBQUNoQztBQUNBekosZ0JBQWdCaEosSUFBSSxHQUFHO0FBRXZCLElBQUkwUztBQUNKLE1BQU1wSyxzQkFBc0J3STtJQUN4QnRSLFlBQVkyRixhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNuQyxPQUFPLENBQUNJLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNKLE9BQU8sQ0FBQ0ssU0FBUyxHQUFHO0lBQzdCO0FBQ0o7QUFDQXFQLE9BQU9wSztBQUNOO0lBQ0d4RCxVQUFVd0QsYUFBYSxHQUFHb0s7QUFDOUI7QUFDQXBLLGNBQWN0SSxJQUFJLEdBQUc7QUFFckIsSUFBSTJTO0FBQ0osTUFBTXBLLHdCQUF3QnVJO0lBQzFCdFIsWUFBWTJGLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ25DLE9BQU8sQ0FBQ0ksUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBc1AsT0FBT3BLO0FBQ047SUFDR3pELFVBQVV5RCxlQUFlLEdBQUdvSztBQUNoQztBQUNBcEssZ0JBQWdCdkksSUFBSSxHQUFHO0FBRXZCLElBQUk0UztBQUNKLE1BQU1wSyxzQkFBc0JzSTtJQUN4QnRSLFlBQVkyRixhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNuQyxPQUFPLENBQUNJLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNKLE9BQU8sQ0FBQ0ssU0FBUyxHQUFHO0lBQzdCO0FBQ0o7QUFDQXVQLE9BQU9wSztBQUNOO0lBQ0cxRCxVQUFVMEQsYUFBYSxHQUFHb0s7QUFDOUI7QUFDQXBLLGNBQWN4SSxJQUFJLEdBQUc7QUFFckIsSUFBSTZTO0FBQ0osTUFBTXBLLHVCQUF1QnFJO0lBQ3pCdFIsWUFBWTJGLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ25DLE9BQU8sQ0FBQ0ksUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBd1AsT0FBT3BLO0FBQ047SUFDRzNELFVBQVUyRCxjQUFjLEdBQUdvSztBQUMvQjtBQUNBcEssZUFBZXpJLElBQUksR0FBRztBQUV0QixJQUFJOFM7QUFDSixNQUFNcEssa0JBQWtCb0k7SUFDcEJ0UixZQUFZMkYsYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbkMsT0FBTyxDQUFDSSxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSixPQUFPLENBQUNLLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0F5UCxPQUFPcEs7QUFDTjtJQUNHNUQsVUFBVTRELFNBQVMsR0FBR29LO0FBQzFCO0FBQ0FwSyxVQUFVMUksSUFBSSxHQUFHO0FBRWpCLElBQUkrUztBQUNKLE1BQU1sSyxzQkFBc0JpSTtJQUN4QnRSLFlBQVkyRixhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNuQyxPQUFPLENBQUNJLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNKLE9BQU8sQ0FBQ0ssU0FBUyxHQUFHO0lBQzdCO0FBQ0o7QUFDQTBQLE9BQU9sSztBQUNOO0lBQ0cvRCxVQUFVK0QsYUFBYSxHQUFHa0s7QUFDOUI7QUFDQWxLLGNBQWM3SSxJQUFJLEdBQUc7QUFFckIsSUFBSWdUO0FBQ0osTUFBTWxLLHNCQUFzQmdJO0lBQ3hCdFIsWUFBWTJGLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ25DLE9BQU8sQ0FBQ0ksUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBMlAsT0FBT2xLO0FBQ047SUFDR2hFLFVBQVVnRSxhQUFhLEdBQUdrSztBQUM5QjtBQUNBbEssY0FBYzlJLElBQUksR0FBRztBQUVyQixJQUFJaVQ7QUFDSixNQUFNbEssc0JBQXNCK0g7SUFDeEJ0UixZQUFZMkYsYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbkMsT0FBTyxDQUFDSSxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSixPQUFPLENBQUNLLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0E0UCxPQUFPbEs7QUFDTjtJQUNHakUsVUFBVWlFLGFBQWEsR0FBR2tLO0FBQzlCO0FBQ0FsSyxjQUFjL0ksSUFBSSxHQUFHO0FBRXJCLElBQUlrVDtBQUNKLE1BQU1qSyx3QkFBd0I2SDtJQUMxQnRSLFlBQVkyRixhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNuQyxPQUFPLENBQUNJLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNKLE9BQU8sQ0FBQ0ssU0FBUyxHQUFHO0lBQzdCO0FBQ0o7QUFDQTZQLE9BQU9qSztBQUNOO0lBQ0duRSxVQUFVbUUsZUFBZSxHQUFHaUs7QUFDaEM7QUFDQWpLLGdCQUFnQmpKLElBQUksR0FBRztBQUV2QixJQUFJbVQ7QUFDSixNQUFNeEssZ0JBQWdCRztJQUNsQnRKLFlBQVksRUFBRXhDLEtBQUssRUFBRW9XLFNBQVMsRUFBRSxHQUFHak8sWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ2xELEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNrTyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQzVILE1BQU0sR0FBRztRQUNkLElBQUk3TyxPQUFPO1lBQ1AsSUFBSSxDQUFDd0osVUFBVSxDQUFDeEo7WUFDaEIsSUFBSSxDQUFDcUksVUFBVSxDQUFDN0QsWUFBWSxHQUFHLElBQUl6QyxXQUFXL0IsTUFBTTJCLE1BQU07WUFDMUQsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLElBQUkxQixNQUFNMkIsTUFBTSxFQUFFRCxJQUM5QixJQUFJLENBQUMyRyxVQUFVLENBQUM3RCxZQUFZLENBQUM5QyxFQUFFLEdBQUcxQixNQUFNb1UsVUFBVSxDQUFDMVM7UUFDM0Q7UUFDQSxJQUFJMFUsV0FBVztZQUNYLElBQUksQ0FBQ00sUUFBUSxDQUFDTjtZQUNkLElBQUksQ0FBQy9OLFVBQVUsQ0FBQzdELFlBQVksR0FBRyxJQUFJekMsV0FBVyxJQUFJLENBQUM0VSxRQUFRO1FBQy9EO1FBQ0EsSUFBSSxDQUFDM1EsT0FBTyxDQUFDSSxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSixPQUFPLENBQUNLLFNBQVMsR0FBRztJQUM3QjtJQUNBc0QsV0FBV3hILFdBQVcsRUFBRTtRQUNwQixJQUFJLENBQUNxSCxVQUFVLENBQUN1SyxPQUFPQyxZQUFZLENBQUNDLEtBQUssQ0FBQyxNQUFNaFQscUJBQXFCeUQscUJBQXFCLENBQUNDLFlBQVksQ0FBQ3hDO0lBQzVHO0lBQ0F3VSxXQUFXO1FBQ1AsTUFBTUMsTUFBTSxJQUFJLENBQUMvTixRQUFRO1FBQ3pCLE1BQU1qSCxTQUFTLElBQUlnQyxZQUFZZ1QsSUFBSWpWLE1BQU07UUFDekMsTUFBTW1ELE9BQU8sSUFBSS9DLFdBQVdIO1FBQzVCLElBQUssSUFBSUYsSUFBSSxHQUFHQSxJQUFJa1YsSUFBSWpWLE1BQU0sRUFBRUQsSUFDNUJvRCxJQUFJLENBQUNwRCxFQUFFLEdBQUdrVixJQUFJeEMsVUFBVSxDQUFDMVM7UUFDN0IsT0FBT0U7SUFDWDtJQUNBOFUsU0FBU0csU0FBUyxFQUFFO1FBQ2hCLElBQUksQ0FBQ1IsSUFBSSxHQUFHUSxVQUFVQyxjQUFjO1FBQ3BDLElBQUksQ0FBQ1IsS0FBSyxHQUFHTyxVQUFVRSxXQUFXLEtBQUs7UUFDdkMsSUFBSSxDQUFDUixHQUFHLEdBQUdNLFVBQVVHLFVBQVU7UUFDL0IsSUFBSSxDQUFDUixJQUFJLEdBQUdLLFVBQVVJLFdBQVc7UUFDakMsSUFBSSxDQUFDUixNQUFNLEdBQUdJLFVBQVVLLGFBQWE7UUFDckMsSUFBSSxDQUFDckksTUFBTSxHQUFHZ0ksVUFBVU0sYUFBYTtJQUN6QztJQUNBQyxTQUFTO1FBQ0wsT0FBUSxJQUFJQyxLQUFLQSxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDakIsSUFBSSxFQUFFLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEdBQUcsSUFBSSxDQUFDQyxHQUFHLEVBQUUsSUFBSSxDQUFDQyxJQUFJLEVBQUUsSUFBSSxDQUFDQyxNQUFNLEVBQUUsSUFBSSxDQUFDNUgsTUFBTTtJQUN0RztJQUNBckYsV0FBVzBLLFdBQVcsRUFBRTtRQUNwQixNQUFNcUQsU0FBUztRQUNmLE1BQU1DLGNBQWNELE9BQU9FLElBQUksQ0FBQ3ZEO1FBQ2hDLElBQUlzRCxnQkFBZ0IsTUFBTTtZQUN0QixJQUFJLENBQUNsVixLQUFLLEdBQUc7WUFDYjtRQUNKO1FBQ0EsTUFBTStULE9BQU9sRSxTQUFTcUYsV0FBVyxDQUFDLEVBQUUsRUFBRTtRQUN0QyxJQUFJbkIsUUFBUSxJQUNSLElBQUksQ0FBQ0EsSUFBSSxHQUFHLE9BQU9BO2FBRW5CLElBQUksQ0FBQ0EsSUFBSSxHQUFHLE9BQU9BO1FBQ3ZCLElBQUksQ0FBQ0MsS0FBSyxHQUFHbkUsU0FBU3FGLFdBQVcsQ0FBQyxFQUFFLEVBQUU7UUFDdEMsSUFBSSxDQUFDakIsR0FBRyxHQUFHcEUsU0FBU3FGLFdBQVcsQ0FBQyxFQUFFLEVBQUU7UUFDcEMsSUFBSSxDQUFDaEIsSUFBSSxHQUFHckUsU0FBU3FGLFdBQVcsQ0FBQyxFQUFFLEVBQUU7UUFDckMsSUFBSSxDQUFDZixNQUFNLEdBQUd0RSxTQUFTcUYsV0FBVyxDQUFDLEVBQUUsRUFBRTtRQUN2QyxJQUFJLENBQUMzSSxNQUFNLEdBQUdzRCxTQUFTcUYsV0FBVyxDQUFDLEVBQUUsRUFBRTtJQUMzQztJQUNBM08sU0FBU0MsV0FBVyxLQUFLLEVBQUU7UUFDdkIsSUFBSUEsYUFBYSxPQUFPO1lBQ3BCLE1BQU00TyxjQUFjLElBQUlDLE1BQU07WUFDOUJELFdBQVcsQ0FBQyxFQUFFLEdBQUd4VyxtQkFBbUIwVyxTQUFTLENBQUUsSUFBSyxDQUFDdkIsSUFBSSxHQUFHLE9BQVMsSUFBSSxDQUFDQSxJQUFJLEdBQUcsT0FBUyxJQUFJLENBQUNBLElBQUksR0FBRyxNQUFRO1lBQzlHcUIsV0FBVyxDQUFDLEVBQUUsR0FBR3hXLG1CQUFtQjBXLFNBQVMsQ0FBQyxJQUFJLENBQUN0QixLQUFLLEVBQUU7WUFDMURvQixXQUFXLENBQUMsRUFBRSxHQUFHeFcsbUJBQW1CMFcsU0FBUyxDQUFDLElBQUksQ0FBQ3JCLEdBQUcsRUFBRTtZQUN4RG1CLFdBQVcsQ0FBQyxFQUFFLEdBQUd4VyxtQkFBbUIwVyxTQUFTLENBQUMsSUFBSSxDQUFDcEIsSUFBSSxFQUFFO1lBQ3pEa0IsV0FBVyxDQUFDLEVBQUUsR0FBR3hXLG1CQUFtQjBXLFNBQVMsQ0FBQyxJQUFJLENBQUNuQixNQUFNLEVBQUU7WUFDM0RpQixXQUFXLENBQUMsRUFBRSxHQUFHeFcsbUJBQW1CMFcsU0FBUyxDQUFDLElBQUksQ0FBQy9JLE1BQU0sRUFBRTtZQUMzRDZJLFdBQVcsQ0FBQyxFQUFFLEdBQUc7WUFDakIsT0FBT0EsWUFBWXpLLElBQUksQ0FBQztRQUM1QjtRQUNBLE9BQU8sS0FBSyxDQUFDcEUsU0FBU0M7SUFDMUI7SUFDQUMsa0JBQWtCO1FBQ2QsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDdkcsV0FBVyxDQUFDUSxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQ29VLE1BQU0sR0FBR1MsV0FBVyxHQUFHLENBQUM7SUFDdEU7SUFDQXhTLFNBQVM7UUFDTCxPQUFPO1lBQ0gsR0FBRyxLQUFLLENBQUNBLFFBQVE7WUFDakJnUixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmQyxPQUFPLElBQUksQ0FBQ0EsS0FBSztZQUNqQkMsS0FBSyxJQUFJLENBQUNBLEdBQUc7WUFDYkMsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkMsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkI1SCxRQUFRLElBQUksQ0FBQ0EsTUFBTTtRQUN2QjtJQUNKO0FBQ0o7QUFDQXNILE9BQU94SztBQUNOO0lBQ0c3RCxVQUFVNkQsT0FBTyxHQUFHd0s7QUFDeEI7QUFDQXhLLFFBQVEzSSxJQUFJLEdBQUc7QUFFZixJQUFJOFU7QUFDSixNQUFNbE0sd0JBQXdCRDtJQUMxQm5KLFlBQVkyRixhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLElBQUlsQztRQUNKLEtBQUssQ0FBQ2tDO1FBQ0xsQyxDQUFBQSxLQUFLLElBQUksQ0FBQzhSLFdBQVcsTUFBTSxRQUFROVIsT0FBTyxLQUFLLElBQUlBLEtBQU0sSUFBSSxDQUFDOFIsV0FBVyxHQUFHO1FBQzdFLElBQUksQ0FBQy9SLE9BQU8sQ0FBQ0ksUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLEdBQUc7SUFDN0I7SUFDQXFRLFNBQVNHLFNBQVMsRUFBRTtRQUNoQixLQUFLLENBQUNILFNBQVNHO1FBQ2YsSUFBSSxDQUFDa0IsV0FBVyxHQUFHbEIsVUFBVW1CLGtCQUFrQjtJQUNuRDtJQUNBWixTQUFTO1FBQ0wsT0FBUSxJQUFJQyxLQUFLQSxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDakIsSUFBSSxFQUFFLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEdBQUcsSUFBSSxDQUFDQyxHQUFHLEVBQUUsSUFBSSxDQUFDQyxJQUFJLEVBQUUsSUFBSSxDQUFDQyxNQUFNLEVBQUUsSUFBSSxDQUFDNUgsTUFBTSxFQUFFLElBQUksQ0FBQ2tKLFdBQVc7SUFDeEg7SUFDQXZPLFdBQVcwSyxXQUFXLEVBQUU7UUFDcEIsSUFBSStELFFBQVE7UUFDWixJQUFJQyxhQUFhO1FBQ2pCLElBQUlDLGlCQUFpQjtRQUNyQixJQUFJQyxlQUFlO1FBQ25CLElBQUliO1FBQ0osSUFBSWMsaUJBQWlCO1FBQ3JCLElBQUlDLG1CQUFtQjtRQUN2QixJQUFJcEUsV0FBVyxDQUFDQSxZQUFZdlMsTUFBTSxHQUFHLEVBQUUsS0FBSyxLQUFLO1lBQzdDdVcsYUFBYWhFLFlBQVl6RixTQUFTLENBQUMsR0FBR3lGLFlBQVl2UyxNQUFNLEdBQUc7WUFDM0RzVyxRQUFRO1FBQ1osT0FDSztZQUNELE1BQU16UixTQUFTLElBQUkwTSxPQUFPZ0IsV0FBVyxDQUFDQSxZQUFZdlMsTUFBTSxHQUFHLEVBQUU7WUFDN0QsSUFBSXNSLE1BQU16TSxPQUFPK1IsT0FBTyxLQUNwQixNQUFNLElBQUlsWCxNQUFNO1lBQ3BCNlcsYUFBYWhFO1FBQ2pCO1FBQ0EsSUFBSStELE9BQU87WUFDUCxJQUFJQyxXQUFXcEYsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUM3QixNQUFNLElBQUl6UixNQUFNO1lBQ3BCLElBQUk2VyxXQUFXcEYsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUM3QixNQUFNLElBQUl6UixNQUFNO1FBQ3hCLE9BQ0s7WUFDRCxJQUFJbVgsYUFBYTtZQUNqQixJQUFJQyxxQkFBcUJQLFdBQVdwRixPQUFPLENBQUM7WUFDNUMsSUFBSTRGLG1CQUFtQjtZQUN2QixJQUFJRCx1QkFBdUIsQ0FBQyxHQUFHO2dCQUMzQkEscUJBQXFCUCxXQUFXcEYsT0FBTyxDQUFDO2dCQUN4QzBGLGFBQWEsQ0FBQztZQUNsQjtZQUNBLElBQUlDLHVCQUF1QixDQUFDLEdBQUc7Z0JBQzNCQyxtQkFBbUJSLFdBQVd6SixTQUFTLENBQUNnSyxxQkFBcUI7Z0JBQzdEUCxhQUFhQSxXQUFXekosU0FBUyxDQUFDLEdBQUdnSztnQkFDckMsSUFBSSxpQkFBa0I5VyxNQUFNLEtBQUssS0FBTytXLGlCQUFpQi9XLE1BQU0sS0FBSyxHQUNoRSxNQUFNLElBQUlOLE1BQU07Z0JBQ3BCLElBQUltRixTQUFTMkwsU0FBU3VHLGlCQUFpQmpLLFNBQVMsQ0FBQyxHQUFHLElBQUk7Z0JBQ3hELElBQUl3RSxNQUFNek0sT0FBTytSLE9BQU8sS0FDcEIsTUFBTSxJQUFJbFgsTUFBTTtnQkFDcEJnWCxpQkFBaUJHLGFBQWFoUztnQkFDOUIsSUFBSWtTLGlCQUFpQi9XLE1BQU0sS0FBSyxHQUFHO29CQUMvQjZFLFNBQVMyTCxTQUFTdUcsaUJBQWlCakssU0FBUyxDQUFDLEdBQUcsSUFBSTtvQkFDcEQsSUFBSXdFLE1BQU16TSxPQUFPK1IsT0FBTyxLQUNwQixNQUFNLElBQUlsWCxNQUFNO29CQUNwQmlYLG1CQUFtQkUsYUFBYWhTO2dCQUNwQztZQUNKO1FBQ0o7UUFDQSxJQUFJbVMsd0JBQXdCVCxXQUFXcEYsT0FBTyxDQUFDO1FBQy9DLElBQUk2RiwwQkFBMEIsQ0FBQyxHQUMzQkEsd0JBQXdCVCxXQUFXcEYsT0FBTyxDQUFDO1FBQy9DLElBQUk2RiwwQkFBMEIsQ0FBQyxHQUFHO1lBQzlCLE1BQU1DLG9CQUFvQixJQUFJMUYsT0FBTyxDQUFDLENBQUMsRUFBRWdGLFdBQVd6SixTQUFTLENBQUNrSyx1QkFBdUIsQ0FBQztZQUN0RixJQUFJMUYsTUFBTTJGLGtCQUFrQkwsT0FBTyxLQUMvQixNQUFNLElBQUlsWCxNQUFNO1lBQ3BCK1csZUFBZVEsa0JBQWtCTCxPQUFPO1lBQ3hDSixpQkFBaUJELFdBQVd6SixTQUFTLENBQUMsR0FBR2tLO1FBQzdDLE9BRUlSLGlCQUFpQkQ7UUFDckIsT0FBUTtZQUNKLEtBQU1DLGVBQWV4VyxNQUFNLEtBQUs7Z0JBQzVCNFYsU0FBUztnQkFDVCxJQUFJb0IsMEJBQTBCLENBQUMsR0FDM0IsTUFBTSxJQUFJdFgsTUFBTTtnQkFDcEI7WUFDSixLQUFNOFcsZUFBZXhXLE1BQU0sS0FBSztnQkFDNUI0VixTQUFTO2dCQUNULElBQUlvQiwwQkFBMEIsQ0FBQyxHQUFHO29CQUM5QixJQUFJRSxpQkFBaUIsS0FBS1Q7b0JBQzFCLElBQUksQ0FBQzNCLE1BQU0sR0FBR3FDLEtBQUtDLEtBQUssQ0FBQ0Y7b0JBQ3pCQSxpQkFBaUIsS0FBTUEsQ0FBQUEsaUJBQWlCLElBQUksQ0FBQ3BDLE1BQU07b0JBQ25ELElBQUksQ0FBQzVILE1BQU0sR0FBR2lLLEtBQUtDLEtBQUssQ0FBQ0Y7b0JBQ3pCQSxpQkFBaUIsT0FBUUEsQ0FBQUEsaUJBQWlCLElBQUksQ0FBQ2hLLE1BQU07b0JBQ3JELElBQUksQ0FBQ2tKLFdBQVcsR0FBR2UsS0FBS0MsS0FBSyxDQUFDRjtnQkFDbEM7Z0JBQ0E7WUFDSixLQUFNVixlQUFleFcsTUFBTSxLQUFLO2dCQUM1QjRWLFNBQVM7Z0JBQ1QsSUFBSW9CLDBCQUEwQixDQUFDLEdBQUc7b0JBQzlCLElBQUlFLGlCQUFpQixLQUFLVDtvQkFDMUIsSUFBSSxDQUFDdkosTUFBTSxHQUFHaUssS0FBS0MsS0FBSyxDQUFDRjtvQkFDekJBLGlCQUFpQixPQUFRQSxDQUFBQSxpQkFBaUIsSUFBSSxDQUFDaEssTUFBTTtvQkFDckQsSUFBSSxDQUFDa0osV0FBVyxHQUFHZSxLQUFLQyxLQUFLLENBQUNGO2dCQUNsQztnQkFDQTtZQUNKLEtBQU1WLGVBQWV4VyxNQUFNLEtBQUs7Z0JBQzVCNFYsU0FBUztnQkFDVCxJQUFJb0IsMEJBQTBCLENBQUMsR0FBRztvQkFDOUIsTUFBTUUsaUJBQWlCLE9BQU9UO29CQUM5QixJQUFJLENBQUNMLFdBQVcsR0FBR2UsS0FBS0MsS0FBSyxDQUFDRjtnQkFDbEM7Z0JBQ0E7WUFDSjtnQkFDSSxNQUFNLElBQUl4WCxNQUFNO1FBQ3hCO1FBQ0EsTUFBTW1XLGNBQWNELE9BQU9FLElBQUksQ0FBQ1U7UUFDaEMsSUFBSVgsZ0JBQWdCLE1BQ2hCLE1BQU0sSUFBSW5XLE1BQU07UUFDcEIsSUFBSyxJQUFJbVUsSUFBSSxHQUFHQSxJQUFJZ0MsWUFBWTdWLE1BQU0sRUFBRTZULElBQUs7WUFDekMsT0FBUUE7Z0JBQ0osS0FBSztvQkFDRCxJQUFJLENBQUNhLElBQUksR0FBR2xFLFNBQVNxRixXQUFXLENBQUNoQyxFQUFFLEVBQUU7b0JBQ3JDO2dCQUNKLEtBQUs7b0JBQ0QsSUFBSSxDQUFDYyxLQUFLLEdBQUduRSxTQUFTcUYsV0FBVyxDQUFDaEMsRUFBRSxFQUFFO29CQUN0QztnQkFDSixLQUFLO29CQUNELElBQUksQ0FBQ2UsR0FBRyxHQUFHcEUsU0FBU3FGLFdBQVcsQ0FBQ2hDLEVBQUUsRUFBRTtvQkFDcEM7Z0JBQ0osS0FBSztvQkFDRCxJQUFJLENBQUNnQixJQUFJLEdBQUdyRSxTQUFTcUYsV0FBVyxDQUFDaEMsRUFBRSxFQUFFLE1BQU02QztvQkFDM0M7Z0JBQ0osS0FBSztvQkFDRCxJQUFJLENBQUM1QixNQUFNLEdBQUd0RSxTQUFTcUYsV0FBVyxDQUFDaEMsRUFBRSxFQUFFLE1BQU04QztvQkFDN0M7Z0JBQ0osS0FBSztvQkFDRCxJQUFJLENBQUN6SixNQUFNLEdBQUdzRCxTQUFTcUYsV0FBVyxDQUFDaEMsRUFBRSxFQUFFO29CQUN2QztnQkFDSjtvQkFDSSxNQUFNLElBQUluVSxNQUFNO1lBQ3hCO1FBQ0o7UUFDQSxJQUFJNFcsVUFBVSxPQUFPO1lBQ2pCLE1BQU1lLFdBQVcsSUFBSTNCLEtBQUssSUFBSSxDQUFDaEIsSUFBSSxFQUFFLElBQUksQ0FBQ0MsS0FBSyxFQUFFLElBQUksQ0FBQ0MsR0FBRyxFQUFFLElBQUksQ0FBQ0MsSUFBSSxFQUFFLElBQUksQ0FBQ0MsTUFBTSxFQUFFLElBQUksQ0FBQzVILE1BQU0sRUFBRSxJQUFJLENBQUNrSixXQUFXO1lBQ2hILElBQUksQ0FBQzFCLElBQUksR0FBRzJDLFNBQVNsQyxjQUFjO1lBQ25DLElBQUksQ0FBQ1IsS0FBSyxHQUFHMEMsU0FBU2pDLFdBQVc7WUFDakMsSUFBSSxDQUFDUixHQUFHLEdBQUd5QyxTQUFTQyxTQUFTO1lBQzdCLElBQUksQ0FBQ3pDLElBQUksR0FBR3dDLFNBQVMvQixXQUFXO1lBQ2hDLElBQUksQ0FBQ1IsTUFBTSxHQUFHdUMsU0FBUzlCLGFBQWE7WUFDcEMsSUFBSSxDQUFDckksTUFBTSxHQUFHbUssU0FBUzdCLGFBQWE7WUFDcEMsSUFBSSxDQUFDWSxXQUFXLEdBQUdpQixTQUFTaEIsa0JBQWtCO1FBQ2xEO0lBQ0o7SUFDQW5QLFNBQVNDLFdBQVcsS0FBSyxFQUFFO1FBQ3ZCLElBQUlBLGFBQWEsT0FBTztZQUNwQixNQUFNNE8sY0FBYyxFQUFFO1lBQ3RCQSxZQUFZOVUsSUFBSSxDQUFDMUIsbUJBQW1CMFcsU0FBUyxDQUFDLElBQUksQ0FBQ3ZCLElBQUksRUFBRTtZQUN6RHFCLFlBQVk5VSxJQUFJLENBQUMxQixtQkFBbUIwVyxTQUFTLENBQUMsSUFBSSxDQUFDdEIsS0FBSyxFQUFFO1lBQzFEb0IsWUFBWTlVLElBQUksQ0FBQzFCLG1CQUFtQjBXLFNBQVMsQ0FBQyxJQUFJLENBQUNyQixHQUFHLEVBQUU7WUFDeERtQixZQUFZOVUsSUFBSSxDQUFDMUIsbUJBQW1CMFcsU0FBUyxDQUFDLElBQUksQ0FBQ3BCLElBQUksRUFBRTtZQUN6RGtCLFlBQVk5VSxJQUFJLENBQUMxQixtQkFBbUIwVyxTQUFTLENBQUMsSUFBSSxDQUFDbkIsTUFBTSxFQUFFO1lBQzNEaUIsWUFBWTlVLElBQUksQ0FBQzFCLG1CQUFtQjBXLFNBQVMsQ0FBQyxJQUFJLENBQUMvSSxNQUFNLEVBQUU7WUFDM0QsSUFBSSxJQUFJLENBQUNrSixXQUFXLEtBQUssR0FBRztnQkFDeEJMLFlBQVk5VSxJQUFJLENBQUM7Z0JBQ2pCOFUsWUFBWTlVLElBQUksQ0FBQzFCLG1CQUFtQjBXLFNBQVMsQ0FBQyxJQUFJLENBQUNHLFdBQVcsRUFBRTtZQUNwRTtZQUNBTCxZQUFZOVUsSUFBSSxDQUFDO1lBQ2pCLE9BQU84VSxZQUFZekssSUFBSSxDQUFDO1FBQzVCO1FBQ0EsT0FBTyxLQUFLLENBQUNwRSxTQUFTQztJQUMxQjtJQUNBekQsU0FBUztRQUNMLE9BQU87WUFDSCxHQUFHLEtBQUssQ0FBQ0EsUUFBUTtZQUNqQjBTLGFBQWEsSUFBSSxDQUFDQSxXQUFXO1FBQ2pDO0lBQ0o7QUFDSjtBQUNBRCxPQUFPbE07QUFDTjtJQUNHOUQsVUFBVThELGVBQWUsR0FBR2tNO0FBQ2hDO0FBQ0FsTSxnQkFBZ0I1SSxJQUFJLEdBQUc7QUFFdkIsSUFBSWtXO0FBQ0osTUFBTS9NLGFBQWFsQjtJQUNmekksWUFBWTJGLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ25DLE9BQU8sQ0FBQ0ksUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBNlMsT0FBTy9NO0FBQ047SUFDR3JFLFVBQVVxRSxJQUFJLEdBQUcrTTtBQUNyQjtBQUNBL00sS0FBS25KLElBQUksR0FBRztBQUVaLElBQUltVztBQUNKLE1BQU0vTSxrQkFBa0JuQjtJQUNwQnpJLFlBQVkyRixhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNuQyxPQUFPLENBQUNJLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNKLE9BQU8sQ0FBQ0ssU0FBUyxHQUFHO0lBQzdCO0FBQ0o7QUFDQThTLE9BQU8vTTtBQUNOO0lBQ0d0RSxVQUFVc0UsU0FBUyxHQUFHK007QUFDMUI7QUFDQS9NLFVBQVVwSixJQUFJLEdBQUc7QUFFakIsSUFBSW9XO0FBQ0osTUFBTS9NLGlCQUFpQnBCO0lBQ25CekksWUFBWTJGLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ25DLE9BQU8sQ0FBQ0ksUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBK1MsT0FBTy9NO0FBQ047SUFDR3ZFLFVBQVV1RSxRQUFRLEdBQUcrTTtBQUN6QjtBQUNBL00sU0FBU3JKLElBQUksR0FBRztBQUVoQixJQUFJcVc7QUFDSixNQUFNL00saUJBQWlCckI7SUFDbkJ6SSxZQUFZMkYsYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbkMsT0FBTyxDQUFDSSxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSixPQUFPLENBQUNLLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0FnVCxPQUFPL007QUFDTjtJQUNHeEUsVUFBVXdFLFFBQVEsR0FBRytNO0FBQ3pCO0FBQ0EvTSxTQUFTdEosSUFBSSxHQUFHO0FBRWhCLElBQUltQjtBQUNKLE1BQU1nSCxhQUFhRjtJQUNmekksWUFBWTJGLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ25DLE9BQU8sQ0FBQ0ksUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBbEMsS0FBS2dIO0FBQ0o7SUFDR3JELFVBQVVxRCxJQUFJLEdBQUdoSDtBQUNyQjtBQUNBZ0gsS0FBS25JLElBQUksR0FBRztBQUVaLE1BQU1zVztJQUNGOVcsWUFBWSxFQUFFd0YsT0FBT3RFLFlBQVksRUFBRXVFLFdBQVcsS0FBSyxFQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDekQsSUFBSSxDQUFDRCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxRQUFRLEdBQUdBO0lBQ3BCO0FBQ0o7QUFFQSxNQUFNc1IsZUFBZUQ7SUFDakI5VyxZQUFZLEVBQUV4QyxRQUFRLEVBQUUsRUFBRSxHQUFHbUksWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQzVDLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNuSSxLQUFLLEdBQUdBO0lBQ2pCO0FBQ0o7QUFFQSxNQUFNd1osaUJBQWlCRjtJQUNuQjlXLFlBQVksRUFBRXhDLFFBQVEsSUFBSXNaLEtBQUssRUFBRUcsUUFBUSxLQUFLLEVBQUUsR0FBR3RSLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNsRSxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbkksS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3laLEtBQUssR0FBR0E7SUFDakI7QUFDSjtBQUVBLE1BQU1DO0lBQ0ZsWCxZQUFZLEVBQUVtWCxPQUFPOVYsVUFBVSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDcEMsSUFBSSxDQUFDK1YsUUFBUSxHQUFHM1kscUJBQXFCeUQscUJBQXFCLENBQUNDLFlBQVksQ0FBQ2dWO0lBQzVFO0lBQ0EsSUFBSUEsT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDQyxRQUFRLENBQUNoVixLQUFLLEdBQUdoRCxNQUFNO0lBQ3ZDO0lBQ0EsSUFBSStYLEtBQUszWixLQUFLLEVBQUU7UUFDWixJQUFJLENBQUM0WixRQUFRLEdBQUczWSxxQkFBcUJ5RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDM0U7SUFDNUU7SUFDQTZFLFFBQVExQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFO1FBQzNDLE1BQU0wQyxZQUFZM0MsY0FBY0M7UUFDaEMsSUFBSSxDQUFDdVgsUUFBUSxHQUFHM1kscUJBQXFCeUQscUJBQXFCLENBQUNDLFlBQVksQ0FBQ3hDLGFBQWE2QyxRQUFRLENBQUM1QyxhQUFhMkM7UUFDM0csT0FBT0E7SUFDWDtJQUNBSSxNQUFNQyxRQUFRLEVBQUU7UUFDWixPQUFPLElBQUksQ0FBQ3dVLFFBQVEsQ0FBQ2hWLEtBQUssR0FBR2hELE1BQU07SUFDdkM7QUFDSjtBQUVBLFNBQVNpWSxjQUFjQyxJQUFJLEVBQUVDLFNBQVMsRUFBRUMsV0FBVztJQUMvQyxJQUFJQSx1QkFBdUJULFFBQVE7UUFDL0IsSUFBSyxJQUFJL0QsSUFBSSxHQUFHQSxJQUFJd0UsWUFBWWhhLEtBQUssQ0FBQzJCLE1BQU0sRUFBRTZULElBQUs7WUFDL0MsTUFBTWpMLFNBQVNzUCxjQUFjQyxNQUFNQyxXQUFXQyxZQUFZaGEsS0FBSyxDQUFDd1YsRUFBRTtZQUNsRSxJQUFJakwsT0FBTzBQLFFBQVEsRUFBRTtnQkFDakIsT0FBTztvQkFDSEEsVUFBVTtvQkFDVjFQLFFBQVF1UDtnQkFDWjtZQUNKO1FBQ0o7UUFDQTtZQUNJLE1BQU1JLFVBQVU7Z0JBQ1pELFVBQVU7Z0JBQ1YxUCxRQUFRO29CQUNKakksT0FBTztnQkFDWDtZQUNKO1lBQ0EsSUFBSTBYLFlBQVlHLGNBQWMsQ0FBQ25YLE9BQzNCa1gsUUFBUWxTLElBQUksR0FBR2dTLFlBQVloUyxJQUFJO1lBQ25DLE9BQU9rUztRQUNYO0lBQ0o7SUFDQSxJQUFJRix1QkFBdUJWLEtBQUs7UUFDNUIsSUFBSVUsWUFBWUcsY0FBYyxDQUFDblgsT0FDM0I4VyxJQUFJLENBQUNFLFlBQVloUyxJQUFJLENBQUMsR0FBRytSO1FBQzdCLE9BQU87WUFDSEUsVUFBVTtZQUNWMVAsUUFBUXVQO1FBQ1o7SUFDSjtJQUNBLElBQUksZ0JBQWlCamEsV0FBWSxPQUFPO1FBQ3BDLE9BQU87WUFDSG9hLFVBQVU7WUFDVjFQLFFBQVE7Z0JBQUVqSSxPQUFPO1lBQW9CO1FBQ3pDO0lBQ0o7SUFDQSxJQUFJLHFCQUFzQnpDLFdBQVksT0FBTztRQUN6QyxPQUFPO1lBQ0hvYSxVQUFVO1lBQ1YxUCxRQUFRO2dCQUFFakksT0FBTztZQUFtQjtRQUN4QztJQUNKO0lBQ0EsSUFBSSx1QkFBd0J6QyxXQUFZLE9BQU87UUFDM0MsT0FBTztZQUNIb2EsVUFBVTtZQUNWMVAsUUFBUTtnQkFBRWpJLE9BQU87WUFBcUI7UUFDMUM7SUFDSjtJQUNBLElBQUksWUFBYTBYLGdCQUFpQixPQUFPO1FBQ3JDLE9BQU87WUFDSEMsVUFBVTtZQUNWMVAsUUFBUTtnQkFBRWpJLE9BQU87WUFBcUI7UUFDMUM7SUFDSjtJQUNBLElBQUksWUFBYTBYLFlBQVloVSxPQUFPLEtBQU0sT0FBTztRQUM3QyxPQUFPO1lBQ0hpVSxVQUFVO1lBQ1YxUCxRQUFRO2dCQUFFakksT0FBTztZQUFxQjtRQUMxQztJQUNKO0lBQ0EsSUFBSSxVQUFXMFgsWUFBWWhVLE9BQU8sS0FBTSxPQUFPO1FBQzNDLE9BQU87WUFDSGlVLFVBQVU7WUFDVjFQLFFBQVE7Z0JBQUVqSSxPQUFPO1lBQXFCO1FBQzFDO0lBQ0o7SUFDQSxNQUFNOFgsWUFBWUosWUFBWWhVLE9BQU8sQ0FBQ2IsS0FBSyxDQUFDO0lBQzVDLElBQUlpVixVQUFVdlksVUFBVSxLQUFLLEdBQUc7UUFDNUIsT0FBTztZQUNIb1ksVUFBVTtZQUNWMVAsUUFBUTtnQkFBRWpJLE9BQU87WUFBMEM7UUFDL0Q7SUFDSjtJQUNBLE1BQU0rWCxnQkFBZ0JMLFlBQVloVSxPQUFPLENBQUNuQixPQUFPLENBQUN1VixXQUFXLEdBQUdBLFVBQVV2WSxVQUFVO0lBQ3BGLElBQUl3WSxrQkFBa0IsQ0FBQyxHQUFHO1FBQ3RCLE9BQU87WUFDSEosVUFBVTtZQUNWMVAsUUFBUTtnQkFBRWpJLE9BQU87WUFBMEM7UUFDL0Q7SUFDSjtJQUNBLElBQUkwWCxZQUFZaFUsT0FBTyxDQUFDbVUsY0FBYyxDQUFDL1csZUFBZSxPQUFPO1FBQ3pELE9BQU87WUFDSDZXLFVBQVU7WUFDVjFQLFFBQVE7Z0JBQUVqSSxPQUFPO1lBQXFCO1FBQzFDO0lBQ0o7SUFDQSxJQUFJMFgsWUFBWWhVLE9BQU8sQ0FBQ0ksUUFBUSxLQUFLMlQsVUFBVS9ULE9BQU8sQ0FBQ0ksUUFBUSxFQUFFO1FBQzdELE9BQU87WUFDSDZULFVBQVU7WUFDVjFQLFFBQVF1UDtRQUNaO0lBQ0o7SUFDQSxJQUFJRSxZQUFZaFUsT0FBTyxDQUFDbVUsY0FBYyxDQUFDOVcsZ0JBQWdCLE9BQU87UUFDMUQsT0FBTztZQUNINFcsVUFBVTtZQUNWMVAsUUFBUTtnQkFBRWpJLE9BQU87WUFBcUI7UUFDMUM7SUFDSjtJQUNBLElBQUkwWCxZQUFZaFUsT0FBTyxDQUFDSyxTQUFTLEtBQUswVCxVQUFVL1QsT0FBTyxDQUFDSyxTQUFTLEVBQUU7UUFDL0QsT0FBTztZQUNINFQsVUFBVTtZQUNWMVAsUUFBUXVQO1FBQ1o7SUFDSjtJQUNBLElBQUlFLFlBQVloVSxPQUFPLENBQUNtVSxjQUFjLENBQUM3VyxvQkFBb0IsT0FBTztRQUM5RCxPQUFPO1lBQ0gyVyxVQUFVO1lBQ1YxUCxRQUFRO2dCQUFFakksT0FBTztZQUFxQjtRQUMxQztJQUNKO0lBQ0EsSUFBSTBYLFlBQVloVSxPQUFPLENBQUNNLGFBQWEsS0FBS3lULFVBQVUvVCxPQUFPLENBQUNNLGFBQWEsRUFBRTtRQUN2RSxPQUFPO1lBQ0gyVCxVQUFVO1lBQ1YxUCxRQUFRdVA7UUFDWjtJQUNKO0lBQ0EsSUFBSSxDQUFFNVcsQ0FBQUEsZUFBZThXLFlBQVloVSxPQUFPLEdBQUc7UUFDdkMsT0FBTztZQUNIaVUsVUFBVTtZQUNWMVAsUUFBUTtnQkFBRWpJLE9BQU87WUFBcUI7UUFDMUM7SUFDSjtJQUNBLElBQUkwWCxZQUFZaFUsT0FBTyxDQUFDekIsU0FBUyxLQUFLd1YsVUFBVS9ULE9BQU8sQ0FBQ3pCLFNBQVMsRUFBRTtRQUMvRCxPQUFPO1lBQ0gwVixVQUFVO1lBQ1YxUCxRQUFRdVA7UUFDWjtJQUNKO0lBQ0EsSUFBSUUsWUFBWWhVLE9BQU8sQ0FBQ3pCLFNBQVMsRUFBRTtRQUMvQixJQUFJLGtCQUFtQnlWLFlBQVloVSxPQUFPLEtBQU0sT0FBTztZQUNuRCxPQUFPO2dCQUNIaVUsVUFBVTtnQkFDVjFQLFFBQVE7b0JBQUVqSSxPQUFPO2dCQUFxQjtZQUMxQztRQUNKO1FBQ0EsTUFBTWdZLGFBQWFOLFlBQVloVSxPQUFPLENBQUN4QixZQUFZO1FBQ25ELE1BQU1vTSxXQUFXbUosVUFBVS9ULE9BQU8sQ0FBQ3hCLFlBQVk7UUFDL0MsSUFBSThWLFdBQVczWSxNQUFNLEtBQUtpUCxTQUFTalAsTUFBTSxFQUFFO1lBQ3ZDLE9BQU87Z0JBQ0hzWSxVQUFVO2dCQUNWMVAsUUFBUXVQO1lBQ1o7UUFDSjtRQUNBLElBQUssSUFBSXBZLElBQUksR0FBR0EsSUFBSTRZLFdBQVczWSxNQUFNLEVBQUVELElBQUs7WUFDeEMsSUFBSTRZLFVBQVUsQ0FBQzVZLEVBQUUsS0FBS2tQLFFBQVEsQ0FBQyxFQUFFLEVBQUU7Z0JBQy9CLE9BQU87b0JBQ0hxSixVQUFVO29CQUNWMVAsUUFBUXVQO2dCQUNaO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsSUFBSUUsWUFBWWhTLElBQUksRUFBRTtRQUNsQmdTLFlBQVloUyxJQUFJLEdBQUdnUyxZQUFZaFMsSUFBSSxDQUFDcUosT0FBTyxDQUFDLGNBQWMzTjtRQUMxRCxJQUFJc1csWUFBWWhTLElBQUksRUFDaEI4UixJQUFJLENBQUNFLFlBQVloUyxJQUFJLENBQUMsR0FBRytSO0lBQ2pDO0lBQ0EsSUFBSUMsdUJBQXVCbFMsVUFBVXVCLFdBQVcsRUFBRTtRQUM5QyxJQUFJa1IsWUFBWTtRQUNoQixJQUFJaFEsU0FBUztZQUNUMFAsVUFBVTtZQUNWMVAsUUFBUTtnQkFDSmpJLE9BQU87WUFDWDtRQUNKO1FBQ0EsSUFBSWtZLFlBQVlSLFlBQVkzUixVQUFVLENBQUNySSxLQUFLLENBQUMyQixNQUFNO1FBQ25ELElBQUk2WSxZQUFZLEdBQUc7WUFDZixJQUFJUixZQUFZM1IsVUFBVSxDQUFDckksS0FBSyxDQUFDLEVBQUUsWUFBWXdaLFVBQVU7Z0JBQ3JEZ0IsWUFBWVQsVUFBVTFSLFVBQVUsQ0FBQ3JJLEtBQUssQ0FBQzJCLE1BQU07WUFDakQ7UUFDSjtRQUNBLElBQUk2WSxjQUFjLEdBQUc7WUFDakIsT0FBTztnQkFDSFAsVUFBVTtnQkFDVjFQLFFBQVF1UDtZQUNaO1FBQ0o7UUFDQSxJQUFJLFVBQVd6UixVQUFVLENBQUNySSxLQUFLLENBQUMyQixNQUFNLEtBQUssS0FDdENxWSxZQUFZM1IsVUFBVSxDQUFDckksS0FBSyxDQUFDMkIsTUFBTSxLQUFLLEdBQUk7WUFDN0MsSUFBSThZLFlBQVk7WUFDaEIsSUFBSyxJQUFJL1ksSUFBSSxHQUFHQSxJQUFJc1ksWUFBWTNSLFVBQVUsQ0FBQ3JJLEtBQUssQ0FBQzJCLE1BQU0sRUFBRUQsSUFDckQrWSxZQUFZQSxhQUFjVCxDQUFBQSxZQUFZM1IsVUFBVSxDQUFDckksS0FBSyxDQUFDMEIsRUFBRSxDQUFDdUcsUUFBUSxJQUFJLEtBQUk7WUFDOUUsSUFBSXdTLFdBQVc7Z0JBQ1gsT0FBTztvQkFDSFIsVUFBVTtvQkFDVjFQLFFBQVF1UDtnQkFDWjtZQUNKO1lBQ0EsSUFBSUUsWUFBWWhTLElBQUksRUFBRTtnQkFDbEJnUyxZQUFZaFMsSUFBSSxHQUFHZ1MsWUFBWWhTLElBQUksQ0FBQ3FKLE9BQU8sQ0FBQyxjQUFjM047Z0JBQzFELElBQUlzVyxZQUFZaFMsSUFBSSxFQUNoQixPQUFPOFIsSUFBSSxDQUFDRSxZQUFZaFMsSUFBSSxDQUFDO1lBQ3JDO1lBQ0E4UixLQUFLeFgsS0FBSyxHQUFHO1lBQ2IsT0FBTztnQkFDSDJYLFVBQVU7Z0JBQ1YxUCxRQUFRdVA7WUFDWjtRQUNKO1FBQ0EsSUFBSyxJQUFJcFksSUFBSSxHQUFHQSxJQUFJOFksV0FBVzlZLElBQUs7WUFDaEMsSUFBSSxJQUFLNlksYUFBY1IsVUFBVTFSLFVBQVUsQ0FBQ3JJLEtBQUssQ0FBQzJCLE1BQU0sRUFBRTtnQkFDdEQsSUFBSXFZLFlBQVkzUixVQUFVLENBQUNySSxLQUFLLENBQUMwQixFQUFFLENBQUN1RyxRQUFRLEtBQUssT0FBTztvQkFDcEQsTUFBTWlTLFVBQVU7d0JBQ1pELFVBQVU7d0JBQ1YxUCxRQUFRdVA7b0JBQ1o7b0JBQ0FBLEtBQUt4WCxLQUFLLEdBQUc7b0JBQ2IsSUFBSTBYLFlBQVloUyxJQUFJLEVBQUU7d0JBQ2xCZ1MsWUFBWWhTLElBQUksR0FBR2dTLFlBQVloUyxJQUFJLENBQUNxSixPQUFPLENBQUMsY0FBYzNOO3dCQUMxRCxJQUFJc1csWUFBWWhTLElBQUksRUFBRTs0QkFDbEIsT0FBTzhSLElBQUksQ0FBQ0UsWUFBWWhTLElBQUksQ0FBQzs0QkFDN0JrUyxRQUFRbFMsSUFBSSxHQUFHZ1MsWUFBWWhTLElBQUk7d0JBQ25DO29CQUNKO29CQUNBLE9BQU9rUztnQkFDWDtZQUNKLE9BQ0s7Z0JBQ0QsSUFBSUYsWUFBWTNSLFVBQVUsQ0FBQ3JJLEtBQUssQ0FBQyxFQUFFLFlBQVl3WixVQUFVO29CQUNyRGpQLFNBQVNzUCxjQUFjQyxNQUFNQyxVQUFVMVIsVUFBVSxDQUFDckksS0FBSyxDQUFDMEIsRUFBRSxFQUFFc1ksWUFBWTNSLFVBQVUsQ0FBQ3JJLEtBQUssQ0FBQyxFQUFFLENBQUNBLEtBQUs7b0JBQ2pHLElBQUl1SyxPQUFPMFAsUUFBUSxLQUFLLE9BQU87d0JBQzNCLElBQUlELFlBQVkzUixVQUFVLENBQUNySSxLQUFLLENBQUMsRUFBRSxDQUFDaUksUUFBUSxFQUN4Q3NTOzZCQUNDOzRCQUNELElBQUlQLFlBQVloUyxJQUFJLEVBQUU7Z0NBQ2xCZ1MsWUFBWWhTLElBQUksR0FBR2dTLFlBQVloUyxJQUFJLENBQUNxSixPQUFPLENBQUMsY0FBYzNOO2dDQUMxRCxJQUFJc1csWUFBWWhTLElBQUksRUFDaEIsT0FBTzhSLElBQUksQ0FBQ0UsWUFBWWhTLElBQUksQ0FBQzs0QkFDckM7NEJBQ0EsT0FBT3VDO3dCQUNYO29CQUNKO29CQUNBLElBQUksUUFBU3lQLFlBQVkzUixVQUFVLENBQUNySSxLQUFLLENBQUMsRUFBRSxJQUFNZ2EsWUFBWTNSLFVBQVUsQ0FBQ3JJLEtBQUssQ0FBQyxFQUFFLENBQUNnSSxJQUFJLENBQUNyRyxNQUFNLEdBQUcsR0FBSTt3QkFDaEcsSUFBSStZLFlBQVksQ0FBQzt3QkFDakIsSUFBSSxTQUFVVixZQUFZM1IsVUFBVSxDQUFDckksS0FBSyxDQUFDLEVBQUUsSUFBTWdhLFlBQVkzUixVQUFVLENBQUNySSxLQUFLLENBQUMsRUFBRSxDQUFDeVosS0FBSyxFQUNwRmlCLFlBQVlYOzZCQUVaVyxZQUFZWjt3QkFDaEIsSUFBSSxPQUFPWSxTQUFTLENBQUNWLFlBQVkzUixVQUFVLENBQUNySSxLQUFLLENBQUMsRUFBRSxDQUFDZ0ksSUFBSSxDQUFDLEtBQUssYUFDM0QwUyxTQUFTLENBQUNWLFlBQVkzUixVQUFVLENBQUNySSxLQUFLLENBQUMsRUFBRSxDQUFDZ0ksSUFBSSxDQUFDLEdBQUcsRUFBRTt3QkFDeEQwUyxTQUFTLENBQUNWLFlBQVkzUixVQUFVLENBQUNySSxLQUFLLENBQUMsRUFBRSxDQUFDZ0ksSUFBSSxDQUFDLENBQUNwRixJQUFJLENBQUNtWCxVQUFVMVIsVUFBVSxDQUFDckksS0FBSyxDQUFDMEIsRUFBRTtvQkFDdEY7Z0JBQ0osT0FDSztvQkFDRDZJLFNBQVNzUCxjQUFjQyxNQUFNQyxVQUFVMVIsVUFBVSxDQUFDckksS0FBSyxDQUFDMEIsSUFBSTZZLFVBQVUsRUFBRVAsWUFBWTNSLFVBQVUsQ0FBQ3JJLEtBQUssQ0FBQzBCLEVBQUU7b0JBQ3ZHLElBQUk2SSxPQUFPMFAsUUFBUSxLQUFLLE9BQU87d0JBQzNCLElBQUlELFlBQVkzUixVQUFVLENBQUNySSxLQUFLLENBQUMwQixFQUFFLENBQUN1RyxRQUFRLEVBQ3hDc1M7NkJBQ0M7NEJBQ0QsSUFBSVAsWUFBWWhTLElBQUksRUFBRTtnQ0FDbEJnUyxZQUFZaFMsSUFBSSxHQUFHZ1MsWUFBWWhTLElBQUksQ0FBQ3FKLE9BQU8sQ0FBQyxjQUFjM047Z0NBQzFELElBQUlzVyxZQUFZaFMsSUFBSSxFQUNoQixPQUFPOFIsSUFBSSxDQUFDRSxZQUFZaFMsSUFBSSxDQUFDOzRCQUNyQzs0QkFDQSxPQUFPdUM7d0JBQ1g7b0JBQ0o7Z0JBQ0o7WUFDSjtRQUNKO1FBQ0EsSUFBSUEsT0FBTzBQLFFBQVEsS0FBSyxPQUFPO1lBQzNCLE1BQU1DLFVBQVU7Z0JBQ1pELFVBQVU7Z0JBQ1YxUCxRQUFRdVA7WUFDWjtZQUNBLElBQUlFLFlBQVloUyxJQUFJLEVBQUU7Z0JBQ2xCZ1MsWUFBWWhTLElBQUksR0FBR2dTLFlBQVloUyxJQUFJLENBQUNxSixPQUFPLENBQUMsY0FBYzNOO2dCQUMxRCxJQUFJc1csWUFBWWhTLElBQUksRUFBRTtvQkFDbEIsT0FBTzhSLElBQUksQ0FBQ0UsWUFBWWhTLElBQUksQ0FBQztvQkFDN0JrUyxRQUFRbFMsSUFBSSxHQUFHZ1MsWUFBWWhTLElBQUk7Z0JBQ25DO1lBQ0o7WUFDQSxPQUFPa1M7UUFDWDtRQUNBLE9BQU87WUFDSEQsVUFBVTtZQUNWMVAsUUFBUXVQO1FBQ1o7SUFDSjtJQUNBLElBQUlFLFlBQVk5UixlQUFlLElBQzFCakYsa0JBQWtCOFcsVUFBVTFSLFVBQVUsRUFBRztRQUMxQyxNQUFNc1MsT0FBT3hRLGFBQWE0UCxVQUFVMVIsVUFBVSxDQUFDN0QsWUFBWTtRQUMzRCxJQUFJbVcsS0FBS3JRLE1BQU0sS0FBSyxDQUFDLEdBQUc7WUFDcEIsTUFBTTRQLFVBQVU7Z0JBQ1pELFVBQVU7Z0JBQ1YxUCxRQUFRb1EsS0FBS3BRLE1BQU07WUFDdkI7WUFDQSxJQUFJeVAsWUFBWWhTLElBQUksRUFBRTtnQkFDbEJnUyxZQUFZaFMsSUFBSSxHQUFHZ1MsWUFBWWhTLElBQUksQ0FBQ3FKLE9BQU8sQ0FBQyxjQUFjM047Z0JBQzFELElBQUlzVyxZQUFZaFMsSUFBSSxFQUFFO29CQUNsQixPQUFPOFIsSUFBSSxDQUFDRSxZQUFZaFMsSUFBSSxDQUFDO29CQUM3QmtTLFFBQVFsUyxJQUFJLEdBQUdnUyxZQUFZaFMsSUFBSTtnQkFDbkM7WUFDSjtZQUNBLE9BQU9rUztRQUNYO1FBQ0EsT0FBT0wsY0FBY0MsTUFBTWEsS0FBS3BRLE1BQU0sRUFBRXlQLFlBQVk5UixlQUFlO0lBQ3ZFO0lBQ0EsT0FBTztRQUNIK1IsVUFBVTtRQUNWMVAsUUFBUXVQO0lBQ1o7QUFDSjtBQUNBLFNBQVNjLGFBQWF6WSxXQUFXLEVBQUU2WCxXQUFXO0lBQzFDLElBQUksdUJBQXdCbmEsV0FBWSxPQUFPO1FBQzNDLE9BQU87WUFDSG9hLFVBQVU7WUFDVjFQLFFBQVE7Z0JBQUVqSSxPQUFPO1lBQTBCO1FBQy9DO0lBQ0o7SUFDQSxNQUFNcVksT0FBT3hRLGFBQWFsSixxQkFBcUJ5RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDeEM7SUFDbEYsSUFBSXdZLEtBQUtyUSxNQUFNLEtBQUssQ0FBQyxHQUFHO1FBQ3BCLE9BQU87WUFDSDJQLFVBQVU7WUFDVjFQLFFBQVFvUSxLQUFLcFEsTUFBTTtRQUN2QjtJQUNKO0lBQ0EsT0FBT3NQLGNBQWNjLEtBQUtwUSxNQUFNLEVBQUVvUSxLQUFLcFEsTUFBTSxFQUFFeVA7QUFDbkQ7QUFFQWphLFdBQVcsR0FBR3VaO0FBQ2R2WixpQkFBaUIsR0FBR2dJO0FBQ3BCaEksdUJBQXVCLEdBQUd1SjtBQUMxQnZKLGlCQUFpQixHQUFHNks7QUFDcEI3SyxpQkFBaUIsR0FBR21NO0FBQ3BCbk0sZUFBZSxHQUFHMks7QUFDbEIzSyx1QkFBdUIsR0FBR2tNO0FBQzFCbE0sY0FBYyxHQUFHd1o7QUFDakJ4WixtQkFBbUIsR0FBR3NKO0FBQ3RCdEosWUFBWSxHQUFHb007QUFDZnBNLGdCQUFnQixHQUFHc007QUFDbkJ0TSxnQkFBZ0IsR0FBR3VNO0FBQ25Cdk0sb0JBQW9CLEdBQUcwSztBQUN2QjFLLGtCQUFrQixHQUFHaUw7QUFDckJqTCxxQkFBcUIsR0FBR2dNO0FBQ3hCaE0sdUJBQXVCLEdBQUc2TDtBQUMxQjdMLHFCQUFxQixHQUFHOEw7QUFDeEI5TCxnQkFBZ0IsR0FBR2tFO0FBQ25CbEUsaUJBQWlCLEdBQUcyTDtBQUNwQjNMLGVBQWUsR0FBRzRLO0FBQ2xCNUssWUFBWSxHQUFHK0s7QUFDZi9LLHFCQUFxQixHQUFHdUw7QUFDeEJ2TCx3QkFBd0IsR0FBR2dMO0FBQzNCaEwsbUJBQW1CLEdBQUc4SztBQUN0QjlLLGlCQUFpQixHQUFHK0o7QUFDcEIvSix1QkFBdUIsR0FBR3dMO0FBQzFCeEwsZUFBZSxHQUFHMlo7QUFDbEIzWixnQ0FBZ0MsR0FBR21MO0FBQ25DbkwsZ0JBQWdCLEdBQUd5WjtBQUNuQnpaLGdCQUFnQixHQUFHcUw7QUFDbkJyTCxXQUFXLEdBQUdzTDtBQUNkdEwsWUFBWSxHQUFHb0w7QUFDZnBMLHFCQUFxQixHQUFHeUw7QUFDeEJ6TCxpQkFBaUIsR0FBR3FNO0FBQ3BCck0sZUFBZSxHQUFHNEw7QUFDbEI1TCx1QkFBdUIsR0FBR2lNO0FBQzFCak0sa0JBQWtCLEdBQUdrTDtBQUNyQmxMLGtCQUFrQixHQUFHNkY7QUFDckI3RixzQkFBc0IsR0FBRzBMO0FBQ3pCMUwsa0JBQWtCLEdBQUd3QztBQUNyQnhDLHFCQUFxQixHQUFHK0w7QUFDeEIvTCxxQkFBcUIsR0FBRzhaO0FBQ3hCOVosZUFBZSxHQUFHOEU7QUFDbEI5RSxvQkFBb0IsR0FBRzZhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXl0YXNrcy8uL25vZGVfbW9kdWxlcy9hc24xanMvYnVpbGQvaW5kZXguanM/Y2E4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgR01PIEdsb2JhbFNpZ25cbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDIyLCBQZWN1bGlhciBWZW50dXJlc1xuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFxuICogQXV0aG9yIDIwMTQtMjAxOSwgWXVyeSBTdHJvemhldnNreVxuICogXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICogXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIFxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yXG4gKiAgIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiBcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICogXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICogQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gKiAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gKiBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbiAqIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBwdnRzdXRpbHMgPSByZXF1aXJlKCdwdnRzdXRpbHMnKTtcbnZhciBwdnV0aWxzID0gcmVxdWlyZSgncHZ1dGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgcHZ0c3V0aWxzX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UocHZ0c3V0aWxzKTtcbnZhciBwdnV0aWxzX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UocHZ1dGlscyk7XG5cbmZ1bmN0aW9uIGFzc2VydEJpZ0ludCgpIHtcclxuICAgIGlmICh0eXBlb2YgQmlnSW50ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmlnSW50IGlzIG5vdCBkZWZpbmVkLiBZb3VyIGVudmlyb25tZW50IGRvZXNuJ3QgaW1wbGVtZW50IEJpZ0ludC5cIik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29uY2F0KGJ1ZmZlcnMpIHtcclxuICAgIGxldCBvdXRwdXRMZW5ndGggPSAwO1xyXG4gICAgbGV0IHByZXZMZW5ndGggPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1tpXTtcclxuICAgICAgICBvdXRwdXRMZW5ndGggKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkob3V0cHV0TGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbaV07XHJcbiAgICAgICAgcmV0Vmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSwgcHJldkxlbmd0aCk7XHJcbiAgICAgICAgcHJldkxlbmd0aCArPSBidWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXRWaWV3LmJ1ZmZlcjtcclxufVxyXG5mdW5jdGlvbiBjaGVja0J1ZmZlclBhcmFtcyhiYXNlQmxvY2ssIGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcclxuICAgIGlmICghKGlucHV0QnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcclxuICAgICAgICBiYXNlQmxvY2suZXJyb3IgPSBcIldyb25nIHBhcmFtZXRlcjogaW5wdXRCdWZmZXIgbXVzdCBiZSAnVWludDhBcnJheSdcIjtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlucHV0QnVmZmVyLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICBiYXNlQmxvY2suZXJyb3IgPSBcIldyb25nIHBhcmFtZXRlcjogaW5wdXRCdWZmZXIgaGFzIHplcm8gbGVuZ3RoXCI7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlucHV0T2Zmc2V0IDwgMCkge1xyXG4gICAgICAgIGJhc2VCbG9jay5lcnJvciA9IFwiV3JvbmcgcGFyYW1ldGVyOiBpbnB1dE9mZnNldCBsZXNzIHRoYW4gemVyb1wiO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChpbnB1dExlbmd0aCA8IDApIHtcclxuICAgICAgICBiYXNlQmxvY2suZXJyb3IgPSBcIldyb25nIHBhcmFtZXRlcjogaW5wdXRMZW5ndGggbGVzcyB0aGFuIHplcm9cIjtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoKGlucHV0QnVmZmVyLmJ5dGVMZW5ndGggLSBpbnB1dE9mZnNldCAtIGlucHV0TGVuZ3RoKSA8IDApIHtcclxuICAgICAgICBiYXNlQmxvY2suZXJyb3IgPSBcIkVuZCBvZiBpbnB1dCByZWFjaGVkIGJlZm9yZSBtZXNzYWdlIHdhcyBmdWxseSBkZWNvZGVkIChpbmNvbnNpc3RlbnQgb2Zmc2V0IGFuZCBsZW5ndGggdmFsdWVzKVwiO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cbmNsYXNzIFZpZXdXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgd3JpdGUoYnVmKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKGJ1Zik7XHJcbiAgICB9XHJcbiAgICBmaW5hbCgpIHtcclxuICAgICAgICByZXR1cm4gY29uY2F0KHRoaXMuaXRlbXMpO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHBvd2VyczIgPSBbbmV3IFVpbnQ4QXJyYXkoWzFdKV07XHJcbmNvbnN0IGRpZ2l0c1N0cmluZyA9IFwiMDEyMzQ1Njc4OVwiO1xyXG5jb25zdCBOQU1FID0gXCJuYW1lXCI7XHJcbmNvbnN0IFZBTFVFX0hFWF9WSUVXID0gXCJ2YWx1ZUhleFZpZXdcIjtcclxuY29uc3QgSVNfSEVYX09OTFkgPSBcImlzSGV4T25seVwiO1xyXG5jb25zdCBJRF9CTE9DSyA9IFwiaWRCbG9ja1wiO1xyXG5jb25zdCBUQUdfQ0xBU1MgPSBcInRhZ0NsYXNzXCI7XHJcbmNvbnN0IFRBR19OVU1CRVIgPSBcInRhZ051bWJlclwiO1xyXG5jb25zdCBJU19DT05TVFJVQ1RFRCA9IFwiaXNDb25zdHJ1Y3RlZFwiO1xyXG5jb25zdCBGUk9NX0JFUiA9IFwiZnJvbUJFUlwiO1xyXG5jb25zdCBUT19CRVIgPSBcInRvQkVSXCI7XHJcbmNvbnN0IExPQ0FMID0gXCJsb2NhbFwiO1xyXG5jb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xyXG5jb25zdCBFTVBUWV9CVUZGRVIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XHJcbmNvbnN0IEVNUFRZX1ZJRVcgPSBuZXcgVWludDhBcnJheSgwKTtcclxuY29uc3QgRU5EX09GX0NPTlRFTlRfTkFNRSA9IFwiRW5kT2ZDb250ZW50XCI7XHJcbmNvbnN0IE9DVEVUX1NUUklOR19OQU1FID0gXCJPQ1RFVCBTVFJJTkdcIjtcclxuY29uc3QgQklUX1NUUklOR19OQU1FID0gXCJCSVQgU1RSSU5HXCI7XG5cbmZ1bmN0aW9uIEhleEJsb2NrKEJhc2VDbGFzcykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIF9hID0gY2xhc3MgU29tZSBleHRlbmRzIEJhc2VDbGFzcyB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYXJnc1swXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gKF9hID0gcGFyYW1zLmlzSGV4T25seSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IHBhcmFtcy52YWx1ZUhleCA/IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkocGFyYW1zLnZhbHVlSGV4KSA6IEVNUFRZX1ZJRVc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHZhbHVlSGV4KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVIZXhWaWV3LnNsaWNlKCkuYnVmZmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldCB2YWx1ZUhleCh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSBuZXcgVWludDhBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gaW5wdXRCdWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KGlucHV0QnVmZmVyKSA6IGlucHV0QnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja0J1ZmZlclBhcmFtcyh0aGlzLCB2aWV3LCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kTGVuZ3RoID0gaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gdmlldy5zdWJhcnJheShpbnB1dE9mZnNldCwgZW5kTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiWmVybyBidWZmZXIgbGVuZ3RoXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dE9mZnNldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSBpbnB1dExlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbmRMZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdG9CRVIoc2l6ZU9ubHkgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGV4T25seSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIkZsYWcgJ2lzSGV4T25seScgaXMgbm90IHNldCwgYWJvcnRcIjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNpemVPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcih0aGlzLnZhbHVlSGV4Vmlldy5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aCA9PT0gdGhpcy52YWx1ZUhleFZpZXcuYnVmZmVyLmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnZhbHVlSGV4Vmlldy5idWZmZXJcclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMudmFsdWVIZXhWaWV3LnNsaWNlKCkuYnVmZmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNIZXhPbmx5OiB0aGlzLmlzSGV4T25seSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhleDogcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0hleCh0aGlzLnZhbHVlSGV4VmlldyksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYS5OQU1FID0gXCJoZXhCbG9ja1wiLFxyXG4gICAgICAgIF9hO1xyXG59XG5cbmNsYXNzIExvY2FsQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgYmxvY2tMZW5ndGggPSAwLCBlcnJvciA9IEVNUFRZX1NUUklORywgd2FybmluZ3MgPSBbXSwgdmFsdWVCZWZvcmVEZWNvZGUgPSBFTVBUWV9WSUVXLCB9ID0ge30pIHtcclxuICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoID0gYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcclxuICAgICAgICB0aGlzLnZhbHVlQmVmb3JlRGVjb2RlVmlldyA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkodmFsdWVCZWZvcmVEZWNvZGUpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGJsb2NrTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5OQU1FO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlQmVmb3JlRGVjb2RlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlQmVmb3JlRGVjb2RlVmlldy5zbGljZSgpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZUJlZm9yZURlY29kZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWVCZWZvcmVEZWNvZGVWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGJsb2NrTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5OQU1FLFxyXG4gICAgICAgICAgICBibG9ja0xlbmd0aDogdGhpcy5ibG9ja0xlbmd0aCxcclxuICAgICAgICAgICAgZXJyb3I6IHRoaXMuZXJyb3IsXHJcbiAgICAgICAgICAgIHdhcm5pbmdzOiB0aGlzLndhcm5pbmdzLFxyXG4gICAgICAgICAgICB2YWx1ZUJlZm9yZURlY29kZTogcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0hleCh0aGlzLnZhbHVlQmVmb3JlRGVjb2RlVmlldyksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5Mb2NhbEJhc2VCbG9jay5OQU1FID0gXCJiYXNlQmxvY2tcIjtcblxuY2xhc3MgVmFsdWVCbG9jayBleHRlbmRzIExvY2FsQmFzZUJsb2NrIHtcclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIlVzZXIgbmVlZCB0byBtYWtlIGEgc3BlY2lmaWMgZnVuY3Rpb24gaW4gYSBjbGFzcyB3aGljaCBleHRlbmRzICdWYWx1ZUJsb2NrJ1wiKTtcclxuICAgIH1cclxuICAgIHRvQkVSKHNpemVPbmx5LCB3cml0ZXIpIHtcclxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJVc2VyIG5lZWQgdG8gbWFrZSBhIHNwZWNpZmljIGZ1bmN0aW9uIGluIGEgY2xhc3Mgd2hpY2ggZXh0ZW5kcyAnVmFsdWVCbG9jaydcIik7XHJcbiAgICB9XHJcbn1cclxuVmFsdWVCbG9jay5OQU1FID0gXCJ2YWx1ZUJsb2NrXCI7XG5cbmNsYXNzIExvY2FsSWRlbnRpZmljYXRpb25CbG9jayBleHRlbmRzIEhleEJsb2NrKExvY2FsQmFzZUJsb2NrKSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IGlkQmxvY2sgPSB7fSwgfSA9IHt9KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgaWYgKGlkQmxvY2spIHtcclxuICAgICAgICAgICAgdGhpcy5pc0hleE9ubHkgPSAoX2EgPSBpZEJsb2NrLmlzSGV4T25seSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gaWRCbG9jay52YWx1ZUhleCA/IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaWRCbG9jay52YWx1ZUhleCkgOiBFTVBUWV9WSUVXO1xyXG4gICAgICAgICAgICB0aGlzLnRhZ0NsYXNzID0gKF9iID0gaWRCbG9jay50YWdDbGFzcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogLTE7XHJcbiAgICAgICAgICAgIHRoaXMudGFnTnVtYmVyID0gKF9jID0gaWRCbG9jay50YWdOdW1iZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IC0xO1xyXG4gICAgICAgICAgICB0aGlzLmlzQ29uc3RydWN0ZWQgPSAoX2QgPSBpZEJsb2NrLmlzQ29uc3RydWN0ZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50YWdDbGFzcyA9IC0xO1xyXG4gICAgICAgICAgICB0aGlzLnRhZ051bWJlciA9IC0xO1xyXG4gICAgICAgICAgICB0aGlzLmlzQ29uc3RydWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b0JFUihzaXplT25seSA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IGZpcnN0T2N0ZXQgPSAwO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy50YWdDbGFzcykge1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBmaXJzdE9jdGV0IHw9IDB4MDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgZmlyc3RPY3RldCB8PSAweDQwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIGZpcnN0T2N0ZXQgfD0gMHg4MDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBmaXJzdE9jdGV0IHw9IDB4QzA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIlVua25vd24gdGFnIGNsYXNzXCI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKVxyXG4gICAgICAgICAgICBmaXJzdE9jdGV0IHw9IDB4MjA7XHJcbiAgICAgICAgaWYgKHRoaXMudGFnTnVtYmVyIDwgMzEgJiYgIXRoaXMuaXNIZXhPbmx5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheSgxKTtcclxuICAgICAgICAgICAgaWYgKCFzaXplT25seSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG51bWJlciA9IHRoaXMudGFnTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgbnVtYmVyICY9IDB4MUY7XHJcbiAgICAgICAgICAgICAgICBmaXJzdE9jdGV0IHw9IG51bWJlcjtcclxuICAgICAgICAgICAgICAgIHJldFZpZXdbMF0gPSBmaXJzdE9jdGV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXRWaWV3LmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGV4T25seSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkQnVmID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxUb0Jhc2UodGhpcy50YWdOdW1iZXIsIDcpO1xyXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkVmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWRCdWYpO1xyXG4gICAgICAgICAgICBjb25zdCBzaXplID0gZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSArIDEpO1xyXG4gICAgICAgICAgICByZXRWaWV3WzBdID0gKGZpcnN0T2N0ZXQgfCAweDFGKTtcclxuICAgICAgICAgICAgaWYgKCFzaXplT25seSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAoc2l6ZSAtIDEpOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0Vmlld1tpICsgMV0gPSBlbmNvZGVkVmlld1tpXSB8IDB4ODA7XHJcbiAgICAgICAgICAgICAgICByZXRWaWV3W3NpemVdID0gZW5jb2RlZFZpZXdbc2l6ZSAtIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXRWaWV3LmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmV0VmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMudmFsdWVIZXhWaWV3LmJ5dGVMZW5ndGggKyAxKTtcclxuICAgICAgICByZXRWaWV3WzBdID0gKGZpcnN0T2N0ZXQgfCAweDFGKTtcclxuICAgICAgICBpZiAoIXNpemVPbmx5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1clZpZXcgPSB0aGlzLnZhbHVlSGV4VmlldztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAoY3VyVmlldy5sZW5ndGggLSAxKTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgcmV0Vmlld1tpICsgMV0gPSBjdXJWaWV3W2ldIHwgMHg4MDtcclxuICAgICAgICAgICAgcmV0Vmlld1t0aGlzLnZhbHVlSGV4Vmlldy5ieXRlTGVuZ3RoXSA9IGN1clZpZXdbY3VyVmlldy5sZW5ndGggLSAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldFZpZXcuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgaW5wdXRWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XHJcbiAgICAgICAgaWYgKCFjaGVja0J1ZmZlclBhcmFtcyh0aGlzLCBpbnB1dFZpZXcsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnRCdWZmZXIgPSBpbnB1dFZpZXcuc3ViYXJyYXkoaW5wdXRPZmZzZXQsIGlucHV0T2Zmc2V0ICsgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgIGlmIChpbnRCdWZmZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIlplcm8gYnVmZmVyIGxlbmd0aFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRhZ0NsYXNzTWFzayA9IGludEJ1ZmZlclswXSAmIDB4QzA7XHJcbiAgICAgICAgc3dpdGNoICh0YWdDbGFzc01hc2spIHtcclxuICAgICAgICAgICAgY2FzZSAweDAwOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50YWdDbGFzcyA9ICgxKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDB4NDA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ0NsYXNzID0gKDIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMHg4MDpcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnQ2xhc3MgPSAoMyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAweEMwOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50YWdDbGFzcyA9ICg0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiVW5rbm93biB0YWcgY2xhc3NcIjtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pc0NvbnN0cnVjdGVkID0gKGludEJ1ZmZlclswXSAmIDB4MjApID09PSAweDIwO1xyXG4gICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgdGFnTnVtYmVyTWFzayA9IGludEJ1ZmZlclswXSAmIDB4MUY7XHJcbiAgICAgICAgaWYgKHRhZ051bWJlck1hc2sgIT09IDB4MUYpIHtcclxuICAgICAgICAgICAgdGhpcy50YWdOdW1iZXIgPSAodGFnTnVtYmVyTWFzayk7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gMTtcclxuICAgICAgICAgICAgbGV0IGludFRhZ051bWJlckJ1ZmZlciA9IHRoaXMudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMjU1KTtcclxuICAgICAgICAgICAgbGV0IHRhZ051bWJlckJ1ZmZlck1heExlbmd0aCA9IDI1NTtcclxuICAgICAgICAgICAgd2hpbGUgKGludEJ1ZmZlcltjb3VudF0gJiAweDgwKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRUYWdOdW1iZXJCdWZmZXJbY291bnQgLSAxXSA9IGludEJ1ZmZlcltjb3VudF0gJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+PSBpbnRCdWZmZXIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRW5kIG9mIGlucHV0IHJlYWNoZWQgYmVmb3JlIG1lc3NhZ2Ugd2FzIGZ1bGx5IGRlY29kZWRcIjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IHRhZ051bWJlckJ1ZmZlck1heExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ051bWJlckJ1ZmZlck1heExlbmd0aCArPSAyNTU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcEJ1ZmZlclZpZXcgPSBuZXcgVWludDhBcnJheSh0YWdOdW1iZXJCdWZmZXJNYXhMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW50VGFnTnVtYmVyQnVmZmVyLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wQnVmZmVyVmlld1tpXSA9IGludFRhZ051bWJlckJ1ZmZlcltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpbnRUYWdOdW1iZXJCdWZmZXIgPSB0aGlzLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHRhZ051bWJlckJ1ZmZlck1heExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IChjb3VudCArIDEpO1xyXG4gICAgICAgICAgICBpbnRUYWdOdW1iZXJCdWZmZXJbY291bnQgLSAxXSA9IGludEJ1ZmZlcltjb3VudF0gJiAweDdGO1xyXG4gICAgICAgICAgICBjb25zdCB0ZW1wQnVmZmVyVmlldyA9IG5ldyBVaW50OEFycmF5KGNvdW50KTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgdGVtcEJ1ZmZlclZpZXdbaV0gPSBpbnRUYWdOdW1iZXJCdWZmZXJbaV07XHJcbiAgICAgICAgICAgIGludFRhZ051bWJlckJ1ZmZlciA9IHRoaXMudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpO1xyXG4gICAgICAgICAgICBpbnRUYWdOdW1iZXJCdWZmZXIuc2V0KHRlbXBCdWZmZXJWaWV3KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tMZW5ndGggPD0gOSlcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnTnVtYmVyID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxGcm9tQmFzZShpbnRUYWdOdW1iZXJCdWZmZXIsIDcpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChcIlRhZyB0b28gbG9uZywgcmVwcmVzZW50ZWQgYXMgaGV4LWNvZGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoKHRoaXMudGFnQ2xhc3MgPT09IDEpKSAmJlxyXG4gICAgICAgICAgICAodGhpcy5pc0NvbnN0cnVjdGVkKSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudGFnTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjM6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSAzMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMzI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMzOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAzNDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gXCJDb25zdHJ1Y3RlZCBlbmNvZGluZyB1c2VkIGZvciBwcmltaXRpdmUgdHlwZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGlucHV0T2Zmc2V0ICsgdGhpcy5ibG9ja0xlbmd0aCk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIHRhZ0NsYXNzOiB0aGlzLnRhZ0NsYXNzLFxyXG4gICAgICAgICAgICB0YWdOdW1iZXI6IHRoaXMudGFnTnVtYmVyLFxyXG4gICAgICAgICAgICBpc0NvbnN0cnVjdGVkOiB0aGlzLmlzQ29uc3RydWN0ZWQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5Mb2NhbElkZW50aWZpY2F0aW9uQmxvY2suTkFNRSA9IFwiaWRlbnRpZmljYXRpb25CbG9ja1wiO1xuXG5jbGFzcyBMb2NhbExlbmd0aEJsb2NrIGV4dGVuZHMgTG9jYWxCYXNlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IoeyBsZW5CbG9jayA9IHt9LCB9ID0ge30pIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaXNJbmRlZmluaXRlRm9ybSA9IChfYSA9IGxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubG9uZ0Zvcm1Vc2VkID0gKF9iID0gbGVuQmxvY2subG9uZ0Zvcm1Vc2VkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IChfYyA9IGxlbkJsb2NrLmxlbmd0aCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGlucHV0QnVmZmVyKTtcclxuICAgICAgICBpZiAoIWNoZWNrQnVmZmVyUGFyYW1zKHRoaXMsIHZpZXcsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnRCdWZmZXIgPSB2aWV3LnN1YmFycmF5KGlucHV0T2Zmc2V0LCBpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKTtcclxuICAgICAgICBpZiAoaW50QnVmZmVyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gXCJaZXJvIGJ1ZmZlciBsZW5ndGhcIjtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW50QnVmZmVyWzBdID09PSAweEZGKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIkxlbmd0aCBibG9jayAweEZGIGlzIHJlc2VydmVkIGJ5IHN0YW5kYXJkXCI7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pc0luZGVmaW5pdGVGb3JtID0gaW50QnVmZmVyWzBdID09PSAweDgwO1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW5kZWZpbml0ZUZvcm0pIHtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IDE7XHJcbiAgICAgICAgICAgIHJldHVybiAoaW5wdXRPZmZzZXQgKyB0aGlzLmJsb2NrTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb25nRm9ybVVzZWQgPSAhIShpbnRCdWZmZXJbMF0gJiAweDgwKTtcclxuICAgICAgICBpZiAodGhpcy5sb25nRm9ybVVzZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gKGludEJ1ZmZlclswXSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gKGlucHV0T2Zmc2V0ICsgdGhpcy5ibG9ja0xlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvdW50ID0gaW50QnVmZmVyWzBdICYgMHg3RjtcclxuICAgICAgICBpZiAoY291bnQgPiA4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIlRvbyBiaWcgaW50ZWdlclwiO1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoY291bnQgKyAxKSA+IGludEJ1ZmZlci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRW5kIG9mIGlucHV0IHJlYWNoZWQgYmVmb3JlIG1lc3NhZ2Ugd2FzIGZ1bGx5IGRlY29kZWRcIjtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW5PZmZzZXQgPSBpbnB1dE9mZnNldCArIDE7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoQnVmZmVyVmlldyA9IHZpZXcuc3ViYXJyYXkobGVuT2Zmc2V0LCBsZW5PZmZzZXQgKyBjb3VudCk7XHJcbiAgICAgICAgaWYgKGxlbmd0aEJ1ZmZlclZpZXdbY291bnQgLSAxXSA9PT0gMHgwMClcclxuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiTmVlZGxlc3NseSBsb25nIGVuY29kZWQgbGVuZ3RoXCIpO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxGcm9tQmFzZShsZW5ndGhCdWZmZXJWaWV3LCA4KTtcclxuICAgICAgICBpZiAodGhpcy5sb25nRm9ybVVzZWQgJiYgKHRoaXMubGVuZ3RoIDw9IDEyNykpXHJcbiAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChcIlVubmVjZXNzYXJ5IHVzYWdlIG9mIGxvbmcgbGVuZ3RoIGZvcm1cIik7XHJcbiAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IGNvdW50ICsgMTtcclxuICAgICAgICByZXR1cm4gKGlucHV0T2Zmc2V0ICsgdGhpcy5ibG9ja0xlbmd0aCk7XHJcbiAgICB9XHJcbiAgICB0b0JFUihzaXplT25seSA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IHJldEJ1ZjtcclxuICAgICAgICBsZXQgcmV0VmlldztcclxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAxMjcpXHJcbiAgICAgICAgICAgIHRoaXMubG9uZ0Zvcm1Vc2VkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5pc0luZGVmaW5pdGVGb3JtKSB7XHJcbiAgICAgICAgICAgIHJldEJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigxKTtcclxuICAgICAgICAgICAgaWYgKHNpemVPbmx5ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0VmlldyA9IG5ldyBVaW50OEFycmF5KHJldEJ1Zik7XHJcbiAgICAgICAgICAgICAgICByZXRWaWV3WzBdID0gMHg4MDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0QnVmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5sb25nRm9ybVVzZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgZW5jb2RlZEJ1ZiA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsVG9CYXNlKHRoaXMubGVuZ3RoLCA4KTtcclxuICAgICAgICAgICAgaWYgKGVuY29kZWRCdWYuYnl0ZUxlbmd0aCA+IDEyNykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiVG9vIGJpZyBsZW5ndGhcIjtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoRU1QVFlfQlVGRkVSKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXRCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoICsgMSk7XHJcbiAgICAgICAgICAgIGlmIChzaXplT25seSlcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXRCdWY7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEJ1Zik7XHJcbiAgICAgICAgICAgIHJldFZpZXcgPSBuZXcgVWludDhBcnJheShyZXRCdWYpO1xyXG4gICAgICAgICAgICByZXRWaWV3WzBdID0gZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoIHwgMHg4MDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVkQnVmLmJ5dGVMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHJldFZpZXdbaSArIDFdID0gZW5jb2RlZFZpZXdbaV07XHJcbiAgICAgICAgICAgIHJldHVybiByZXRCdWY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldEJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigxKTtcclxuICAgICAgICBpZiAoc2l6ZU9ubHkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldFZpZXcgPSBuZXcgVWludDhBcnJheShyZXRCdWYpO1xyXG4gICAgICAgICAgICByZXRWaWV3WzBdID0gdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXRCdWY7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIGlzSW5kZWZpbml0ZUZvcm06IHRoaXMuaXNJbmRlZmluaXRlRm9ybSxcclxuICAgICAgICAgICAgbG9uZ0Zvcm1Vc2VkOiB0aGlzLmxvbmdGb3JtVXNlZCxcclxuICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLmxlbmd0aCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbkxvY2FsTGVuZ3RoQmxvY2suTkFNRSA9IFwibGVuZ3RoQmxvY2tcIjtcblxuY29uc3QgdHlwZVN0b3JlID0ge307XG5cbmNsYXNzIEJhc2VCbG9jayBleHRlbmRzIExvY2FsQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgbmFtZSA9IEVNUFRZX1NUUklORywgb3B0aW9uYWwgPSBmYWxzZSwgcHJpbWl0aXZlU2NoZW1hLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSwgdmFsdWVCbG9ja1R5cGUpIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSBvcHRpb25hbDtcclxuICAgICAgICBpZiAocHJpbWl0aXZlU2NoZW1hKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJpbWl0aXZlU2NoZW1hID0gcHJpbWl0aXZlU2NoZW1hO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlkQmxvY2sgPSBuZXcgTG9jYWxJZGVudGlmaWNhdGlvbkJsb2NrKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMubGVuQmxvY2sgPSBuZXcgTG9jYWxMZW5ndGhCbG9jayhwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2sgPSB2YWx1ZUJsb2NrVHlwZSA/IG5ldyB2YWx1ZUJsb2NrVHlwZShwYXJhbWV0ZXJzKSA6IG5ldyBWYWx1ZUJsb2NrKHBhcmFtZXRlcnMpO1xyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0T2Zmc2V0ID0gdGhpcy52YWx1ZUJsb2NrLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCAodGhpcy5sZW5CbG9jay5pc0luZGVmaW5pdGVGb3JtKSA/IGlucHV0TGVuZ3RoIDogdGhpcy5sZW5CbG9jay5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB0aGlzLnZhbHVlQmxvY2suZXJyb3I7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pZEJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmlkQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxlbkJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmxlbkJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgICAgIGlmICghdGhpcy52YWx1ZUJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLnZhbHVlQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgIH1cclxuICAgIHRvQkVSKHNpemVPbmx5LCB3cml0ZXIpIHtcclxuICAgICAgICBjb25zdCBfd3JpdGVyID0gd3JpdGVyIHx8IG5ldyBWaWV3V3JpdGVyKCk7XHJcbiAgICAgICAgaWYgKCF3cml0ZXIpIHtcclxuICAgICAgICAgICAgcHJlcGFyZUluZGVmaW5pdGVGb3JtKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZEJsb2NrQnVmID0gdGhpcy5pZEJsb2NrLnRvQkVSKHNpemVPbmx5KTtcclxuICAgICAgICBfd3JpdGVyLndyaXRlKGlkQmxvY2tCdWYpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm0pIHtcclxuICAgICAgICAgICAgX3dyaXRlci53cml0ZShuZXcgVWludDhBcnJheShbMHg4MF0pLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVCbG9jay50b0JFUihzaXplT25seSwgX3dyaXRlcik7XHJcbiAgICAgICAgICAgIF93cml0ZXIud3JpdGUobmV3IEFycmF5QnVmZmVyKDIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlQmxvY2tCdWYgPSB0aGlzLnZhbHVlQmxvY2sudG9CRVIoc2l6ZU9ubHkpO1xyXG4gICAgICAgICAgICB0aGlzLmxlbkJsb2NrLmxlbmd0aCA9IHZhbHVlQmxvY2tCdWYuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgbGVuQmxvY2tCdWYgPSB0aGlzLmxlbkJsb2NrLnRvQkVSKHNpemVPbmx5KTtcclxuICAgICAgICAgICAgX3dyaXRlci53cml0ZShsZW5CbG9ja0J1Zik7XHJcbiAgICAgICAgICAgIF93cml0ZXIud3JpdGUodmFsdWVCbG9ja0J1Zik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfd3JpdGVyLmZpbmFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFTVBUWV9CVUZGRVI7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgaWRCbG9jazogdGhpcy5pZEJsb2NrLnRvSlNPTigpLFxyXG4gICAgICAgICAgICBsZW5CbG9jazogdGhpcy5sZW5CbG9jay50b0pTT04oKSxcclxuICAgICAgICAgICAgdmFsdWVCbG9jazogdGhpcy52YWx1ZUJsb2NrLnRvSlNPTigpLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0aGlzLm9wdGlvbmFsLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMucHJpbWl0aXZlU2NoZW1hKVxyXG4gICAgICAgICAgICBvYmplY3QucHJpbWl0aXZlU2NoZW1hID0gdGhpcy5wcmltaXRpdmVTY2hlbWEudG9KU09OKCk7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKGVuY29kaW5nID0gXCJhc2NpaVwiKSB7XHJcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSBcImFzY2lpXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25Bc2NpaUVuY29kaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwdnRzdXRpbHNfX25hbWVzcGFjZS5Db252ZXJ0LlRvSGV4KHRoaXMudG9CRVIoKSk7XHJcbiAgICB9XHJcbiAgICBvbkFzY2lpRW5jb2RpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IuTkFNRX0gOiAke3B2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuVG9IZXgodGhpcy52YWx1ZUJsb2NrLnZhbHVlQmVmb3JlRGVjb2RlVmlldyl9YDtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0aGlzUmF3ID0gdGhpcy50b0JFUigpO1xyXG4gICAgICAgIGNvbnN0IG90aGVyUmF3ID0gb3RoZXIudG9CRVIoKTtcclxuICAgICAgICByZXR1cm4gcHZ1dGlsc19fbmFtZXNwYWNlLmlzRXF1YWxCdWZmZXIodGhpc1Jhdywgb3RoZXJSYXcpO1xyXG4gICAgfVxyXG59XHJcbkJhc2VCbG9jay5OQU1FID0gXCJCYXNlQmxvY2tcIjtcclxuZnVuY3Rpb24gcHJlcGFyZUluZGVmaW5pdGVGb3JtKGJhc2VCbG9jaykge1xyXG4gICAgaWYgKGJhc2VCbG9jayBpbnN0YW5jZW9mIHR5cGVTdG9yZS5Db25zdHJ1Y3RlZCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYmFzZUJsb2NrLnZhbHVlQmxvY2sudmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHByZXBhcmVJbmRlZmluaXRlRm9ybSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGJhc2VCbG9jay5sZW5CbG9jay5pc0luZGVmaW5pdGVGb3JtID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAhIWJhc2VCbG9jay5sZW5CbG9jay5pc0luZGVmaW5pdGVGb3JtO1xyXG59XG5cbmNsYXNzIEJhc2VTdHJpbmdCbG9jayBleHRlbmRzIEJhc2VCbG9jayB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlID0gRU1QVFlfU1RSSU5HLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSwgc3RyaW5nVmFsdWVCbG9ja1R5cGUpIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzLCBzdHJpbmdWYWx1ZUJsb2NrVHlwZSk7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVCbG9jay52YWx1ZTtcclxuICAgIH1cclxuICAgIHNldFZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBmcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCByZXN1bHRPZmZzZXQgPSB0aGlzLnZhbHVlQmxvY2suZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsICh0aGlzLmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm0pID8gaW5wdXRMZW5ndGggOiB0aGlzLmxlbkJsb2NrLmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdE9mZnNldCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IHRoaXMudmFsdWVCbG9jay5lcnJvcjtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mcm9tQnVmZmVyKHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXcpO1xyXG4gICAgICAgIGlmICghdGhpcy5pZEJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmlkQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxlbkJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmxlbkJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgICAgIGlmICghdGhpcy52YWx1ZUJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLnZhbHVlQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgIH1cclxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcclxuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfSA6ICcke3RoaXMudmFsdWVCbG9jay52YWx1ZX0nYDtcclxuICAgIH1cclxufVxyXG5CYXNlU3RyaW5nQmxvY2suTkFNRSA9IFwiQmFzZVN0cmluZ0Jsb2NrXCI7XG5cbmNsYXNzIExvY2FsUHJpbWl0aXZlVmFsdWVCbG9jayBleHRlbmRzIEhleEJsb2NrKFZhbHVlQmxvY2spIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgaXNIZXhPbmx5ID0gdHJ1ZSwgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLmlzSGV4T25seSA9IGlzSGV4T25seTtcclxuICAgIH1cclxufVxyXG5Mb2NhbFByaW1pdGl2ZVZhbHVlQmxvY2suTkFNRSA9IFwiUHJpbWl0aXZlVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkdztcclxuY2xhc3MgUHJpbWl0aXZlIGV4dGVuZHMgQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMsIExvY2FsUHJpbWl0aXZlVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLmlzQ29uc3RydWN0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5fYSR3ID0gUHJpbWl0aXZlO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLlByaW1pdGl2ZSA9IF9hJHc7XHJcbn0pKCk7XHJcblByaW1pdGl2ZS5OQU1FID0gXCJQUklNSVRJVkVcIjtcblxuZnVuY3Rpb24gbG9jYWxDaGFuZ2VUeXBlKGlucHV0T2JqZWN0LCBuZXdUeXBlKSB7XHJcbiAgICBpZiAoaW5wdXRPYmplY3QgaW5zdGFuY2VvZiBuZXdUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0T2JqZWN0O1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3T2JqZWN0ID0gbmV3IG5ld1R5cGUoKTtcclxuICAgIG5ld09iamVjdC5pZEJsb2NrID0gaW5wdXRPYmplY3QuaWRCbG9jaztcclxuICAgIG5ld09iamVjdC5sZW5CbG9jayA9IGlucHV0T2JqZWN0LmxlbkJsb2NrO1xyXG4gICAgbmV3T2JqZWN0Lndhcm5pbmdzID0gaW5wdXRPYmplY3Qud2FybmluZ3M7XHJcbiAgICBuZXdPYmplY3QudmFsdWVCZWZvcmVEZWNvZGVWaWV3ID0gaW5wdXRPYmplY3QudmFsdWVCZWZvcmVEZWNvZGVWaWV3O1xyXG4gICAgcmV0dXJuIG5ld09iamVjdDtcclxufVxyXG5mdW5jdGlvbiBsb2NhbEZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0ID0gMCwgaW5wdXRMZW5ndGggPSBpbnB1dEJ1ZmZlci5sZW5ndGgpIHtcclxuICAgIGNvbnN0IGluY29taW5nT2Zmc2V0ID0gaW5wdXRPZmZzZXQ7XHJcbiAgICBsZXQgcmV0dXJuT2JqZWN0ID0gbmV3IEJhc2VCbG9jayh7fSwgVmFsdWVCbG9jayk7XHJcbiAgICBjb25zdCBiYXNlQmxvY2sgPSBuZXcgTG9jYWxCYXNlQmxvY2soKTtcclxuICAgIGlmICghY2hlY2tCdWZmZXJQYXJhbXMoYmFzZUJsb2NrLCBpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSkge1xyXG4gICAgICAgIHJldHVybk9iamVjdC5lcnJvciA9IGJhc2VCbG9jay5lcnJvcjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvZmZzZXQ6IC0xLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHJldHVybk9iamVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnRCdWZmZXIgPSBpbnB1dEJ1ZmZlci5zdWJhcnJheShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aCk7XHJcbiAgICBpZiAoIWludEJ1ZmZlci5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm5PYmplY3QuZXJyb3IgPSBcIlplcm8gYnVmZmVyIGxlbmd0aFwiO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9mZnNldDogLTEsXHJcbiAgICAgICAgICAgIHJlc3VsdDogcmV0dXJuT2JqZWN0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGxldCByZXN1bHRPZmZzZXQgPSByZXR1cm5PYmplY3QuaWRCbG9jay5mcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpO1xyXG4gICAgaWYgKHJldHVybk9iamVjdC5pZEJsb2NrLndhcm5pbmdzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybk9iamVjdC53YXJuaW5ncy5jb25jYXQocmV0dXJuT2JqZWN0LmlkQmxvY2sud2FybmluZ3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlc3VsdE9mZnNldCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm5PYmplY3QuZXJyb3IgPSByZXR1cm5PYmplY3QuaWRCbG9jay5lcnJvcjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvZmZzZXQ6IC0xLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHJldHVybk9iamVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpbnB1dE9mZnNldCA9IHJlc3VsdE9mZnNldDtcclxuICAgIGlucHV0TGVuZ3RoIC09IHJldHVybk9iamVjdC5pZEJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgcmVzdWx0T2Zmc2V0ID0gcmV0dXJuT2JqZWN0LmxlbkJsb2NrLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCk7XHJcbiAgICBpZiAocmV0dXJuT2JqZWN0LmxlbkJsb2NrLndhcm5pbmdzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybk9iamVjdC53YXJuaW5ncy5jb25jYXQocmV0dXJuT2JqZWN0LmxlbkJsb2NrLndhcm5pbmdzKTtcclxuICAgIH1cclxuICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuT2JqZWN0LmVycm9yID0gcmV0dXJuT2JqZWN0LmxlbkJsb2NrLmVycm9yO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9mZnNldDogLTEsXHJcbiAgICAgICAgICAgIHJlc3VsdDogcmV0dXJuT2JqZWN0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlucHV0T2Zmc2V0ID0gcmVzdWx0T2Zmc2V0O1xyXG4gICAgaW5wdXRMZW5ndGggLT0gcmV0dXJuT2JqZWN0LmxlbkJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgaWYgKCFyZXR1cm5PYmplY3QuaWRCbG9jay5pc0NvbnN0cnVjdGVkICYmXHJcbiAgICAgICAgcmV0dXJuT2JqZWN0LmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm0pIHtcclxuICAgICAgICByZXR1cm5PYmplY3QuZXJyb3IgPSBcIkluZGVmaW5pdGUgbGVuZ3RoIGZvcm0gdXNlZCBmb3IgcHJpbWl0aXZlIGVuY29kaW5nIGZvcm1cIjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvZmZzZXQ6IC0xLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHJldHVybk9iamVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBsZXQgbmV3QVNOMVR5cGUgPSBCYXNlQmxvY2s7XHJcbiAgICBzd2l0Y2ggKHJldHVybk9iamVjdC5pZEJsb2NrLnRhZ0NsYXNzKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICBpZiAoKHJldHVybk9iamVjdC5pZEJsb2NrLnRhZ051bWJlciA+PSAzNykgJiZcclxuICAgICAgICAgICAgICAgIChyZXR1cm5PYmplY3QuaWRCbG9jay5pc0hleE9ubHkgPT09IGZhbHNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuT2JqZWN0LmVycm9yID0gXCJVTklWRVJTQUwgMzcgYW5kIHVwcGVyIHRhZ3MgYXJlIHJlc2VydmVkIGJ5IEFTTi4xIHN0YW5kYXJkXCI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogLTEsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXR1cm5PYmplY3RcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoIChyZXR1cm5PYmplY3QuaWRCbG9jay50YWdOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHJldHVybk9iamVjdC5pZEJsb2NrLmlzQ29uc3RydWN0ZWQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZXR1cm5PYmplY3QubGVuQmxvY2subGVuZ3RoID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqZWN0LmVycm9yID0gXCJUeXBlIFtVTklWRVJTQUwgMF0gaXMgcmVzZXJ2ZWRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogLTEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJldHVybk9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5FbmRPZkNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuQm9vbGVhbjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5JbnRlZ2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkJpdFN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5PY3RldFN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5OdWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLk9iamVjdElkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkVudW1lcmF0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlV0ZjhTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlJlbGF0aXZlT2JqZWN0SWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuVElNRTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqZWN0LmVycm9yID0gXCJbVU5JVkVSU0FMIDE1XSBpcyByZXNlcnZlZCBieSBBU04uMSBzdGFuZGFyZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogLTEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmV0dXJuT2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTY6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuU2VxdWVuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE3OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlNldDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTg6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuTnVtZXJpY1N0cmluZztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTk6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuUHJpbnRhYmxlU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyMDpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5UZWxldGV4U3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyMTpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5WaWRlb3RleFN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjI6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuSUE1U3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyMzpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5VVENUaW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyNDpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5HZW5lcmFsaXplZFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI1OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkdyYXBoaWNTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI2OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlZpc2libGVTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI3OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkdlbmVyYWxTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI4OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlVuaXZlcnNhbFN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjk6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuQ2hhcmFjdGVyU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzMDpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5CbXBTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMxOlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkRBVEU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMyOlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlRpbWVPZkRheTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzM6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuRGF0ZVRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM0OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld09iamVjdCA9IHJldHVybk9iamVjdC5pZEJsb2NrLmlzQ29uc3RydWN0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgdHlwZVN0b3JlLkNvbnN0cnVjdGVkKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgdHlwZVN0b3JlLlByaW1pdGl2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld09iamVjdC5pZEJsb2NrID0gcmV0dXJuT2JqZWN0LmlkQmxvY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqZWN0LmxlbkJsb2NrID0gcmV0dXJuT2JqZWN0LmxlbkJsb2NrO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld09iamVjdC53YXJuaW5ncyA9IHJldHVybk9iamVjdC53YXJuaW5ncztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5PYmplY3QgPSBuZXdPYmplY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICBuZXdBU04xVHlwZSA9IHJldHVybk9iamVjdC5pZEJsb2NrLmlzQ29uc3RydWN0ZWRcclxuICAgICAgICAgICAgICAgID8gdHlwZVN0b3JlLkNvbnN0cnVjdGVkXHJcbiAgICAgICAgICAgICAgICA6IHR5cGVTdG9yZS5QcmltaXRpdmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuT2JqZWN0ID0gbG9jYWxDaGFuZ2VUeXBlKHJldHVybk9iamVjdCwgbmV3QVNOMVR5cGUpO1xyXG4gICAgcmVzdWx0T2Zmc2V0ID0gcmV0dXJuT2JqZWN0LmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCByZXR1cm5PYmplY3QubGVuQmxvY2suaXNJbmRlZmluaXRlRm9ybSA/IGlucHV0TGVuZ3RoIDogcmV0dXJuT2JqZWN0LmxlbkJsb2NrLmxlbmd0aCk7XHJcbiAgICByZXR1cm5PYmplY3QudmFsdWVCZWZvcmVEZWNvZGVWaWV3ID0gaW5wdXRCdWZmZXIuc3ViYXJyYXkoaW5jb21pbmdPZmZzZXQsIGluY29taW5nT2Zmc2V0ICsgcmV0dXJuT2JqZWN0LmJsb2NrTGVuZ3RoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgb2Zmc2V0OiByZXN1bHRPZmZzZXQsXHJcbiAgICAgICAgcmVzdWx0OiByZXR1cm5PYmplY3RcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZnJvbUJFUihpbnB1dEJ1ZmZlcikge1xyXG4gICAgaWYgKCFpbnB1dEJ1ZmZlci5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEJhc2VCbG9jayh7fSwgVmFsdWVCbG9jayk7XHJcbiAgICAgICAgcmVzdWx0LmVycm9yID0gXCJJbnB1dCBidWZmZXIgaGFzIHplcm8gbGVuZ3RoXCI7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb2Zmc2V0OiAtMSxcclxuICAgICAgICAgICAgcmVzdWx0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbEZyb21CRVIocHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcikuc2xpY2UoKSwgMCwgaW5wdXRCdWZmZXIuYnl0ZUxlbmd0aCk7XHJcbn1cblxuZnVuY3Rpb24gY2hlY2tMZW4oaW5kZWZpbml0ZUxlbmd0aCwgbGVuZ3RoKSB7XHJcbiAgICBpZiAoaW5kZWZpbml0ZUxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbmd0aDtcclxufVxyXG5jbGFzcyBMb2NhbENvbnN0cnVjdGVkVmFsdWVCbG9jayBleHRlbmRzIFZhbHVlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSA9IFtdLCBpc0luZGVmaW5pdGVGb3JtID0gZmFsc2UsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaXNJbmRlZmluaXRlRm9ybSA9IGlzSW5kZWZpbml0ZUZvcm07XHJcbiAgICB9XHJcbiAgICBmcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCB2aWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XHJcbiAgICAgICAgaWYgKCFjaGVja0J1ZmZlclBhcmFtcyh0aGlzLCB2aWV3LCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWx1ZUJlZm9yZURlY29kZVZpZXcgPSB2aWV3LnN1YmFycmF5KGlucHV0T2Zmc2V0LCBpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKTtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZUJlZm9yZURlY29kZVZpZXcubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChcIlplcm8gYnVmZmVyIGxlbmd0aFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0T2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY3VycmVudE9mZnNldCA9IGlucHV0T2Zmc2V0O1xyXG4gICAgICAgIHdoaWxlIChjaGVja0xlbih0aGlzLmlzSW5kZWZpbml0ZUZvcm0sIGlucHV0TGVuZ3RoKSA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgcmV0dXJuT2JqZWN0ID0gbG9jYWxGcm9tQkVSKHZpZXcsIGN1cnJlbnRPZmZzZXQsIGlucHV0TGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKHJldHVybk9iamVjdC5vZmZzZXQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gcmV0dXJuT2JqZWN0LnJlc3VsdC5lcnJvcjtcclxuICAgICAgICAgICAgICAgIHRoaXMud2FybmluZ3MuY29uY2F0KHJldHVybk9iamVjdC5yZXN1bHQud2FybmluZ3MpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRPZmZzZXQgPSByZXR1cm5PYmplY3Qub2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoICs9IHJldHVybk9iamVjdC5yZXN1bHQuYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgICAgIGlucHV0TGVuZ3RoIC09IHJldHVybk9iamVjdC5yZXN1bHQuYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUucHVzaChyZXR1cm5PYmplY3QucmVzdWx0KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbmRlZmluaXRlRm9ybSAmJiByZXR1cm5PYmplY3QucmVzdWx0LmNvbnN0cnVjdG9yLk5BTUUgPT09IEVORF9PRl9DT05URU5UX05BTUUpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzSW5kZWZpbml0ZUZvcm0pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVbdGhpcy52YWx1ZS5sZW5ndGggLSAxXS5jb25zdHJ1Y3Rvci5OQU1FID09PSBFTkRfT0ZfQ09OVEVOVF9OQU1FKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLnBvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiTm8gRW5kT2ZDb250ZW50IGJsb2NrIGVuY29kZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICB0b0JFUihzaXplT25seSwgd3JpdGVyKSB7XHJcbiAgICAgICAgY29uc3QgX3dyaXRlciA9IHdyaXRlciB8fCBuZXcgVmlld1dyaXRlcigpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldLnRvQkVSKHNpemVPbmx5LCBfd3JpdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF3cml0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF93cml0ZXIuZmluYWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBvYmplY3QgPSB7XHJcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxyXG4gICAgICAgICAgICBpc0luZGVmaW5pdGVGb3JtOiB0aGlzLmlzSW5kZWZpbml0ZUZvcm0sXHJcbiAgICAgICAgICAgIHZhbHVlOiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy52YWx1ZSkge1xyXG4gICAgICAgICAgICBvYmplY3QudmFsdWUucHVzaCh2YWx1ZS50b0pTT04oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICB9XHJcbn1cclxuTG9jYWxDb25zdHJ1Y3RlZFZhbHVlQmxvY2suTkFNRSA9IFwiQ29uc3RydWN0ZWRWYWx1ZUJsb2NrXCI7XG5cbnZhciBfYSR2O1xyXG5jbGFzcyBDb25zdHJ1Y3RlZCBleHRlbmRzIEJhc2VCbG9jayB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzLCBMb2NhbENvbnN0cnVjdGVkVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLmlzQ29uc3RydWN0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLmlzSW5kZWZpbml0ZUZvcm0gPSB0aGlzLmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm07XHJcbiAgICAgICAgY29uc3QgcmVzdWx0T2Zmc2V0ID0gdGhpcy52YWx1ZUJsb2NrLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCAodGhpcy5sZW5CbG9jay5pc0luZGVmaW5pdGVGb3JtKSA/IGlucHV0TGVuZ3RoIDogdGhpcy5sZW5CbG9jay5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB0aGlzLnZhbHVlQmxvY2suZXJyb3I7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pZEJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmlkQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxlbkJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmxlbkJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgICAgIGlmICghdGhpcy52YWx1ZUJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLnZhbHVlQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgIH1cclxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMudmFsdWVCbG9jay52YWx1ZSkge1xyXG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZS50b1N0cmluZyhcImFzY2lpXCIpLnNwbGl0KFwiXFxuXCIpLm1hcChvID0+IGAgICR7b31gKS5qb2luKFwiXFxuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmxvY2tOYW1lID0gdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID09PSAzXHJcbiAgICAgICAgICAgID8gYFske3RoaXMuaWRCbG9jay50YWdOdW1iZXJ9XWBcclxuICAgICAgICAgICAgOiB0aGlzLmNvbnN0cnVjdG9yLk5BTUU7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5sZW5ndGhcclxuICAgICAgICAgICAgPyBgJHtibG9ja05hbWV9IDpcXG4ke3ZhbHVlcy5qb2luKFwiXFxuXCIpfWBcclxuICAgICAgICAgICAgOiBgJHtibG9ja05hbWV9IDpgO1xyXG4gICAgfVxyXG59XHJcbl9hJHYgPSBDb25zdHJ1Y3RlZDtcclxuKCgpID0+IHtcclxuICAgIHR5cGVTdG9yZS5Db25zdHJ1Y3RlZCA9IF9hJHY7XHJcbn0pKCk7XHJcbkNvbnN0cnVjdGVkLk5BTUUgPSBcIkNPTlNUUlVDVEVEXCI7XG5cbmNsYXNzIExvY2FsRW5kT2ZDb250ZW50VmFsdWVCbG9jayBleHRlbmRzIFZhbHVlQmxvY2sge1xyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0T2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgdG9CRVIoc2l6ZU9ubHkpIHtcclxuICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgfVxyXG59XHJcbkxvY2FsRW5kT2ZDb250ZW50VmFsdWVCbG9jay5vdmVycmlkZSA9IFwiRW5kT2ZDb250ZW50VmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkdTtcclxuY2xhc3MgRW5kT2ZDb250ZW50IGV4dGVuZHMgQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMsIExvY2FsRW5kT2ZDb250ZW50VmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMDtcclxuICAgIH1cclxufVxyXG5fYSR1ID0gRW5kT2ZDb250ZW50O1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkVuZE9mQ29udGVudCA9IF9hJHU7XHJcbn0pKCk7XHJcbkVuZE9mQ29udGVudC5OQU1FID0gRU5EX09GX0NPTlRFTlRfTkFNRTtcblxudmFyIF9hJHQ7XHJcbmNsYXNzIE51bGwgZXh0ZW5kcyBCYXNlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycywgVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gNTtcclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlbkJsb2NrLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChcIk5vbi16ZXJvIGxlbmd0aCBvZiB2YWx1ZSBibG9jayBmb3IgTnVsbCB0eXBlXCIpO1xyXG4gICAgICAgIGlmICghdGhpcy5pZEJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmlkQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxlbkJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmxlbkJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuYmxvY2tMZW5ndGggKz0gaW5wdXRMZW5ndGg7XHJcbiAgICAgICAgaWYgKChpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKSA+IGlucHV0QnVmZmVyLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRW5kIG9mIGlucHV0IHJlYWNoZWQgYmVmb3JlIG1lc3NhZ2Ugd2FzIGZ1bGx5IGRlY29kZWQgKGluY29uc2lzdGVudCBvZmZzZXQgYW5kIGxlbmd0aCB2YWx1ZXMpXCI7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHRvQkVSKHNpemVPbmx5LCB3cml0ZXIpIHtcclxuICAgICAgICBjb25zdCByZXRCdWYgPSBuZXcgQXJyYXlCdWZmZXIoMik7XHJcbiAgICAgICAgaWYgKCFzaXplT25seSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkocmV0QnVmKTtcclxuICAgICAgICAgICAgcmV0Vmlld1swXSA9IDB4MDU7XHJcbiAgICAgICAgICAgIHJldFZpZXdbMV0gPSAweDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod3JpdGVyKSB7XHJcbiAgICAgICAgICAgIHdyaXRlci53cml0ZShyZXRCdWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0QnVmO1xyXG4gICAgfVxyXG4gICAgb25Bc2NpaUVuY29kaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9YDtcclxuICAgIH1cclxufVxyXG5fYSR0ID0gTnVsbDtcclxuKCgpID0+IHtcclxuICAgIHR5cGVTdG9yZS5OdWxsID0gX2EkdDtcclxufSkoKTtcclxuTnVsbC5OQU1FID0gXCJOVUxMXCI7XG5cbmNsYXNzIExvY2FsQm9vbGVhblZhbHVlQmxvY2sgZXh0ZW5kcyBIZXhCbG9jayhWYWx1ZUJsb2NrKSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLnZhbHVlSGV4KSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShwYXJhbWV0ZXJzLnZhbHVlSGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgb2N0ZXQgb2YgdGhpcy52YWx1ZUhleFZpZXcpIHtcclxuICAgICAgICAgICAgaWYgKG9jdGV0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZUhleFZpZXdbMF0gPSB2YWx1ZSA/IDB4RkYgOiAweDAwO1xyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgaW5wdXRWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XHJcbiAgICAgICAgaWYgKCFjaGVja0J1ZmZlclBhcmFtcyh0aGlzLCBpbnB1dFZpZXcsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IGlucHV0Vmlldy5zdWJhcnJheShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aCk7XHJcbiAgICAgICAgaWYgKGlucHV0TGVuZ3RoID4gMSlcclxuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiQm9vbGVhbiB2YWx1ZSBlbmNvZGVkIGluIG1vcmUgdGhlbiAxIG9jdGV0XCIpO1xyXG4gICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gdHJ1ZTtcclxuICAgICAgICBwdnV0aWxzX19uYW1lc3BhY2UudXRpbERlY29kZVRDLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IGlucHV0TGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiAoaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aCk7XHJcbiAgICB9XHJcbiAgICB0b0JFUigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUhleFZpZXcuc2xpY2UoKTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5Mb2NhbEJvb2xlYW5WYWx1ZUJsb2NrLk5BTUUgPSBcIkJvb2xlYW5WYWx1ZUJsb2NrXCI7XG5cbnZhciBfYSRzO1xyXG5jbGFzcyBCb29sZWFuIGV4dGVuZHMgQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMsIExvY2FsQm9vbGVhblZhbHVlQmxvY2spO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDE7XHJcbiAgICB9XHJcbiAgICBnZXRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUJsb2NrLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0VmFsdWUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcclxuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfSA6ICR7dGhpcy5nZXRWYWx1ZX1gO1xyXG4gICAgfVxyXG59XHJcbl9hJHMgPSBCb29sZWFuO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkJvb2xlYW4gPSBfYSRzO1xyXG59KSgpO1xyXG5Cb29sZWFuLk5BTUUgPSBcIkJPT0xFQU5cIjtcblxuY2xhc3MgTG9jYWxPY3RldFN0cmluZ1ZhbHVlQmxvY2sgZXh0ZW5kcyBIZXhCbG9jayhMb2NhbENvbnN0cnVjdGVkVmFsdWVCbG9jaykge1xyXG4gICAgY29uc3RydWN0b3IoeyBpc0NvbnN0cnVjdGVkID0gZmFsc2UsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pc0NvbnN0cnVjdGVkID0gaXNDb25zdHJ1Y3RlZDtcclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQ29uc3RydWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0hleE9ubHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmVzdWx0T2Zmc2V0ID0gTG9jYWxDb25zdHJ1Y3RlZFZhbHVlQmxvY2sucHJvdG90eXBlLmZyb21CRVIuY2FsbCh0aGlzLCBpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdE9mZnNldCA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCbG9ja05hbWUgPSB0aGlzLnZhbHVlW2ldLmNvbnN0cnVjdG9yLk5BTUU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEJsb2NrTmFtZSA9PT0gRU5EX09GX0NPTlRFTlRfTkFNRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW5kZWZpbml0ZUZvcm0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gXCJFbmRPZkNvbnRlbnQgaXMgdW5leHBlY3RlZCwgT0NURVQgU1RSSU5HIG1heSBjb25zaXN0cyBvZiBPQ1RFVCBTVFJJTkdzIG9ubHlcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2tOYW1lICE9PSBPQ1RFVF9TVFJJTkdfTkFNRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIk9DVEVUIFNUUklORyBtYXkgY29uc2lzdHMgb2YgT0NURVQgU1RSSU5HcyBvbmx5XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmlzSGV4T25seSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlc3VsdE9mZnNldCA9IHN1cGVyLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSBpbnB1dExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgIH1cclxuICAgIHRvQkVSKHNpemVPbmx5LCB3cml0ZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKVxyXG4gICAgICAgICAgICByZXR1cm4gTG9jYWxDb25zdHJ1Y3RlZFZhbHVlQmxvY2sucHJvdG90eXBlLnRvQkVSLmNhbGwodGhpcywgc2l6ZU9ubHksIHdyaXRlcik7XHJcbiAgICAgICAgcmV0dXJuIHNpemVPbmx5XHJcbiAgICAgICAgICAgID8gbmV3IEFycmF5QnVmZmVyKHRoaXMudmFsdWVIZXhWaWV3LmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgIDogdGhpcy52YWx1ZUhleFZpZXcuc2xpY2UoKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIGlzQ29uc3RydWN0ZWQ6IHRoaXMuaXNDb25zdHJ1Y3RlZCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbkxvY2FsT2N0ZXRTdHJpbmdWYWx1ZUJsb2NrLk5BTUUgPSBcIk9jdGV0U3RyaW5nVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkcjtcclxuY2xhc3MgT2N0ZXRTdHJpbmcgZXh0ZW5kcyBCYXNlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IoeyBpZEJsb2NrID0ge30sIGxlbkJsb2NrID0ge30sIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgdmFyIF9iLCBfYztcclxuICAgICAgICAoX2IgPSBwYXJhbWV0ZXJzLmlzQ29uc3RydWN0ZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChwYXJhbWV0ZXJzLmlzQ29uc3RydWN0ZWQgPSAhISgoX2MgPSBwYXJhbWV0ZXJzLnZhbHVlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSk7XHJcbiAgICAgICAgc3VwZXIoe1xyXG4gICAgICAgICAgICBpZEJsb2NrOiB7XHJcbiAgICAgICAgICAgICAgICBpc0NvbnN0cnVjdGVkOiBwYXJhbWV0ZXJzLmlzQ29uc3RydWN0ZWQsXHJcbiAgICAgICAgICAgICAgICAuLi5pZEJsb2NrLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsZW5CbG9jazoge1xyXG4gICAgICAgICAgICAgICAgLi4ubGVuQmxvY2ssXHJcbiAgICAgICAgICAgICAgICBpc0luZGVmaW5pdGVGb3JtOiAhIXBhcmFtZXRlcnMuaXNJbmRlZmluaXRlRm9ybSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLi4ucGFyYW1ldGVycyxcclxuICAgICAgICB9LCBMb2NhbE9jdGV0U3RyaW5nVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gNDtcclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay5pc0NvbnN0cnVjdGVkID0gdGhpcy5pZEJsb2NrLmlzQ29uc3RydWN0ZWQ7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLmlzSW5kZWZpbml0ZUZvcm0gPSB0aGlzLmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm07XHJcbiAgICAgICAgaWYgKGlucHV0TGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlkQmxvY2suZXJyb3IubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmlkQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbkJsb2NrLmVycm9yLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggKz0gdGhpcy5sZW5CbG9jay5ibG9ja0xlbmd0aDtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0T2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMudmFsdWVCbG9jay5pc0NvbnN0cnVjdGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBpbnB1dEJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpIDogaW5wdXRCdWZmZXI7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IHZpZXcuc3ViYXJyYXkoaW5wdXRPZmZzZXQsIGlucHV0T2Zmc2V0ICsgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1Zi5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuID0gbG9jYWxGcm9tQkVSKGJ1ZiwgMCwgYnVmLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhc24ub2Zmc2V0ICE9PSAtMSAmJiBhc24ub2Zmc2V0ID09PSBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWUgPSBbYXNuLnJlc3VsdF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBvbkFzY2lpRW5jb2RpbmcoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWVCbG9jay5pc0NvbnN0cnVjdGVkIHx8ICh0aGlzLnZhbHVlQmxvY2sudmFsdWUgJiYgdGhpcy52YWx1ZUJsb2NrLnZhbHVlLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdGVkLnByb3RvdHlwZS5vbkFzY2lpRW5jb2RpbmcuY2FsbCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IuTkFNRX0gOiAke3B2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuVG9IZXgodGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4Vmlldyl9YDtcclxuICAgIH1cclxuICAgIGdldFZhbHVlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pZEJsb2NrLmlzQ29uc3RydWN0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXcuc2xpY2UoKS5idWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFycmF5ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBjb250ZW50IG9mIHRoaXMudmFsdWVCbG9jay52YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIE9jdGV0U3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKGNvbnRlbnQudmFsdWVCbG9jay52YWx1ZUhleFZpZXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIuY29uY2F0KGFycmF5KTtcclxuICAgIH1cclxufVxyXG5fYSRyID0gT2N0ZXRTdHJpbmc7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuT2N0ZXRTdHJpbmcgPSBfYSRyO1xyXG59KSgpO1xyXG5PY3RldFN0cmluZy5OQU1FID0gT0NURVRfU1RSSU5HX05BTUU7XG5cbmNsYXNzIExvY2FsQml0U3RyaW5nVmFsdWVCbG9jayBleHRlbmRzIEhleEJsb2NrKExvY2FsQ29uc3RydWN0ZWRWYWx1ZUJsb2NrKSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHVudXNlZEJpdHMgPSAwLCBpc0NvbnN0cnVjdGVkID0gZmFsc2UsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy51bnVzZWRCaXRzID0gdW51c2VkQml0cztcclxuICAgICAgICB0aGlzLmlzQ29uc3RydWN0ZWQgPSBpc0NvbnN0cnVjdGVkO1xyXG4gICAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSB0aGlzLnZhbHVlSGV4Vmlldy5ieXRlTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFpbnB1dExlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAtMTtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdE9mZnNldCA9IExvY2FsQ29uc3RydWN0ZWRWYWx1ZUJsb2NrLnByb3RvdHlwZS5mcm9tQkVSLmNhbGwodGhpcywgaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tOYW1lID0gdmFsdWUuY29uc3RydWN0b3IuTkFNRTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2tOYW1lID09PSBFTkRfT0ZfQ09OVEVOVF9OQU1FKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbmRlZmluaXRlRm9ybSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIkVuZE9mQ29udGVudCBpcyB1bmV4cGVjdGVkLCBCSVQgU1RSSU5HIG1heSBjb25zaXN0cyBvZiBCSVQgU1RSSU5HcyBvbmx5XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEJsb2NrTmFtZSAhPT0gQklUX1NUUklOR19OQU1FKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiQklUIFNUUklORyBtYXkgY29uc2lzdHMgb2YgQklUIFNUUklOR3Mgb25seVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlQmxvY2sgPSB2YWx1ZS52YWx1ZUJsb2NrO1xyXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLnVudXNlZEJpdHMgPiAwKSAmJiAodmFsdWVCbG9jay51bnVzZWRCaXRzID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gXCJVc2luZyBvZiBcXFwidW51c2VkIGJpdHNcXFwiIGluc2lkZSBjb25zdHJ1Y3RpdmUgQklUIFNUUklORyBhbGxvd2VkIGZvciBsZWFzdCBvbmUgb25seVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudW51c2VkQml0cyA9IHZhbHVlQmxvY2sudW51c2VkQml0cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnB1dFZpZXcgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGlucHV0QnVmZmVyKTtcclxuICAgICAgICBpZiAoIWNoZWNrQnVmZmVyUGFyYW1zKHRoaXMsIGlucHV0VmlldywgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGludEJ1ZmZlciA9IGlucHV0Vmlldy5zdWJhcnJheShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aCk7XHJcbiAgICAgICAgdGhpcy51bnVzZWRCaXRzID0gaW50QnVmZmVyWzBdO1xyXG4gICAgICAgIGlmICh0aGlzLnVudXNlZEJpdHMgPiA3KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIlVudXNlZCBiaXRzIGZvciBCaXRTdHJpbmcgbXVzdCBiZSBpbiByYW5nZSAwLTdcIjtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMudW51c2VkQml0cykge1xyXG4gICAgICAgICAgICBjb25zdCBidWYgPSBpbnRCdWZmZXIuc3ViYXJyYXkoMSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVmLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc24gPSBsb2NhbEZyb21CRVIoYnVmLCAwLCBidWYuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzbi5vZmZzZXQgIT09IC0xICYmIGFzbi5vZmZzZXQgPT09IChpbnB1dExlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbYXNuLnJlc3VsdF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSBpbnRCdWZmZXIuc3ViYXJyYXkoMSk7XHJcbiAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IGludEJ1ZmZlci5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIChpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHRvQkVSKHNpemVPbmx5LCB3cml0ZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb2NhbENvbnN0cnVjdGVkVmFsdWVCbG9jay5wcm90b3R5cGUudG9CRVIuY2FsbCh0aGlzLCBzaXplT25seSwgd3JpdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpemVPbmx5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIodGhpcy52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMudmFsdWVIZXhWaWV3LmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmV0VmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMudmFsdWVIZXhWaWV3Lmxlbmd0aCArIDEpO1xyXG4gICAgICAgIHJldFZpZXdbMF0gPSB0aGlzLnVudXNlZEJpdHM7XHJcbiAgICAgICAgcmV0Vmlldy5zZXQodGhpcy52YWx1ZUhleFZpZXcsIDEpO1xyXG4gICAgICAgIHJldHVybiByZXRWaWV3LmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgdW51c2VkQml0czogdGhpcy51bnVzZWRCaXRzLFxyXG4gICAgICAgICAgICBpc0NvbnN0cnVjdGVkOiB0aGlzLmlzQ29uc3RydWN0ZWQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5Mb2NhbEJpdFN0cmluZ1ZhbHVlQmxvY2suTkFNRSA9IFwiQml0U3RyaW5nVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkcTtcclxuY2xhc3MgQml0U3RyaW5nIGV4dGVuZHMgQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgaWRCbG9jayA9IHt9LCBsZW5CbG9jayA9IHt9LCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHZhciBfYiwgX2M7XHJcbiAgICAgICAgKF9iID0gcGFyYW1ldGVycy5pc0NvbnN0cnVjdGVkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAocGFyYW1ldGVycy5pc0NvbnN0cnVjdGVkID0gISEoKF9jID0gcGFyYW1ldGVycy52YWx1ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkpO1xyXG4gICAgICAgIHN1cGVyKHtcclxuICAgICAgICAgICAgaWRCbG9jazoge1xyXG4gICAgICAgICAgICAgICAgaXNDb25zdHJ1Y3RlZDogcGFyYW1ldGVycy5pc0NvbnN0cnVjdGVkLFxyXG4gICAgICAgICAgICAgICAgLi4uaWRCbG9jayxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGVuQmxvY2s6IHtcclxuICAgICAgICAgICAgICAgIC4uLmxlbkJsb2NrLFxyXG4gICAgICAgICAgICAgICAgaXNJbmRlZmluaXRlRm9ybTogISFwYXJhbWV0ZXJzLmlzSW5kZWZpbml0ZUZvcm0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC4uLnBhcmFtZXRlcnMsXHJcbiAgICAgICAgfSwgTG9jYWxCaXRTdHJpbmdWYWx1ZUJsb2NrKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAzO1xyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLmlzQ29uc3RydWN0ZWQgPSB0aGlzLmlkQmxvY2suaXNDb25zdHJ1Y3RlZDtcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2suaXNJbmRlZmluaXRlRm9ybSA9IHRoaXMubGVuQmxvY2suaXNJbmRlZmluaXRlRm9ybTtcclxuICAgICAgICByZXR1cm4gc3VwZXIuZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKTtcclxuICAgIH1cclxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZUJsb2NrLmlzQ29uc3RydWN0ZWQgfHwgKHRoaXMudmFsdWVCbG9jay52YWx1ZSAmJiB0aGlzLnZhbHVlQmxvY2sudmFsdWUubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0ZWQucHJvdG90eXBlLm9uQXNjaWlFbmNvZGluZy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgYml0cyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZUhleCA9IHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXc7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYnl0ZSBvZiB2YWx1ZUhleCkge1xyXG4gICAgICAgICAgICAgICAgYml0cy5wdXNoKGJ5dGUudG9TdHJpbmcoMikucGFkU3RhcnQoOCwgXCIwXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBiaXRzU3RyID0gYml0cy5qb2luKFwiXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfSA6ICR7Yml0c1N0ci5zdWJzdHJpbmcoMCwgYml0c1N0ci5sZW5ndGggLSB0aGlzLnZhbHVlQmxvY2sudW51c2VkQml0cyl9YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuX2EkcSA9IEJpdFN0cmluZztcclxuKCgpID0+IHtcclxuICAgIHR5cGVTdG9yZS5CaXRTdHJpbmcgPSBfYSRxO1xyXG59KSgpO1xyXG5CaXRTdHJpbmcuTkFNRSA9IEJJVF9TVFJJTkdfTkFNRTtcblxudmFyIF9hJHA7XHJcbmZ1bmN0aW9uIHZpZXdBZGQoZmlyc3QsIHNlY29uZCkge1xyXG4gICAgY29uc3QgYyA9IG5ldyBVaW50OEFycmF5KFswXSk7XHJcbiAgICBjb25zdCBmaXJzdFZpZXcgPSBuZXcgVWludDhBcnJheShmaXJzdCk7XHJcbiAgICBjb25zdCBzZWNvbmRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoc2Vjb25kKTtcclxuICAgIGxldCBmaXJzdFZpZXdDb3B5ID0gZmlyc3RWaWV3LnNsaWNlKDApO1xyXG4gICAgY29uc3QgZmlyc3RWaWV3Q29weUxlbmd0aCA9IGZpcnN0Vmlld0NvcHkubGVuZ3RoIC0gMTtcclxuICAgIGNvbnN0IHNlY29uZFZpZXdDb3B5ID0gc2Vjb25kVmlldy5zbGljZSgwKTtcclxuICAgIGNvbnN0IHNlY29uZFZpZXdDb3B5TGVuZ3RoID0gc2Vjb25kVmlld0NvcHkubGVuZ3RoIC0gMTtcclxuICAgIGxldCB2YWx1ZSA9IDA7XHJcbiAgICBjb25zdCBtYXggPSAoc2Vjb25kVmlld0NvcHlMZW5ndGggPCBmaXJzdFZpZXdDb3B5TGVuZ3RoKSA/IGZpcnN0Vmlld0NvcHlMZW5ndGggOiBzZWNvbmRWaWV3Q29weUxlbmd0aDtcclxuICAgIGxldCBjb3VudGVyID0gMDtcclxuICAgIGZvciAobGV0IGkgPSBtYXg7IGkgPj0gMDsgaS0tLCBjb3VudGVyKyspIHtcclxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgICAgICAgY2FzZSAoY291bnRlciA8IHNlY29uZFZpZXdDb3B5Lmxlbmd0aCk6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpcnN0Vmlld0NvcHlbZmlyc3RWaWV3Q29weUxlbmd0aCAtIGNvdW50ZXJdICsgc2Vjb25kVmlld0NvcHlbc2Vjb25kVmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSArIGNbMF07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZmlyc3RWaWV3Q29weVtmaXJzdFZpZXdDb3B5TGVuZ3RoIC0gY291bnRlcl0gKyBjWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjWzBdID0gdmFsdWUgLyAxMDtcclxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgICAgICAgY2FzZSAoY291bnRlciA+PSBmaXJzdFZpZXdDb3B5Lmxlbmd0aCk6XHJcbiAgICAgICAgICAgICAgICBmaXJzdFZpZXdDb3B5ID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxDb25jYXRWaWV3KG5ldyBVaW50OEFycmF5KFt2YWx1ZSAlIDEwXSksIGZpcnN0Vmlld0NvcHkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBmaXJzdFZpZXdDb3B5W2ZpcnN0Vmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSA9IHZhbHVlICUgMTA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGNbMF0gPiAwKVxyXG4gICAgICAgIGZpcnN0Vmlld0NvcHkgPSBwdnV0aWxzX19uYW1lc3BhY2UudXRpbENvbmNhdFZpZXcoYywgZmlyc3RWaWV3Q29weSk7XHJcbiAgICByZXR1cm4gZmlyc3RWaWV3Q29weTtcclxufVxyXG5mdW5jdGlvbiBwb3dlcjIobikge1xyXG4gICAgaWYgKG4gPj0gcG93ZXJzMi5sZW5ndGgpIHtcclxuICAgICAgICBmb3IgKGxldCBwID0gcG93ZXJzMi5sZW5ndGg7IHAgPD0gbjsgcCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBuZXcgVWludDhBcnJheShbMF0pO1xyXG4gICAgICAgICAgICBsZXQgZGlnaXRzID0gKHBvd2VyczJbcCAtIDFdKS5zbGljZSgwKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IChkaWdpdHMubGVuZ3RoIC0gMSk7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG5ldyBVaW50OEFycmF5KFsoZGlnaXRzW2ldIDw8IDEpICsgY1swXV0pO1xyXG4gICAgICAgICAgICAgICAgY1swXSA9IG5ld1ZhbHVlWzBdIC8gMTA7XHJcbiAgICAgICAgICAgICAgICBkaWdpdHNbaV0gPSBuZXdWYWx1ZVswXSAlIDEwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjWzBdID4gMClcclxuICAgICAgICAgICAgICAgIGRpZ2l0cyA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsQ29uY2F0VmlldyhjLCBkaWdpdHMpO1xyXG4gICAgICAgICAgICBwb3dlcnMyLnB1c2goZGlnaXRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG93ZXJzMltuXTtcclxufVxyXG5mdW5jdGlvbiB2aWV3U3ViKGZpcnN0LCBzZWNvbmQpIHtcclxuICAgIGxldCBiID0gMDtcclxuICAgIGNvbnN0IGZpcnN0VmlldyA9IG5ldyBVaW50OEFycmF5KGZpcnN0KTtcclxuICAgIGNvbnN0IHNlY29uZFZpZXcgPSBuZXcgVWludDhBcnJheShzZWNvbmQpO1xyXG4gICAgY29uc3QgZmlyc3RWaWV3Q29weSA9IGZpcnN0Vmlldy5zbGljZSgwKTtcclxuICAgIGNvbnN0IGZpcnN0Vmlld0NvcHlMZW5ndGggPSBmaXJzdFZpZXdDb3B5Lmxlbmd0aCAtIDE7XHJcbiAgICBjb25zdCBzZWNvbmRWaWV3Q29weSA9IHNlY29uZFZpZXcuc2xpY2UoMCk7XHJcbiAgICBjb25zdCBzZWNvbmRWaWV3Q29weUxlbmd0aCA9IHNlY29uZFZpZXdDb3B5Lmxlbmd0aCAtIDE7XHJcbiAgICBsZXQgdmFsdWU7XHJcbiAgICBsZXQgY291bnRlciA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gc2Vjb25kVmlld0NvcHlMZW5ndGg7IGkgPj0gMDsgaS0tLCBjb3VudGVyKyspIHtcclxuICAgICAgICB2YWx1ZSA9IGZpcnN0Vmlld0NvcHlbZmlyc3RWaWV3Q29weUxlbmd0aCAtIGNvdW50ZXJdIC0gc2Vjb25kVmlld0NvcHlbc2Vjb25kVmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSAtIGI7XHJcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgKHZhbHVlIDwgMCk6XHJcbiAgICAgICAgICAgICAgICBiID0gMTtcclxuICAgICAgICAgICAgICAgIGZpcnN0Vmlld0NvcHlbZmlyc3RWaWV3Q29weUxlbmd0aCAtIGNvdW50ZXJdID0gdmFsdWUgKyAxMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYiA9IDA7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFZpZXdDb3B5W2ZpcnN0Vmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChiID4gMCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAoZmlyc3RWaWV3Q29weUxlbmd0aCAtIHNlY29uZFZpZXdDb3B5TGVuZ3RoICsgMSk7IGkgPj0gMDsgaS0tLCBjb3VudGVyKyspIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBmaXJzdFZpZXdDb3B5W2ZpcnN0Vmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSAtIGI7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGIgPSAxO1xyXG4gICAgICAgICAgICAgICAgZmlyc3RWaWV3Q29weVtmaXJzdFZpZXdDb3B5TGVuZ3RoIC0gY291bnRlcl0gPSB2YWx1ZSArIDEwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYiA9IDA7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFZpZXdDb3B5W2ZpcnN0Vmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmlyc3RWaWV3Q29weS5zbGljZSgpO1xyXG59XHJcbmNsYXNzIExvY2FsSW50ZWdlclZhbHVlQmxvY2sgZXh0ZW5kcyBIZXhCbG9jayhWYWx1ZUJsb2NrKSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlRGVjID0gMDtcclxuICAgICAgICBpZiAocGFyYW1ldGVycy52YWx1ZUhleCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlSGV4KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVEZWMgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRWYWx1ZUhleCgpIHtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoID49IDQpIHtcclxuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiVG9vIGJpZyBJbnRlZ2VyIGZvciBkZWNvZGluZywgaGV4IG9ubHlcIik7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVEZWMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pc0hleE9ubHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVIZXhWaWV3Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlRGVjID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxEZWNvZGVUQy5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlRGVjKHYpIHtcclxuICAgICAgICB0aGlzLl92YWx1ZURlYyA9IHY7XHJcbiAgICAgICAgdGhpcy5pc0hleE9ubHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHB2dXRpbHNfX25hbWVzcGFjZS51dGlsRW5jb2RlVEModikpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlRGVjKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZURlYztcclxuICAgIH1cclxuICAgIGZyb21ERVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCwgZXhwZWN0ZWRMZW5ndGggPSAwKSB7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5mcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgPT09IC0xKVxyXG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZhbHVlSGV4VmlldztcclxuICAgICAgICBpZiAoKHZpZXdbMF0gPT09IDB4MDApICYmICgodmlld1sxXSAmIDB4ODApICE9PSAwKSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IHZpZXcuc3ViYXJyYXkoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRMZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICh2aWV3Lmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChleHBlY3RlZExlbmd0aCAtIHZpZXcubGVuZ3RoKSA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkTGVuZ3RoID0gdmlldy5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gdmlldy5zdWJhcnJheShleHBlY3RlZExlbmd0aCAtIHZpZXcubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgdG9ERVIoc2l6ZU9ubHkgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZhbHVlSGV4VmlldztcclxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgICAgICAgY2FzZSAoKHZpZXdbMF0gJiAweDgwKSAhPT0gMCk6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLnZhbHVlSGV4Vmlldy5sZW5ndGggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkVmlld1swXSA9IDB4MDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFZpZXcuc2V0KHZpZXcsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gdXBkYXRlZFZpZXc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAoKHZpZXdbMF0gPT09IDB4MDApICYmICgodmlld1sxXSAmIDB4ODApID09PSAwKSk6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSB0aGlzLnZhbHVlSGV4Vmlldy5zdWJhcnJheSgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50b0JFUihzaXplT25seSk7XHJcbiAgICB9XHJcbiAgICBmcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCByZXN1bHRPZmZzZXQgPSBzdXBlci5mcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0VmFsdWVIZXgoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgdG9CRVIoc2l6ZU9ubHkpIHtcclxuICAgICAgICByZXR1cm4gc2l6ZU9ubHlcclxuICAgICAgICAgICAgPyBuZXcgQXJyYXlCdWZmZXIodGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoKVxyXG4gICAgICAgICAgICA6IHRoaXMudmFsdWVIZXhWaWV3LnNsaWNlKCkuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxyXG4gICAgICAgICAgICB2YWx1ZURlYzogdGhpcy52YWx1ZURlYyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RCaXQgPSAodGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoICogOCkgLSAxO1xyXG4gICAgICAgIGxldCBkaWdpdHMgPSBuZXcgVWludDhBcnJheSgodGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoICogOCkgLyAzKTtcclxuICAgICAgICBsZXQgYml0TnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgY3VycmVudEJ5dGU7XHJcbiAgICAgICAgY29uc3QgYXNuMVZpZXcgPSB0aGlzLnZhbHVlSGV4VmlldztcclxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICBsZXQgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGJ5dGVOdW1iZXIgPSAoYXNuMVZpZXcuYnl0ZUxlbmd0aCAtIDEpOyBieXRlTnVtYmVyID49IDA7IGJ5dGVOdW1iZXItLSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA9IGFzbjFWaWV3W2J5dGVOdW1iZXJdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKChjdXJyZW50Qnl0ZSAmIDEpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChiaXROdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBmaXJzdEJpdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0cyA9IHZpZXdTdWIocG93ZXIyKGJpdE51bWJlciksIGRpZ2l0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIi1cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzID0gdmlld0FkZChkaWdpdHMsIHBvd2VyMihiaXROdW1iZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBiaXROdW1iZXIrKztcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlID4+PSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkaWdpdHNbaV0pXHJcbiAgICAgICAgICAgICAgICBmbGFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGZsYWcpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZGlnaXRzU3RyaW5nLmNoYXJBdChkaWdpdHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmxhZyA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBkaWdpdHNTdHJpbmcuY2hhckF0KDApO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuX2EkcCA9IExvY2FsSW50ZWdlclZhbHVlQmxvY2s7XHJcbkxvY2FsSW50ZWdlclZhbHVlQmxvY2suTkFNRSA9IFwiSW50ZWdlclZhbHVlQmxvY2tcIjtcclxuKCgpID0+IHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYSRwLnByb3RvdHlwZSwgXCJ2YWx1ZUhleFwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHYpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlSGV4KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVIZXhWaWV3LnNsaWNlKCkuYnVmZmVyO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufSkoKTtcblxudmFyIF9hJG87XHJcbmNsYXNzIEludGVnZXIgZXh0ZW5kcyBCYXNlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycywgTG9jYWxJbnRlZ2VyVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMjtcclxuICAgIH1cclxuICAgIHRvQmlnSW50KCkge1xyXG4gICAgICAgIGFzc2VydEJpZ0ludCgpO1xyXG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy52YWx1ZUJsb2NrLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21CaWdJbnQodmFsdWUpIHtcclxuICAgICAgICBhc3NlcnRCaWdJbnQoKTtcclxuICAgICAgICBjb25zdCBiaWdJbnRWYWx1ZSA9IEJpZ0ludCh2YWx1ZSk7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFZpZXdXcml0ZXIoKTtcclxuICAgICAgICBjb25zdCBoZXggPSBiaWdJbnRWYWx1ZS50b1N0cmluZygxNikucmVwbGFjZSgvXi0vLCBcIlwiKTtcclxuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Gcm9tSGV4KGhleCkpO1xyXG4gICAgICAgIGlmIChiaWdJbnRWYWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBuZXcgVWludDhBcnJheSh2aWV3Lmxlbmd0aCArICh2aWV3WzBdICYgMHg4MCA/IDEgOiAwKSk7XHJcbiAgICAgICAgICAgIGZpcnN0WzBdIHw9IDB4ODA7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0SW50ID0gQmlnSW50KGAweCR7cHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0hleChmaXJzdCl9YCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZEludCA9IGZpcnN0SW50ICsgYmlnSW50VmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZCA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkocHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Gcm9tSGV4KHNlY29uZEludC50b1N0cmluZygxNikpKTtcclxuICAgICAgICAgICAgc2Vjb25kWzBdIHw9IDB4ODA7XHJcbiAgICAgICAgICAgIHdyaXRlci53cml0ZShzZWNvbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHZpZXdbMF0gJiAweDgwKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGUobmV3IFVpbnQ4QXJyYXkoWzBdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd3JpdGVyLndyaXRlKHZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBuZXcgSW50ZWdlcih7XHJcbiAgICAgICAgICAgIHZhbHVlSGV4OiB3cml0ZXIuZmluYWwoKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgY29udmVydFRvREVSKCkge1xyXG4gICAgICAgIGNvbnN0IGludGVnZXIgPSBuZXcgSW50ZWdlcih7IHZhbHVlSGV4OiB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3IH0pO1xyXG4gICAgICAgIGludGVnZXIudmFsdWVCbG9jay50b0RFUigpO1xyXG4gICAgICAgIHJldHVybiBpbnRlZ2VyO1xyXG4gICAgfVxyXG4gICAgY29udmVydEZyb21ERVIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlZ2VyKHtcclxuICAgICAgICAgICAgdmFsdWVIZXg6IHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXdbMF0gPT09IDBcclxuICAgICAgICAgICAgICAgID8gdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4Vmlldy5zdWJhcnJheSgxKVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb25Bc2NpaUVuY29kaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9IDogJHt0aGlzLnZhbHVlQmxvY2sudG9TdHJpbmcoKX1gO1xyXG4gICAgfVxyXG59XHJcbl9hJG8gPSBJbnRlZ2VyO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkludGVnZXIgPSBfYSRvO1xyXG59KSgpO1xyXG5JbnRlZ2VyLk5BTUUgPSBcIklOVEVHRVJcIjtcblxudmFyIF9hJG47XHJcbmNsYXNzIEVudW1lcmF0ZWQgZXh0ZW5kcyBJbnRlZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDEwO1xyXG4gICAgfVxyXG59XHJcbl9hJG4gPSBFbnVtZXJhdGVkO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkVudW1lcmF0ZWQgPSBfYSRuO1xyXG59KSgpO1xyXG5FbnVtZXJhdGVkLk5BTUUgPSBcIkVOVU1FUkFURURcIjtcblxuY2xhc3MgTG9jYWxTaWRWYWx1ZUJsb2NrIGV4dGVuZHMgSGV4QmxvY2soVmFsdWVCbG9jaykge1xyXG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZURlYyA9IC0xLCBpc0ZpcnN0U2lkID0gZmFsc2UsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy52YWx1ZURlYyA9IHZhbHVlRGVjO1xyXG4gICAgICAgIHRoaXMuaXNGaXJzdFNpZCA9IGlzRmlyc3RTaWQ7XHJcbiAgICB9XHJcbiAgICBmcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcclxuICAgICAgICBpZiAoIWlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5wdXRWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XHJcbiAgICAgICAgaWYgKCFjaGVja0J1ZmZlclBhcmFtcyh0aGlzLCBpbnB1dFZpZXcsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnRCdWZmZXIgPSBpbnB1dFZpZXcuc3ViYXJyYXkoaW5wdXRPZmZzZXQsIGlucHV0T2Zmc2V0ICsgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlSGV4Vmlld1tpXSA9IGludEJ1ZmZlcltpXSAmIDB4N0Y7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGgrKztcclxuICAgICAgICAgICAgaWYgKChpbnRCdWZmZXJbaV0gJiAweDgwKSA9PT0gMHgwMClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0ZW1wVmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYmxvY2tMZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ibG9ja0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRlbXBWaWV3W2ldID0gdGhpcy52YWx1ZUhleFZpZXdbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gdGVtcFZpZXc7XHJcbiAgICAgICAgaWYgKChpbnRCdWZmZXJbdGhpcy5ibG9ja0xlbmd0aCAtIDFdICYgMHg4MCkgIT09IDB4MDApIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRW5kIG9mIGlucHV0IHJlYWNoZWQgYmVmb3JlIG1lc3NhZ2Ugd2FzIGZ1bGx5IGRlY29kZWRcIjtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy52YWx1ZUhleFZpZXdbMF0gPT09IDB4MDApXHJcbiAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChcIk5lZWRsZXNzbHkgbG9uZyBmb3JtYXQgb2YgU0lEIGVuY29kaW5nXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmJsb2NrTGVuZ3RoIDw9IDgpXHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVEZWMgPSBwdnV0aWxzX19uYW1lc3BhY2UudXRpbEZyb21CYXNlKHRoaXMudmFsdWVIZXhWaWV3LCA3KTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pc0hleE9ubHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2goXCJUb28gYmlnIFNJRCBmb3IgZGVjb2RpbmcsIGhleCBvbmx5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGlucHV0T2Zmc2V0ICsgdGhpcy5ibG9ja0xlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWVCaWdJbnQodmFsdWUpIHtcclxuICAgICAgICBhc3NlcnRCaWdJbnQoKTtcclxuICAgICAgICBsZXQgYml0cyA9IEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoMik7XHJcbiAgICAgICAgd2hpbGUgKGJpdHMubGVuZ3RoICUgNykge1xyXG4gICAgICAgICAgICBiaXRzID0gXCIwXCIgKyBiaXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpdHMubGVuZ3RoIC8gNyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBieXRlc1tpXSA9IHBhcnNlSW50KGJpdHMuc2xpY2UoaSAqIDcsIGkgKiA3ICsgNyksIDIpICsgKGkgKyAxIDwgYnl0ZXMubGVuZ3RoID8gMHg4MCA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZyb21CRVIoYnl0ZXMuYnVmZmVyLCAwLCBieXRlcy5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgdG9CRVIoc2l6ZU9ubHkpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0hleE9ubHkpIHtcclxuICAgICAgICAgICAgaWYgKHNpemVPbmx5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgQXJyYXlCdWZmZXIodGhpcy52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aCkpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJWaWV3ID0gdGhpcy52YWx1ZUhleFZpZXc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrTGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAodGhpcy5ibG9ja0xlbmd0aCAtIDEpOyBpKyspXHJcbiAgICAgICAgICAgICAgICByZXRWaWV3W2ldID0gY3VyVmlld1tpXSB8IDB4ODA7XHJcbiAgICAgICAgICAgIHJldFZpZXdbdGhpcy5ibG9ja0xlbmd0aCAtIDFdID0gY3VyVmlld1t0aGlzLmJsb2NrTGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIHJldHVybiByZXRWaWV3LmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW5jb2RlZEJ1ZiA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsVG9CYXNlKHRoaXMudmFsdWVEZWMsIDcpO1xyXG4gICAgICAgIGlmIChlbmNvZGVkQnVmLmJ5dGVMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRXJyb3IgZHVyaW5nIGVuY29kaW5nIFNJRCB2YWx1ZVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoKTtcclxuICAgICAgICBpZiAoIXNpemVPbmx5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEJ1Zik7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGVuY29kZWRCdWYuYnl0ZUxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAgICAgICAgICByZXRWaWV3W2ldID0gZW5jb2RlZFZpZXdbaV0gfCAweDgwO1xyXG4gICAgICAgICAgICByZXRWaWV3W2xlbl0gPSBlbmNvZGVkVmlld1tsZW5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0VmlldztcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIGlmICh0aGlzLmlzSGV4T25seSlcclxuICAgICAgICAgICAgcmVzdWx0ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0hleCh0aGlzLnZhbHVlSGV4Vmlldyk7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmlyc3RTaWQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzaWRWYWx1ZSA9IHRoaXMudmFsdWVEZWM7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZURlYyA8PSAzOSlcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIjAuXCI7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZURlYyA8PSA3OSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIjEuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZFZhbHVlIC09IDQwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXCIyLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRWYWx1ZSAtPSA4MDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2lkVmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnZhbHVlRGVjLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIHZhbHVlRGVjOiB0aGlzLnZhbHVlRGVjLFxyXG4gICAgICAgICAgICBpc0ZpcnN0U2lkOiB0aGlzLmlzRmlyc3RTaWQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5Mb2NhbFNpZFZhbHVlQmxvY2suTkFNRSA9IFwic2lkQmxvY2tcIjtcblxuY2xhc3MgTG9jYWxPYmplY3RJZGVudGlmaWVyVmFsdWVCbG9jayBleHRlbmRzIFZhbHVlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSA9IEVNUFRZX1NUUklORywgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gW107XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdE9mZnNldCA9IGlucHV0T2Zmc2V0O1xyXG4gICAgICAgIHdoaWxlIChpbnB1dExlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3Qgc2lkQmxvY2sgPSBuZXcgTG9jYWxTaWRWYWx1ZUJsb2NrKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdE9mZnNldCA9IHNpZEJsb2NrLmZyb21CRVIoaW5wdXRCdWZmZXIsIHJlc3VsdE9mZnNldCwgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0T2Zmc2V0ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gc2lkQmxvY2suZXJyb3I7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHNpZEJsb2NrLmlzRmlyc3RTaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoICs9IHNpZEJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgICAgICAgICBpbnB1dExlbmd0aCAtPSBzaWRCbG9jay5ibG9ja0xlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZS5wdXNoKHNpZEJsb2NrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgIH1cclxuICAgIHRvQkVSKHNpemVPbmx5KSB7XHJcbiAgICAgICAgY29uc3QgcmV0QnVmZmVycyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZUJ1ZiA9IHRoaXMudmFsdWVbaV0udG9CRVIoc2l6ZU9ubHkpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWVCdWYuYnl0ZUxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHRoaXMudmFsdWVbaV0uZXJyb3I7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldEJ1ZmZlcnMucHVzaCh2YWx1ZUJ1Zik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb25jYXQocmV0QnVmZmVycyk7XHJcbiAgICB9XHJcbiAgICBmcm9tU3RyaW5nKHN0cmluZykge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcclxuICAgICAgICBsZXQgcG9zMSA9IDA7XHJcbiAgICAgICAgbGV0IHBvczIgPSAwO1xyXG4gICAgICAgIGxldCBzaWQgPSBcIlwiO1xyXG4gICAgICAgIGxldCBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBwb3MyID0gc3RyaW5nLmluZGV4T2YoXCIuXCIsIHBvczEpO1xyXG4gICAgICAgICAgICBpZiAocG9zMiA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICBzaWQgPSBzdHJpbmcuc3Vic3RyaW5nKHBvczEpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBzaWQgPSBzdHJpbmcuc3Vic3RyaW5nKHBvczEsIHBvczIpO1xyXG4gICAgICAgICAgICBwb3MxID0gcG9zMiArIDE7XHJcbiAgICAgICAgICAgIGlmIChmbGFnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaWRCbG9jayA9IHRoaXMudmFsdWVbMF07XHJcbiAgICAgICAgICAgICAgICBsZXQgcGx1cyA9IDA7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNpZEJsb2NrLnZhbHVlRGVjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdXMgPSA0MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbHVzID0gODA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkU0lEID0gcGFyc2VJbnQoc2lkLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VkU0lEKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBzaWRCbG9jay52YWx1ZURlYyA9IHBhcnNlZFNJRCArIHBsdXM7XHJcbiAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaWRCbG9jayA9IG5ldyBMb2NhbFNpZFZhbHVlQmxvY2soKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaWQgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydEJpZ0ludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZFZhbHVlID0gQmlnSW50KHNpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lkQmxvY2sudmFsdWVCaWdJbnQgPSBzaWRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZEJsb2NrLnZhbHVlRGVjID0gcGFyc2VJbnQoc2lkLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHNpZEJsb2NrLnZhbHVlRGVjKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZEJsb2NrLmlzRmlyc3RTaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5wdXNoKHNpZEJsb2NrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKHBvczIgIT09IC0xKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIGxldCBpc0hleE9ubHkgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaXNIZXhPbmx5ID0gdGhpcy52YWx1ZVtpXS5pc0hleE9ubHk7XHJcbiAgICAgICAgICAgIGxldCBzaWRTdHIgPSB0aGlzLnZhbHVlW2ldLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChpICE9PSAwKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fS5gO1xyXG4gICAgICAgICAgICBpZiAoaXNIZXhPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICBzaWRTdHIgPSBgeyR7c2lkU3RyfX1gO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVbaV0uaXNGaXJzdFNpZClcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBgMi57JHtzaWRTdHJ9IC0gODB9YDtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2lkU3RyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzaWRTdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgc2lkQXJyYXk6IFtdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG9iamVjdC5zaWRBcnJheS5wdXNoKHRoaXMudmFsdWVbaV0udG9KU09OKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgfVxyXG59XHJcbkxvY2FsT2JqZWN0SWRlbnRpZmllclZhbHVlQmxvY2suTkFNRSA9IFwiT2JqZWN0SWRlbnRpZmllclZhbHVlQmxvY2tcIjtcblxudmFyIF9hJG07XHJcbmNsYXNzIE9iamVjdElkZW50aWZpZXIgZXh0ZW5kcyBCYXNlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycywgTG9jYWxPYmplY3RJZGVudGlmaWVyVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gNjtcclxuICAgIH1cclxuICAgIGdldFZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlQmxvY2sudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIHNldFZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLmZyb21TdHJpbmcodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgb25Bc2NpaUVuY29kaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9IDogJHt0aGlzLnZhbHVlQmxvY2sudG9TdHJpbmcoKSB8fCBcImVtcHR5XCJ9YDtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuZ2V0VmFsdWUoKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbl9hJG0gPSBPYmplY3RJZGVudGlmaWVyO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLk9iamVjdElkZW50aWZpZXIgPSBfYSRtO1xyXG59KSgpO1xyXG5PYmplY3RJZGVudGlmaWVyLk5BTUUgPSBcIk9CSkVDVCBJREVOVElGSUVSXCI7XG5cbmNsYXNzIExvY2FsUmVsYXRpdmVTaWRWYWx1ZUJsb2NrIGV4dGVuZHMgSGV4QmxvY2soTG9jYWxCYXNlQmxvY2spIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWVEZWMgPSAwLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMudmFsdWVEZWMgPSB2YWx1ZURlYztcclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIGlmIChpbnB1dExlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0T2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IGlucHV0VmlldyA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpO1xyXG4gICAgICAgIGlmICghY2hlY2tCdWZmZXJQYXJhbXModGhpcywgaW5wdXRWaWV3LCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgY29uc3QgaW50QnVmZmVyID0gaW5wdXRWaWV3LnN1YmFycmF5KGlucHV0T2Zmc2V0LCBpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKTtcclxuICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KGlucHV0TGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0TGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZUhleFZpZXdbaV0gPSBpbnRCdWZmZXJbaV0gJiAweDdGO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoKys7XHJcbiAgICAgICAgICAgIGlmICgoaW50QnVmZmVyW2ldICYgMHg4MCkgPT09IDB4MDApXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGVtcFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrTGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmxvY2tMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgdGVtcFZpZXdbaV0gPSB0aGlzLnZhbHVlSGV4Vmlld1tpXTtcclxuICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IHRlbXBWaWV3O1xyXG4gICAgICAgIGlmICgoaW50QnVmZmVyW3RoaXMuYmxvY2tMZW5ndGggLSAxXSAmIDB4ODApICE9PSAweDAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIkVuZCBvZiBpbnB1dCByZWFjaGVkIGJlZm9yZSBtZXNzYWdlIHdhcyBmdWxseSBkZWNvZGVkXCI7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWVIZXhWaWV3WzBdID09PSAweDAwKVxyXG4gICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2goXCJOZWVkbGVzc2x5IGxvbmcgZm9ybWF0IG9mIFNJRCBlbmNvZGluZ1wiKTtcclxuICAgICAgICBpZiAodGhpcy5ibG9ja0xlbmd0aCA8PSA4KVxyXG4gICAgICAgICAgICB0aGlzLnZhbHVlRGVjID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxGcm9tQmFzZSh0aGlzLnZhbHVlSGV4VmlldywgNyk7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiVG9vIGJpZyBTSUQgZm9yIGRlY29kaW5nLCBoZXggb25seVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChpbnB1dE9mZnNldCArIHRoaXMuYmxvY2tMZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgdG9CRVIoc2l6ZU9ubHkpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0hleE9ubHkpIHtcclxuICAgICAgICAgICAgaWYgKHNpemVPbmx5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgQXJyYXlCdWZmZXIodGhpcy52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aCkpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJWaWV3ID0gdGhpcy52YWx1ZUhleFZpZXc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrTGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAodGhpcy5ibG9ja0xlbmd0aCAtIDEpOyBpKyspXHJcbiAgICAgICAgICAgICAgICByZXRWaWV3W2ldID0gY3VyVmlld1tpXSB8IDB4ODA7XHJcbiAgICAgICAgICAgIHJldFZpZXdbdGhpcy5ibG9ja0xlbmd0aCAtIDFdID0gY3VyVmlld1t0aGlzLmJsb2NrTGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIHJldHVybiByZXRWaWV3LmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW5jb2RlZEJ1ZiA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsVG9CYXNlKHRoaXMudmFsdWVEZWMsIDcpO1xyXG4gICAgICAgIGlmIChlbmNvZGVkQnVmLmJ5dGVMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRXJyb3IgZHVyaW5nIGVuY29kaW5nIFNJRCB2YWx1ZVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoKTtcclxuICAgICAgICBpZiAoIXNpemVPbmx5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEJ1Zik7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGVuY29kZWRCdWYuYnl0ZUxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAgICAgICAgICByZXRWaWV3W2ldID0gZW5jb2RlZFZpZXdbaV0gfCAweDgwO1xyXG4gICAgICAgICAgICByZXRWaWV3W2xlbl0gPSBlbmNvZGVkVmlld1tsZW5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0Vmlldy5idWZmZXI7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICBpZiAodGhpcy5pc0hleE9ubHkpXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuVG9IZXgodGhpcy52YWx1ZUhleFZpZXcpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnZhbHVlRGVjLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIHZhbHVlRGVjOiB0aGlzLnZhbHVlRGVjLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuTG9jYWxSZWxhdGl2ZVNpZFZhbHVlQmxvY2suTkFNRSA9IFwicmVsYXRpdmVTaWRCbG9ja1wiO1xuXG5jbGFzcyBMb2NhbFJlbGF0aXZlT2JqZWN0SWRlbnRpZmllclZhbHVlQmxvY2sgZXh0ZW5kcyBWYWx1ZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgPSBFTVBUWV9TVFJJTkcsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZyb21TdHJpbmcodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSBpbnB1dE9mZnNldDtcclxuICAgICAgICB3aGlsZSAoaW5wdXRMZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZEJsb2NrID0gbmV3IExvY2FsUmVsYXRpdmVTaWRWYWx1ZUJsb2NrKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdE9mZnNldCA9IHNpZEJsb2NrLmZyb21CRVIoaW5wdXRCdWZmZXIsIHJlc3VsdE9mZnNldCwgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0T2Zmc2V0ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gc2lkQmxvY2suZXJyb3I7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggKz0gc2lkQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgICAgIGlucHV0TGVuZ3RoIC09IHNpZEJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlLnB1c2goc2lkQmxvY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgdG9CRVIoc2l6ZU9ubHksIHdyaXRlcikge1xyXG4gICAgICAgIGNvbnN0IHJldEJ1ZmZlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVCdWYgPSB0aGlzLnZhbHVlW2ldLnRvQkVSKHNpemVPbmx5KTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlQnVmLmJ5dGVMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB0aGlzLnZhbHVlW2ldLmVycm9yO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXRCdWZmZXJzLnB1c2godmFsdWVCdWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29uY2F0KHJldEJ1ZmZlcnMpO1xyXG4gICAgfVxyXG4gICAgZnJvbVN0cmluZyhzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gW107XHJcbiAgICAgICAgbGV0IHBvczEgPSAwO1xyXG4gICAgICAgIGxldCBwb3MyID0gMDtcclxuICAgICAgICBsZXQgc2lkID0gXCJcIjtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHBvczIgPSBzdHJpbmcuaW5kZXhPZihcIi5cIiwgcG9zMSk7XHJcbiAgICAgICAgICAgIGlmIChwb3MyID09PSAtMSlcclxuICAgICAgICAgICAgICAgIHNpZCA9IHN0cmluZy5zdWJzdHJpbmcocG9zMSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHNpZCA9IHN0cmluZy5zdWJzdHJpbmcocG9zMSwgcG9zMik7XHJcbiAgICAgICAgICAgIHBvczEgPSBwb3MyICsgMTtcclxuICAgICAgICAgICAgY29uc3Qgc2lkQmxvY2sgPSBuZXcgTG9jYWxSZWxhdGl2ZVNpZFZhbHVlQmxvY2soKTtcclxuICAgICAgICAgICAgc2lkQmxvY2sudmFsdWVEZWMgPSBwYXJzZUludChzaWQsIDEwKTtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKHNpZEJsb2NrLnZhbHVlRGVjKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlLnB1c2goc2lkQmxvY2spO1xyXG4gICAgICAgIH0gd2hpbGUgKHBvczIgIT09IC0xKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIGxldCBpc0hleE9ubHkgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaXNIZXhPbmx5ID0gdGhpcy52YWx1ZVtpXS5pc0hleE9ubHk7XHJcbiAgICAgICAgICAgIGxldCBzaWRTdHIgPSB0aGlzLnZhbHVlW2ldLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChpICE9PSAwKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fS5gO1xyXG4gICAgICAgICAgICBpZiAoaXNIZXhPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICBzaWRTdHIgPSBgeyR7c2lkU3RyfX1gO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNpZFN0cjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2lkU3RyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHNpZEFycmF5OiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgb2JqZWN0LnNpZEFycmF5LnB1c2godGhpcy52YWx1ZVtpXS50b0pTT04oKSk7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgIH1cclxufVxyXG5Mb2NhbFJlbGF0aXZlT2JqZWN0SWRlbnRpZmllclZhbHVlQmxvY2suTkFNRSA9IFwiUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkbDtcclxuY2xhc3MgUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyIGV4dGVuZHMgQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMsIExvY2FsUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMTM7XHJcbiAgICB9XHJcbiAgICBnZXRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUJsb2NrLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay5mcm9tU3RyaW5nKHZhbHVlKTtcclxuICAgIH1cclxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcclxuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfSA6ICR7dGhpcy52YWx1ZUJsb2NrLnRvU3RyaW5nKCkgfHwgXCJlbXB0eVwifWA7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmdldFZhbHVlKCksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5fYSRsID0gUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLlJlbGF0aXZlT2JqZWN0SWRlbnRpZmllciA9IF9hJGw7XHJcbn0pKCk7XHJcblJlbGF0aXZlT2JqZWN0SWRlbnRpZmllci5OQU1FID0gXCJSZWxhdGl2ZU9iamVjdElkZW50aWZpZXJcIjtcblxudmFyIF9hJGs7XHJcbmNsYXNzIFNlcXVlbmNlIGV4dGVuZHMgQ29uc3RydWN0ZWQge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMTY7XHJcbiAgICB9XHJcbn1cclxuX2EkayA9IFNlcXVlbmNlO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLlNlcXVlbmNlID0gX2EkaztcclxufSkoKTtcclxuU2VxdWVuY2UuTkFNRSA9IFwiU0VRVUVOQ0VcIjtcblxudmFyIF9hJGo7XHJcbmNsYXNzIFNldCBleHRlbmRzIENvbnN0cnVjdGVkIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDE3O1xyXG4gICAgfVxyXG59XHJcbl9hJGogPSBTZXQ7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuU2V0ID0gX2EkajtcclxufSkoKTtcclxuU2V0Lk5BTUUgPSBcIlNFVFwiO1xuXG5jbGFzcyBMb2NhbFN0cmluZ1ZhbHVlQmxvY2sgZXh0ZW5kcyBIZXhCbG9jayhWYWx1ZUJsb2NrKSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pc0hleE9ubHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBFTVBUWV9TVFJJTkc7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuTG9jYWxTdHJpbmdWYWx1ZUJsb2NrLk5BTUUgPSBcIlN0cmluZ1ZhbHVlQmxvY2tcIjtcblxuY2xhc3MgTG9jYWxTaW1wbGVTdHJpbmdWYWx1ZUJsb2NrIGV4dGVuZHMgTG9jYWxTdHJpbmdWYWx1ZUJsb2NrIHtcclxufVxyXG5Mb2NhbFNpbXBsZVN0cmluZ1ZhbHVlQmxvY2suTkFNRSA9IFwiU2ltcGxlU3RyaW5nVmFsdWVCbG9ja1wiO1xuXG5jbGFzcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIGV4dGVuZHMgQmFzZVN0cmluZ0Jsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzLCBMb2NhbFNpbXBsZVN0cmluZ1ZhbHVlQmxvY2spO1xyXG4gICAgfVxyXG4gICAgZnJvbUJ1ZmZlcihpbnB1dEJ1ZmZlcikge1xyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcikpO1xyXG4gICAgfVxyXG4gICAgZnJvbVN0cmluZyhpbnB1dFN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHN0ckxlbiA9IGlucHV0U3RyaW5nLmxlbmd0aDtcclxuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHN0ckxlbik7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJMZW47IGkrKylcclxuICAgICAgICAgICAgdmlld1tpXSA9IGlucHV0U3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gaW5wdXRTdHJpbmc7XHJcbiAgICB9XHJcbn1cclxuTG9jYWxTaW1wbGVTdHJpbmdCbG9jay5OQU1FID0gXCJTSU1QTEUgU1RSSU5HXCI7XG5cbmNsYXNzIExvY2FsVXRmOFN0cmluZ1ZhbHVlQmxvY2sgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcclxuICAgIGZyb21CdWZmZXIoaW5wdXRCdWZmZXIpIHtcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub1V0ZjhTdHJpbmcoaW5wdXRCdWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKGBFcnJvciBkdXJpbmcgXCJkZWNvZGVVUklDb21wb25lbnRcIjogJHtleH0sIHVzaW5nIHJhdyBzdHJpbmdgKTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0JpbmFyeShpbnB1dEJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnJvbVN0cmluZyhpbnB1dFN0cmluZykge1xyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXcgPSBuZXcgVWludDhBcnJheShwdnRzdXRpbHNfX25hbWVzcGFjZS5Db252ZXJ0LkZyb21VdGY4U3RyaW5nKGlucHV0U3RyaW5nKSk7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gaW5wdXRTdHJpbmc7XHJcbiAgICB9XHJcbn1cclxuTG9jYWxVdGY4U3RyaW5nVmFsdWVCbG9jay5OQU1FID0gXCJVdGY4U3RyaW5nVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkaTtcclxuY2xhc3MgVXRmOFN0cmluZyBleHRlbmRzIExvY2FsVXRmOFN0cmluZ1ZhbHVlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMTI7XHJcbiAgICB9XHJcbn1cclxuX2EkaSA9IFV0ZjhTdHJpbmc7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuVXRmOFN0cmluZyA9IF9hJGk7XHJcbn0pKCk7XHJcblV0ZjhTdHJpbmcuTkFNRSA9IFwiVVRGOFN0cmluZ1wiO1xuXG5jbGFzcyBMb2NhbEJtcFN0cmluZ1ZhbHVlQmxvY2sgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcclxuICAgIGZyb21CdWZmZXIoaW5wdXRCdWZmZXIpIHtcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWUgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5Db252ZXJ0LlRvVXRmMTZTdHJpbmcoaW5wdXRCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXcgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGlucHV0QnVmZmVyKTtcclxuICAgIH1cclxuICAgIGZyb21TdHJpbmcoaW5wdXRTdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWUgPSBpbnB1dFN0cmluZztcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkocHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Gcm9tVXRmMTZTdHJpbmcoaW5wdXRTdHJpbmcpKTtcclxuICAgIH1cclxufVxyXG5Mb2NhbEJtcFN0cmluZ1ZhbHVlQmxvY2suTkFNRSA9IFwiQm1wU3RyaW5nVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkaDtcclxuY2xhc3MgQm1wU3RyaW5nIGV4dGVuZHMgTG9jYWxCbXBTdHJpbmdWYWx1ZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAzMDtcclxuICAgIH1cclxufVxyXG5fYSRoID0gQm1wU3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkJtcFN0cmluZyA9IF9hJGg7XHJcbn0pKCk7XHJcbkJtcFN0cmluZy5OQU1FID0gXCJCTVBTdHJpbmdcIjtcblxuY2xhc3MgTG9jYWxVbml2ZXJzYWxTdHJpbmdWYWx1ZUJsb2NrIGV4dGVuZHMgTG9jYWxTaW1wbGVTdHJpbmdCbG9jayB7XHJcbiAgICBmcm9tQnVmZmVyKGlucHV0QnVmZmVyKSB7XHJcbiAgICAgICAgY29uc3QgY29weUJ1ZmZlciA9IEFycmF5QnVmZmVyLmlzVmlldyhpbnB1dEJ1ZmZlcikgPyBpbnB1dEJ1ZmZlci5zbGljZSgpLmJ1ZmZlciA6IGlucHV0QnVmZmVyLnNsaWNlKDApO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlVmlldyA9IG5ldyBVaW50OEFycmF5KGNvcHlCdWZmZXIpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVWaWV3Lmxlbmd0aDsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIHZhbHVlVmlld1tpXSA9IHZhbHVlVmlld1tpICsgM107XHJcbiAgICAgICAgICAgIHZhbHVlVmlld1tpICsgMV0gPSB2YWx1ZVZpZXdbaSArIDJdO1xyXG4gICAgICAgICAgICB2YWx1ZVZpZXdbaSArIDJdID0gMHgwMDtcclxuICAgICAgICAgICAgdmFsdWVWaWV3W2kgKyAzXSA9IDB4MDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQzMkFycmF5KGNvcHlCdWZmZXIpKTtcclxuICAgIH1cclxuICAgIGZyb21TdHJpbmcoaW5wdXRTdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBzdHJMZW5ndGggPSBpbnB1dFN0cmluZy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgdmFsdWVIZXhWaWV3ID0gdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHN0ckxlbmd0aCAqIDQpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY29kZUJ1ZiA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsVG9CYXNlKGlucHV0U3RyaW5nLmNoYXJDb2RlQXQoaSksIDgpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlVmlldyA9IG5ldyBVaW50OEFycmF5KGNvZGVCdWYpO1xyXG4gICAgICAgICAgICBpZiAoY29kZVZpZXcubGVuZ3RoID4gNClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBjb25zdCBkaWYgPSA0IC0gY29kZVZpZXcubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gKGNvZGVWaWV3Lmxlbmd0aCAtIDEpOyBqID49IDA7IGotLSlcclxuICAgICAgICAgICAgICAgIHZhbHVlSGV4Vmlld1tpICogNCArIGogKyBkaWZdID0gY29kZVZpZXdbal07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZSA9IGlucHV0U3RyaW5nO1xyXG4gICAgfVxyXG59XHJcbkxvY2FsVW5pdmVyc2FsU3RyaW5nVmFsdWVCbG9jay5OQU1FID0gXCJVbml2ZXJzYWxTdHJpbmdWYWx1ZUJsb2NrXCI7XG5cbnZhciBfYSRnO1xyXG5jbGFzcyBVbml2ZXJzYWxTdHJpbmcgZXh0ZW5kcyBMb2NhbFVuaXZlcnNhbFN0cmluZ1ZhbHVlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IoeyAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDI4O1xyXG4gICAgfVxyXG59XHJcbl9hJGcgPSBVbml2ZXJzYWxTdHJpbmc7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuVW5pdmVyc2FsU3RyaW5nID0gX2EkZztcclxufSkoKTtcclxuVW5pdmVyc2FsU3RyaW5nLk5BTUUgPSBcIlVuaXZlcnNhbFN0cmluZ1wiO1xuXG52YXIgX2EkZjtcclxuY2xhc3MgTnVtZXJpY1N0cmluZyBleHRlbmRzIExvY2FsU2ltcGxlU3RyaW5nQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMTg7XHJcbiAgICB9XHJcbn1cclxuX2EkZiA9IE51bWVyaWNTdHJpbmc7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuTnVtZXJpY1N0cmluZyA9IF9hJGY7XHJcbn0pKCk7XHJcbk51bWVyaWNTdHJpbmcuTkFNRSA9IFwiTnVtZXJpY1N0cmluZ1wiO1xuXG52YXIgX2EkZTtcclxuY2xhc3MgUHJpbnRhYmxlU3RyaW5nIGV4dGVuZHMgTG9jYWxTaW1wbGVTdHJpbmdCbG9jayB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAxOTtcclxuICAgIH1cclxufVxyXG5fYSRlID0gUHJpbnRhYmxlU3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLlByaW50YWJsZVN0cmluZyA9IF9hJGU7XHJcbn0pKCk7XHJcblByaW50YWJsZVN0cmluZy5OQU1FID0gXCJQcmludGFibGVTdHJpbmdcIjtcblxudmFyIF9hJGQ7XHJcbmNsYXNzIFRlbGV0ZXhTdHJpbmcgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDIwO1xyXG4gICAgfVxyXG59XHJcbl9hJGQgPSBUZWxldGV4U3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLlRlbGV0ZXhTdHJpbmcgPSBfYSRkO1xyXG59KSgpO1xyXG5UZWxldGV4U3RyaW5nLk5BTUUgPSBcIlRlbGV0ZXhTdHJpbmdcIjtcblxudmFyIF9hJGM7XHJcbmNsYXNzIFZpZGVvdGV4U3RyaW5nIGV4dGVuZHMgTG9jYWxTaW1wbGVTdHJpbmdCbG9jayB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAyMTtcclxuICAgIH1cclxufVxyXG5fYSRjID0gVmlkZW90ZXhTdHJpbmc7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuVmlkZW90ZXhTdHJpbmcgPSBfYSRjO1xyXG59KSgpO1xyXG5WaWRlb3RleFN0cmluZy5OQU1FID0gXCJWaWRlb3RleFN0cmluZ1wiO1xuXG52YXIgX2EkYjtcclxuY2xhc3MgSUE1U3RyaW5nIGV4dGVuZHMgTG9jYWxTaW1wbGVTdHJpbmdCbG9jayB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAyMjtcclxuICAgIH1cclxufVxyXG5fYSRiID0gSUE1U3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLklBNVN0cmluZyA9IF9hJGI7XHJcbn0pKCk7XHJcbklBNVN0cmluZy5OQU1FID0gXCJJQTVTdHJpbmdcIjtcblxudmFyIF9hJGE7XHJcbmNsYXNzIEdyYXBoaWNTdHJpbmcgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDI1O1xyXG4gICAgfVxyXG59XHJcbl9hJGEgPSBHcmFwaGljU3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkdyYXBoaWNTdHJpbmcgPSBfYSRhO1xyXG59KSgpO1xyXG5HcmFwaGljU3RyaW5nLk5BTUUgPSBcIkdyYXBoaWNTdHJpbmdcIjtcblxudmFyIF9hJDk7XHJcbmNsYXNzIFZpc2libGVTdHJpbmcgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDI2O1xyXG4gICAgfVxyXG59XHJcbl9hJDkgPSBWaXNpYmxlU3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLlZpc2libGVTdHJpbmcgPSBfYSQ5O1xyXG59KSgpO1xyXG5WaXNpYmxlU3RyaW5nLk5BTUUgPSBcIlZpc2libGVTdHJpbmdcIjtcblxudmFyIF9hJDg7XHJcbmNsYXNzIEdlbmVyYWxTdHJpbmcgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDI3O1xyXG4gICAgfVxyXG59XHJcbl9hJDggPSBHZW5lcmFsU3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkdlbmVyYWxTdHJpbmcgPSBfYSQ4O1xyXG59KSgpO1xyXG5HZW5lcmFsU3RyaW5nLk5BTUUgPSBcIkdlbmVyYWxTdHJpbmdcIjtcblxudmFyIF9hJDc7XHJcbmNsYXNzIENoYXJhY3RlclN0cmluZyBleHRlbmRzIExvY2FsU2ltcGxlU3RyaW5nQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMjk7XHJcbiAgICB9XHJcbn1cclxuX2EkNyA9IENoYXJhY3RlclN0cmluZztcclxuKCgpID0+IHtcclxuICAgIHR5cGVTdG9yZS5DaGFyYWN0ZXJTdHJpbmcgPSBfYSQ3O1xyXG59KSgpO1xyXG5DaGFyYWN0ZXJTdHJpbmcuTkFNRSA9IFwiQ2hhcmFjdGVyU3RyaW5nXCI7XG5cbnZhciBfYSQ2O1xyXG5jbGFzcyBVVENUaW1lIGV4dGVuZHMgVmlzaWJsZVN0cmluZyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCB2YWx1ZURhdGUsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy55ZWFyID0gMDtcclxuICAgICAgICB0aGlzLm1vbnRoID0gMDtcclxuICAgICAgICB0aGlzLmRheSA9IDA7XHJcbiAgICAgICAgdGhpcy5ob3VyID0gMDtcclxuICAgICAgICB0aGlzLm1pbnV0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5zZWNvbmQgPSAwO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZyb21TdHJpbmcodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXdbaV0gPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWVEYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbURhdGUodmFsdWVEYXRlKTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMudG9CdWZmZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDIzO1xyXG4gICAgfVxyXG4gICAgZnJvbUJ1ZmZlcihpbnB1dEJ1ZmZlcikge1xyXG4gICAgICAgIHRoaXMuZnJvbVN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpKSk7XHJcbiAgICB9XHJcbiAgICB0b0J1ZmZlcigpIHtcclxuICAgICAgICBjb25zdCBzdHIgPSB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHN0ci5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB2aWV3W2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGZyb21EYXRlKGlucHV0RGF0ZSkge1xyXG4gICAgICAgIHRoaXMueWVhciA9IGlucHV0RGF0ZS5nZXRVVENGdWxsWWVhcigpO1xyXG4gICAgICAgIHRoaXMubW9udGggPSBpbnB1dERhdGUuZ2V0VVRDTW9udGgoKSArIDE7XHJcbiAgICAgICAgdGhpcy5kYXkgPSBpbnB1dERhdGUuZ2V0VVRDRGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuaG91ciA9IGlucHV0RGF0ZS5nZXRVVENIb3VycygpO1xyXG4gICAgICAgIHRoaXMubWludXRlID0gaW5wdXREYXRlLmdldFVUQ01pbnV0ZXMoKTtcclxuICAgICAgICB0aGlzLnNlY29uZCA9IGlucHV0RGF0ZS5nZXRVVENTZWNvbmRzKCk7XHJcbiAgICB9XHJcbiAgICB0b0RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIChuZXcgRGF0ZShEYXRlLlVUQyh0aGlzLnllYXIsIHRoaXMubW9udGggLSAxLCB0aGlzLmRheSwgdGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQpKSk7XHJcbiAgICB9XHJcbiAgICBmcm9tU3RyaW5nKGlucHV0U3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VyID0gLyhcXGR7Mn0pKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pKFxcZHsyfSkoXFxkezJ9KVovaWc7XHJcbiAgICAgICAgY29uc3QgcGFyc2VyQXJyYXkgPSBwYXJzZXIuZXhlYyhpbnB1dFN0cmluZyk7XHJcbiAgICAgICAgaWYgKHBhcnNlckFycmF5ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIldyb25nIGlucHV0IHN0cmluZyBmb3IgY29udmVyc2lvblwiO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChwYXJzZXJBcnJheVsxXSwgMTApO1xyXG4gICAgICAgIGlmICh5ZWFyID49IDUwKVxyXG4gICAgICAgICAgICB0aGlzLnllYXIgPSAxOTAwICsgeWVhcjtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMueWVhciA9IDIwMDAgKyB5ZWFyO1xyXG4gICAgICAgIHRoaXMubW9udGggPSBwYXJzZUludChwYXJzZXJBcnJheVsyXSwgMTApO1xyXG4gICAgICAgIHRoaXMuZGF5ID0gcGFyc2VJbnQocGFyc2VyQXJyYXlbM10sIDEwKTtcclxuICAgICAgICB0aGlzLmhvdXIgPSBwYXJzZUludChwYXJzZXJBcnJheVs0XSwgMTApO1xyXG4gICAgICAgIHRoaXMubWludXRlID0gcGFyc2VJbnQocGFyc2VyQXJyYXlbNV0sIDEwKTtcclxuICAgICAgICB0aGlzLnNlY29uZCA9IHBhcnNlSW50KHBhcnNlckFycmF5WzZdLCAxMCk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZyhlbmNvZGluZyA9IFwiaXNvXCIpIHtcclxuICAgICAgICBpZiAoZW5jb2RpbmcgPT09IFwiaXNvXCIpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3V0cHV0QXJyYXkgPSBuZXcgQXJyYXkoNyk7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5WzBdID0gcHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcigoKHRoaXMueWVhciA8IDIwMDApID8gKHRoaXMueWVhciAtIDE5MDApIDogKHRoaXMueWVhciAtIDIwMDApKSwgMik7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5WzFdID0gcHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLm1vbnRoLCAyKTtcclxuICAgICAgICAgICAgb3V0cHV0QXJyYXlbMl0gPSBwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMuZGF5LCAyKTtcclxuICAgICAgICAgICAgb3V0cHV0QXJyYXlbM10gPSBwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMuaG91ciwgMik7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5WzRdID0gcHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLm1pbnV0ZSwgMik7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5WzVdID0gcHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLnNlY29uZCwgMik7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5WzZdID0gXCJaXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRBcnJheS5qb2luKFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VwZXIudG9TdHJpbmcoZW5jb2RpbmcpO1xyXG4gICAgfVxyXG4gICAgb25Bc2NpaUVuY29kaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9IDogJHt0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YDtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgeWVhcjogdGhpcy55ZWFyLFxyXG4gICAgICAgICAgICBtb250aDogdGhpcy5tb250aCxcclxuICAgICAgICAgICAgZGF5OiB0aGlzLmRheSxcclxuICAgICAgICAgICAgaG91cjogdGhpcy5ob3VyLFxyXG4gICAgICAgICAgICBtaW51dGU6IHRoaXMubWludXRlLFxyXG4gICAgICAgICAgICBzZWNvbmQ6IHRoaXMuc2Vjb25kLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuX2EkNiA9IFVUQ1RpbWU7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuVVRDVGltZSA9IF9hJDY7XHJcbn0pKCk7XHJcblVUQ1RpbWUuTkFNRSA9IFwiVVRDVGltZVwiO1xuXG52YXIgX2EkNTtcclxuY2xhc3MgR2VuZXJhbGl6ZWRUaW1lIGV4dGVuZHMgVVRDVGltZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcclxuICAgICAgICB2YXIgX2I7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgKF9iID0gdGhpcy5taWxsaXNlY29uZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKHRoaXMubWlsbGlzZWNvbmQgPSAwKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAyNDtcclxuICAgIH1cclxuICAgIGZyb21EYXRlKGlucHV0RGF0ZSkge1xyXG4gICAgICAgIHN1cGVyLmZyb21EYXRlKGlucHV0RGF0ZSk7XHJcbiAgICAgICAgdGhpcy5taWxsaXNlY29uZCA9IGlucHV0RGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcclxuICAgIH1cclxuICAgIHRvRGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gKG5ldyBEYXRlKERhdGUuVVRDKHRoaXMueWVhciwgdGhpcy5tb250aCAtIDEsIHRoaXMuZGF5LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5taWxsaXNlY29uZCkpKTtcclxuICAgIH1cclxuICAgIGZyb21TdHJpbmcoaW5wdXRTdHJpbmcpIHtcclxuICAgICAgICBsZXQgaXNVVEMgPSBmYWxzZTtcclxuICAgICAgICBsZXQgdGltZVN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgbGV0IGRhdGVUaW1lU3RyaW5nID0gXCJcIjtcclxuICAgICAgICBsZXQgZnJhY3Rpb25QYXJ0ID0gMDtcclxuICAgICAgICBsZXQgcGFyc2VyO1xyXG4gICAgICAgIGxldCBob3VyRGlmZmVyZW5jZSA9IDA7XHJcbiAgICAgICAgbGV0IG1pbnV0ZURpZmZlcmVuY2UgPSAwO1xyXG4gICAgICAgIGlmIChpbnB1dFN0cmluZ1tpbnB1dFN0cmluZy5sZW5ndGggLSAxXSA9PT0gXCJaXCIpIHtcclxuICAgICAgICAgICAgdGltZVN0cmluZyA9IGlucHV0U3RyaW5nLnN1YnN0cmluZygwLCBpbnB1dFN0cmluZy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgaXNVVEMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgbnVtYmVyID0gbmV3IE51bWJlcihpbnB1dFN0cmluZ1tpbnB1dFN0cmluZy5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihudW1iZXIudmFsdWVPZigpKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGlucHV0IHN0cmluZyBmb3IgY29udmVyc2lvblwiKTtcclxuICAgICAgICAgICAgdGltZVN0cmluZyA9IGlucHV0U3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNVVEMpIHtcclxuICAgICAgICAgICAgaWYgKHRpbWVTdHJpbmcuaW5kZXhPZihcIitcIikgIT09IC0xKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xyXG4gICAgICAgICAgICBpZiAodGltZVN0cmluZy5pbmRleE9mKFwiLVwiKSAhPT0gLTEpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBpbnB1dCBzdHJpbmcgZm9yIGNvbnZlcnNpb25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgbXVsdGlwbGllciA9IDE7XHJcbiAgICAgICAgICAgIGxldCBkaWZmZXJlbmNlUG9zaXRpb24gPSB0aW1lU3RyaW5nLmluZGV4T2YoXCIrXCIpO1xyXG4gICAgICAgICAgICBsZXQgZGlmZmVyZW5jZVN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlUG9zaXRpb24gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlUG9zaXRpb24gPSB0aW1lU3RyaW5nLmluZGV4T2YoXCItXCIpO1xyXG4gICAgICAgICAgICAgICAgbXVsdGlwbGllciA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlUG9zaXRpb24gIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlU3RyaW5nID0gdGltZVN0cmluZy5zdWJzdHJpbmcoZGlmZmVyZW5jZVBvc2l0aW9uICsgMSk7XHJcbiAgICAgICAgICAgICAgICB0aW1lU3RyaW5nID0gdGltZVN0cmluZy5zdWJzdHJpbmcoMCwgZGlmZmVyZW5jZVBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICgoZGlmZmVyZW5jZVN0cmluZy5sZW5ndGggIT09IDIpICYmIChkaWZmZXJlbmNlU3RyaW5nLmxlbmd0aCAhPT0gNCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG51bWJlciA9IHBhcnNlSW50KGRpZmZlcmVuY2VTdHJpbmcuc3Vic3RyaW5nKDAsIDIpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4obnVtYmVyLnZhbHVlT2YoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgaG91ckRpZmZlcmVuY2UgPSBtdWx0aXBsaWVyICogbnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2VTdHJpbmcubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyID0gcGFyc2VJbnQoZGlmZmVyZW5jZVN0cmluZy5zdWJzdHJpbmcoMiwgNCksIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4obnVtYmVyLnZhbHVlT2YoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGlucHV0IHN0cmluZyBmb3IgY29udmVyc2lvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICBtaW51dGVEaWZmZXJlbmNlID0gbXVsdGlwbGllciAqIG51bWJlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZnJhY3Rpb25Qb2ludFBvc2l0aW9uID0gdGltZVN0cmluZy5pbmRleE9mKFwiLlwiKTtcclxuICAgICAgICBpZiAoZnJhY3Rpb25Qb2ludFBvc2l0aW9uID09PSAtMSlcclxuICAgICAgICAgICAgZnJhY3Rpb25Qb2ludFBvc2l0aW9uID0gdGltZVN0cmluZy5pbmRleE9mKFwiLFwiKTtcclxuICAgICAgICBpZiAoZnJhY3Rpb25Qb2ludFBvc2l0aW9uICE9PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCBmcmFjdGlvblBhcnRDaGVjayA9IG5ldyBOdW1iZXIoYDAke3RpbWVTdHJpbmcuc3Vic3RyaW5nKGZyYWN0aW9uUG9pbnRQb3NpdGlvbil9YCk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihmcmFjdGlvblBhcnRDaGVjay52YWx1ZU9mKCkpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xyXG4gICAgICAgICAgICBmcmFjdGlvblBhcnQgPSBmcmFjdGlvblBhcnRDaGVjay52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIGRhdGVUaW1lU3RyaW5nID0gdGltZVN0cmluZy5zdWJzdHJpbmcoMCwgZnJhY3Rpb25Qb2ludFBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBkYXRlVGltZVN0cmluZyA9IHRpbWVTdHJpbmc7XHJcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgKGRhdGVUaW1lU3RyaW5nLmxlbmd0aCA9PT0gOCk6XHJcbiAgICAgICAgICAgICAgICBwYXJzZXIgPSAvKFxcZHs0fSkoXFxkezJ9KShcXGR7Mn0pL2lnO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyYWN0aW9uUG9pbnRQb3NpdGlvbiAhPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgKGRhdGVUaW1lU3RyaW5nLmxlbmd0aCA9PT0gMTApOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VyID0gLyhcXGR7NH0pKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pL2lnO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyYWN0aW9uUG9pbnRQb3NpdGlvbiAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZnJhY3Rpb25SZXN1bHQgPSA2MCAqIGZyYWN0aW9uUGFydDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZSA9IE1hdGguZmxvb3IoZnJhY3Rpb25SZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uUmVzdWx0ID0gNjAgKiAoZnJhY3Rpb25SZXN1bHQgLSB0aGlzLm1pbnV0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWNvbmQgPSBNYXRoLmZsb29yKGZyYWN0aW9uUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICBmcmFjdGlvblJlc3VsdCA9IDEwMDAgKiAoZnJhY3Rpb25SZXN1bHQgLSB0aGlzLnNlY29uZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZCA9IE1hdGguZmxvb3IoZnJhY3Rpb25SZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgKGRhdGVUaW1lU3RyaW5nLmxlbmd0aCA9PT0gMTIpOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VyID0gLyhcXGR7NH0pKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pKFxcZHsyfSkvaWc7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJhY3Rpb25Qb2ludFBvc2l0aW9uICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmcmFjdGlvblJlc3VsdCA9IDYwICogZnJhY3Rpb25QYXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kID0gTWF0aC5mbG9vcihmcmFjdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhY3Rpb25SZXN1bHQgPSAxMDAwICogKGZyYWN0aW9uUmVzdWx0IC0gdGhpcy5zZWNvbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmQgPSBNYXRoLmZsb29yKGZyYWN0aW9uUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIChkYXRlVGltZVN0cmluZy5sZW5ndGggPT09IDE0KTpcclxuICAgICAgICAgICAgICAgIHBhcnNlciA9IC8oXFxkezR9KShcXGR7Mn0pKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pKFxcZHsyfSkvaWc7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJhY3Rpb25Qb2ludFBvc2l0aW9uICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYWN0aW9uUmVzdWx0ID0gMTAwMCAqIGZyYWN0aW9uUGFydDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kID0gTWF0aC5mbG9vcihmcmFjdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGlucHV0IHN0cmluZyBmb3IgY29udmVyc2lvblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyc2VyQXJyYXkgPSBwYXJzZXIuZXhlYyhkYXRlVGltZVN0cmluZyk7XHJcbiAgICAgICAgaWYgKHBhcnNlckFycmF5ID09PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBpbnB1dCBzdHJpbmcgZm9yIGNvbnZlcnNpb25cIik7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwYXJzZXJBcnJheS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIgPSBwYXJzZUludChwYXJzZXJBcnJheVtqXSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGggPSBwYXJzZUludChwYXJzZXJBcnJheVtqXSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF5ID0gcGFyc2VJbnQocGFyc2VyQXJyYXlbal0sIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdXIgPSBwYXJzZUludChwYXJzZXJBcnJheVtqXSwgMTApICsgaG91ckRpZmZlcmVuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW51dGUgPSBwYXJzZUludChwYXJzZXJBcnJheVtqXSwgMTApICsgbWludXRlRGlmZmVyZW5jZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlY29uZCA9IHBhcnNlSW50KHBhcnNlckFycmF5W2pdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGlucHV0IHN0cmluZyBmb3IgY29udmVyc2lvblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNVVEMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXBEYXRlID0gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSwgdGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQsIHRoaXMubWlsbGlzZWNvbmQpO1xyXG4gICAgICAgICAgICB0aGlzLnllYXIgPSB0ZW1wRGF0ZS5nZXRVVENGdWxsWWVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLm1vbnRoID0gdGVtcERhdGUuZ2V0VVRDTW9udGgoKTtcclxuICAgICAgICAgICAgdGhpcy5kYXkgPSB0ZW1wRGF0ZS5nZXRVVENEYXkoKTtcclxuICAgICAgICAgICAgdGhpcy5ob3VyID0gdGVtcERhdGUuZ2V0VVRDSG91cnMoKTtcclxuICAgICAgICAgICAgdGhpcy5taW51dGUgPSB0ZW1wRGF0ZS5nZXRVVENNaW51dGVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kID0gdGVtcERhdGUuZ2V0VVRDU2Vjb25kcygpO1xyXG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kID0gdGVtcERhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoZW5jb2RpbmcgPSBcImlzb1wiKSB7XHJcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSBcImlzb1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEFycmF5ID0gW107XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gocHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLnllYXIsIDQpKTtcclxuICAgICAgICAgICAgb3V0cHV0QXJyYXkucHVzaChwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMubW9udGgsIDIpKTtcclxuICAgICAgICAgICAgb3V0cHV0QXJyYXkucHVzaChwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMuZGF5LCAyKSk7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gocHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLmhvdXIsIDIpKTtcclxuICAgICAgICAgICAgb3V0cHV0QXJyYXkucHVzaChwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMubWludXRlLCAyKSk7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gocHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLnNlY29uZCwgMikpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5taWxsaXNlY29uZCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0QXJyYXkucHVzaChcIi5cIik7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXRBcnJheS5wdXNoKHB2dXRpbHNfX25hbWVzcGFjZS5wYWROdW1iZXIodGhpcy5taWxsaXNlY29uZCwgMykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2goXCJaXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0QXJyYXkuam9pbihcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLnRvU3RyaW5nKGVuY29kaW5nKTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmQ6IHRoaXMubWlsbGlzZWNvbmQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5fYSQ1ID0gR2VuZXJhbGl6ZWRUaW1lO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkdlbmVyYWxpemVkVGltZSA9IF9hJDU7XHJcbn0pKCk7XHJcbkdlbmVyYWxpemVkVGltZS5OQU1FID0gXCJHZW5lcmFsaXplZFRpbWVcIjtcblxudmFyIF9hJDQ7XHJcbmNsYXNzIERBVEUgZXh0ZW5kcyBVdGY4U3RyaW5nIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDMxO1xyXG4gICAgfVxyXG59XHJcbl9hJDQgPSBEQVRFO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkRBVEUgPSBfYSQ0O1xyXG59KSgpO1xyXG5EQVRFLk5BTUUgPSBcIkRBVEVcIjtcblxudmFyIF9hJDM7XHJcbmNsYXNzIFRpbWVPZkRheSBleHRlbmRzIFV0ZjhTdHJpbmcge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMzI7XHJcbiAgICB9XHJcbn1cclxuX2EkMyA9IFRpbWVPZkRheTtcclxuKCgpID0+IHtcclxuICAgIHR5cGVTdG9yZS5UaW1lT2ZEYXkgPSBfYSQzO1xyXG59KSgpO1xyXG5UaW1lT2ZEYXkuTkFNRSA9IFwiVGltZU9mRGF5XCI7XG5cbnZhciBfYSQyO1xyXG5jbGFzcyBEYXRlVGltZSBleHRlbmRzIFV0ZjhTdHJpbmcge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMzM7XHJcbiAgICB9XHJcbn1cclxuX2EkMiA9IERhdGVUaW1lO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkRhdGVUaW1lID0gX2EkMjtcclxufSkoKTtcclxuRGF0ZVRpbWUuTkFNRSA9IFwiRGF0ZVRpbWVcIjtcblxudmFyIF9hJDE7XHJcbmNsYXNzIER1cmF0aW9uIGV4dGVuZHMgVXRmOFN0cmluZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAzNDtcclxuICAgIH1cclxufVxyXG5fYSQxID0gRHVyYXRpb247XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuRHVyYXRpb24gPSBfYSQxO1xyXG59KSgpO1xyXG5EdXJhdGlvbi5OQU1FID0gXCJEdXJhdGlvblwiO1xuXG52YXIgX2E7XHJcbmNsYXNzIFRJTUUgZXh0ZW5kcyBVdGY4U3RyaW5nIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDE0O1xyXG4gICAgfVxyXG59XHJcbl9hID0gVElNRTtcclxuKCgpID0+IHtcclxuICAgIHR5cGVTdG9yZS5USU1FID0gX2E7XHJcbn0pKCk7XHJcblRJTUUuTkFNRSA9IFwiVElNRVwiO1xuXG5jbGFzcyBBbnkge1xyXG4gICAgY29uc3RydWN0b3IoeyBuYW1lID0gRU1QVFlfU1RSSU5HLCBvcHRpb25hbCA9IGZhbHNlLCB9ID0ge30pIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSBvcHRpb25hbDtcclxuICAgIH1cclxufVxuXG5jbGFzcyBDaG9pY2UgZXh0ZW5kcyBBbnkge1xyXG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSA9IFtdLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBSZXBlYXRlZCBleHRlbmRzIEFueSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlID0gbmV3IEFueSgpLCBsb2NhbCA9IGZhbHNlLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUmF3RGF0YSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IGRhdGEgPSBFTVBUWV9WSUVXIH0gPSB7fSkge1xyXG4gICAgICAgIHRoaXMuZGF0YVZpZXcgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZpZXcuc2xpY2UoKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgZGF0YSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuZGF0YVZpZXcgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGVuZExlbmd0aCA9IGlucHV0T2Zmc2V0ICsgaW5wdXRMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5kYXRhVmlldyA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpLnN1YmFycmF5KGlucHV0T2Zmc2V0LCBlbmRMZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBlbmRMZW5ndGg7XHJcbiAgICB9XHJcbiAgICB0b0JFUihzaXplT25seSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFWaWV3LnNsaWNlKCkuYnVmZmVyO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVTY2hlbWEocm9vdCwgaW5wdXREYXRhLCBpbnB1dFNjaGVtYSkge1xyXG4gICAgaWYgKGlucHV0U2NoZW1hIGluc3RhbmNlb2YgQ2hvaWNlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbnB1dFNjaGVtYS52YWx1ZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJlU2NoZW1hKHJvb3QsIGlucHV0RGF0YSwgaW5wdXRTY2hlbWEudmFsdWVbal0pO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LnZlcmlmaWVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcmlmaWVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcm9vdFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IF9yZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogXCJXcm9uZyB2YWx1ZXMgZm9yIENob2ljZSB0eXBlXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5oYXNPd25Qcm9wZXJ0eShOQU1FKSlcclxuICAgICAgICAgICAgICAgIF9yZXN1bHQubmFtZSA9IGlucHV0U2NoZW1hLm5hbWU7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpbnB1dFNjaGVtYSBpbnN0YW5jZW9mIEFueSkge1xyXG4gICAgICAgIGlmIChpbnB1dFNjaGVtYS5oYXNPd25Qcm9wZXJ0eShOQU1FKSlcclxuICAgICAgICAgICAgcm9vdFtpbnB1dFNjaGVtYS5uYW1lXSA9IGlucHV0RGF0YTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogdHJ1ZSxcclxuICAgICAgICAgICAgcmVzdWx0OiByb290XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICgocm9vdCBpbnN0YW5jZW9mIE9iamVjdCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHsgZXJyb3I6IFwiV3Jvbmcgcm9vdCBvYmplY3RcIiB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICgoaW5wdXREYXRhIGluc3RhbmNlb2YgT2JqZWN0KSA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJXcm9uZyBBU04uMSBkYXRhXCIgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoKGlucHV0U2NoZW1hIGluc3RhbmNlb2YgT2JqZWN0KSA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJXcm9uZyBBU04uMSBzY2hlbWFcIiB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICgoSURfQkxPQ0sgaW4gaW5wdXRTY2hlbWEpID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVzdWx0OiB7IGVycm9yOiBcIldyb25nIEFTTi4xIHNjaGVtYVwiIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKChGUk9NX0JFUiBpbiBpbnB1dFNjaGVtYS5pZEJsb2NrKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJXcm9uZyBBU04uMSBzY2hlbWFcIiB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICgoVE9fQkVSIGluIGlucHV0U2NoZW1hLmlkQmxvY2spID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVzdWx0OiB7IGVycm9yOiBcIldyb25nIEFTTi4xIHNjaGVtYVwiIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgZW5jb2RlZElkID0gaW5wdXRTY2hlbWEuaWRCbG9jay50b0JFUihmYWxzZSk7XHJcbiAgICBpZiAoZW5jb2RlZElkLmJ5dGVMZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJFcnJvciBlbmNvZGluZyBpZEJsb2NrIGZvciBBU04uMSBzY2hlbWFcIiB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlY29kZWRPZmZzZXQgPSBpbnB1dFNjaGVtYS5pZEJsb2NrLmZyb21CRVIoZW5jb2RlZElkLCAwLCBlbmNvZGVkSWQuYnl0ZUxlbmd0aCk7XHJcbiAgICBpZiAoZGVjb2RlZE9mZnNldCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJFcnJvciBkZWNvZGluZyBpZEJsb2NrIGZvciBBU04uMSBzY2hlbWFcIiB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChpbnB1dFNjaGVtYS5pZEJsb2NrLmhhc093blByb3BlcnR5KFRBR19DTEFTUykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHsgZXJyb3I6IFwiV3JvbmcgQVNOLjEgc2NoZW1hXCIgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRTY2hlbWEuaWRCbG9jay50YWdDbGFzcyAhPT0gaW5wdXREYXRhLmlkQmxvY2sudGFnQ2xhc3MpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogcm9vdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRTY2hlbWEuaWRCbG9jay5oYXNPd25Qcm9wZXJ0eShUQUdfTlVNQkVSKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJXcm9uZyBBU04uMSBzY2hlbWFcIiB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChpbnB1dFNjaGVtYS5pZEJsb2NrLnRhZ051bWJlciAhPT0gaW5wdXREYXRhLmlkQmxvY2sudGFnTnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHJvb3RcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGlucHV0U2NoZW1hLmlkQmxvY2suaGFzT3duUHJvcGVydHkoSVNfQ09OU1RSVUNURUQpID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVzdWx0OiB7IGVycm9yOiBcIldyb25nIEFTTi4xIHNjaGVtYVwiIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGlucHV0U2NoZW1hLmlkQmxvY2suaXNDb25zdHJ1Y3RlZCAhPT0gaW5wdXREYXRhLmlkQmxvY2suaXNDb25zdHJ1Y3RlZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVzdWx0OiByb290XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICghKElTX0hFWF9PTkxZIGluIGlucHV0U2NoZW1hLmlkQmxvY2spKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHsgZXJyb3I6IFwiV3JvbmcgQVNOLjEgc2NoZW1hXCIgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRTY2hlbWEuaWRCbG9jay5pc0hleE9ubHkgIT09IGlucHV0RGF0YS5pZEJsb2NrLmlzSGV4T25seSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVzdWx0OiByb290XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChpbnB1dFNjaGVtYS5pZEJsb2NrLmlzSGV4T25seSkge1xyXG4gICAgICAgIGlmICgoVkFMVUVfSEVYX1ZJRVcgaW4gaW5wdXRTY2hlbWEuaWRCbG9jaykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHsgZXJyb3I6IFwiV3JvbmcgQVNOLjEgc2NoZW1hXCIgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzY2hlbWFWaWV3ID0gaW5wdXRTY2hlbWEuaWRCbG9jay52YWx1ZUhleFZpZXc7XHJcbiAgICAgICAgY29uc3QgYXNuMVZpZXcgPSBpbnB1dERhdGEuaWRCbG9jay52YWx1ZUhleFZpZXc7XHJcbiAgICAgICAgaWYgKHNjaGVtYVZpZXcubGVuZ3RoICE9PSBhc24xVmlldy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHJlc3VsdDogcm9vdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYVZpZXcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHNjaGVtYVZpZXdbaV0gIT09IGFzbjFWaWV3WzFdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJvb3RcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRTY2hlbWEubmFtZSkge1xyXG4gICAgICAgIGlucHV0U2NoZW1hLm5hbWUgPSBpbnB1dFNjaGVtYS5uYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csIEVNUFRZX1NUUklORyk7XHJcbiAgICAgICAgaWYgKGlucHV0U2NoZW1hLm5hbWUpXHJcbiAgICAgICAgICAgIHJvb3RbaW5wdXRTY2hlbWEubmFtZV0gPSBpbnB1dERhdGE7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRTY2hlbWEgaW5zdGFuY2VvZiB0eXBlU3RvcmUuQ29uc3RydWN0ZWQpIHtcclxuICAgICAgICBsZXQgYWRtaXNzaW9uID0gMDtcclxuICAgICAgICBsZXQgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDoge1xyXG4gICAgICAgICAgICAgICAgZXJyb3I6IFwiVW5rbm93biBlcnJvclwiLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgbWF4TGVuZ3RoID0gaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKG1heExlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbMF0gaW5zdGFuY2VvZiBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoID0gaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXhMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZlcmlmaWVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0OiByb290XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWUubGVuZ3RoID09PSAwKSAmJlxyXG4gICAgICAgICAgICAoaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZS5sZW5ndGggIT09IDApKSB7XHJcbiAgICAgICAgICAgIGxldCBfb3B0aW9uYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICBfb3B0aW9uYWwgPSBfb3B0aW9uYWwgJiYgKGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbaV0ub3B0aW9uYWwgfHwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoX29wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcmlmaWVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcm9vdFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaW5wdXRTY2hlbWEubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXRTY2hlbWEubmFtZSA9IGlucHV0U2NoZW1hLm5hbWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgRU1QVFlfU1RSSU5HKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByb290W2lucHV0U2NoZW1hLm5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvb3QuZXJyb3IgPSBcIkluY29uc2lzdGVudCBvYmplY3QgbGVuZ3RoXCI7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJvb3RcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoKGkgLSBhZG1pc3Npb24pID49IGlucHV0RGF0YS52YWx1ZUJsb2NrLnZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbaV0ub3B0aW9uYWwgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgX3Jlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJvb3RcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZXJyb3IgPSBcIkluY29uc2lzdGVudCBsZW5ndGggYmV0d2VlbiBBU04uMSBkYXRhIGFuZCBzY2hlbWFcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRTY2hlbWEubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYS5uYW1lID0gaW5wdXRTY2hlbWEubmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBFTVBUWV9TVFJJTkcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRTY2hlbWEubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJvb3RbaW5wdXRTY2hlbWEubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0Lm5hbWUgPSBpbnB1dFNjaGVtYS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbMF0gaW5zdGFuY2VvZiBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBhcmVTY2hlbWEocm9vdCwgaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWVbaV0sIGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbMF0udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmVyaWZpZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLm9wdGlvbmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRtaXNzaW9uKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYS5uYW1lID0gaW5wdXRTY2hlbWEubmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBFTVBUWV9TVFJJTkcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcm9vdFtpbnB1dFNjaGVtYS5uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChOQU1FIGluIGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbMF0pICYmIChpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLm5hbWUubGVuZ3RoID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFycmF5Um9vdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKExPQ0FMIGluIGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbMF0pICYmIChpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLmxvY2FsKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Um9vdCA9IGlucHV0RGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlSb290ID0gcm9vdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcnJheVJvb3RbaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZVswXS5uYW1lXSA9PT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Um9vdFtpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLm5hbWVdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Um9vdFtpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLm5hbWVdLnB1c2goaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBhcmVTY2hlbWEocm9vdCwgaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWVbaSAtIGFkbWlzc2lvbl0sIGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmVyaWZpZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlW2ldLm9wdGlvbmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRtaXNzaW9uKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYS5uYW1lID0gaW5wdXRTY2hlbWEubmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBFTVBUWV9TVFJJTkcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcm9vdFtpbnB1dFNjaGVtYS5uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdC52ZXJpZmllZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgY29uc3QgX3Jlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHJlc3VsdDogcm9vdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoaW5wdXRTY2hlbWEubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXRTY2hlbWEubmFtZSA9IGlucHV0U2NoZW1hLm5hbWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgRU1QVFlfU1RSSU5HKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJvb3RbaW5wdXRTY2hlbWEubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdC5uYW1lID0gaW5wdXRTY2hlbWEubmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVyaWZpZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIHJlc3VsdDogcm9vdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRTY2hlbWEucHJpbWl0aXZlU2NoZW1hICYmXHJcbiAgICAgICAgKFZBTFVFX0hFWF9WSUVXIGluIGlucHV0RGF0YS52YWx1ZUJsb2NrKSkge1xyXG4gICAgICAgIGNvbnN0IGFzbjEgPSBsb2NhbEZyb21CRVIoaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3KTtcclxuICAgICAgICBpZiAoYXNuMS5vZmZzZXQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IF9yZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGFzbjEucmVzdWx0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYS5uYW1lID0gaW5wdXRTY2hlbWEubmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBFTVBUWV9TVFJJTkcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcm9vdFtpbnB1dFNjaGVtYS5uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBfcmVzdWx0Lm5hbWUgPSBpbnB1dFNjaGVtYS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcGFyZVNjaGVtYShyb290LCBhc24xLnJlc3VsdCwgaW5wdXRTY2hlbWEucHJpbWl0aXZlU2NoZW1hKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmVyaWZpZWQ6IHRydWUsXHJcbiAgICAgICAgcmVzdWx0OiByb290XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHZlcmlmeVNjaGVtYShpbnB1dEJ1ZmZlciwgaW5wdXRTY2hlbWEpIHtcclxuICAgIGlmICgoaW5wdXRTY2hlbWEgaW5zdGFuY2VvZiBPYmplY3QpID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVzdWx0OiB7IGVycm9yOiBcIldyb25nIEFTTi4xIHNjaGVtYSB0eXBlXCIgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBhc24xID0gbG9jYWxGcm9tQkVSKHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpKTtcclxuICAgIGlmIChhc24xLm9mZnNldCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogYXNuMS5yZXN1bHRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBhcmVTY2hlbWEoYXNuMS5yZXN1bHQsIGFzbjEucmVzdWx0LCBpbnB1dFNjaGVtYSk7XHJcbn1cblxuZXhwb3J0cy5BbnkgPSBBbnk7XG5leHBvcnRzLkJhc2VCbG9jayA9IEJhc2VCbG9jaztcbmV4cG9ydHMuQmFzZVN0cmluZ0Jsb2NrID0gQmFzZVN0cmluZ0Jsb2NrO1xuZXhwb3J0cy5CaXRTdHJpbmcgPSBCaXRTdHJpbmc7XG5leHBvcnRzLkJtcFN0cmluZyA9IEJtcFN0cmluZztcbmV4cG9ydHMuQm9vbGVhbiA9IEJvb2xlYW47XG5leHBvcnRzLkNoYXJhY3RlclN0cmluZyA9IENoYXJhY3RlclN0cmluZztcbmV4cG9ydHMuQ2hvaWNlID0gQ2hvaWNlO1xuZXhwb3J0cy5Db25zdHJ1Y3RlZCA9IENvbnN0cnVjdGVkO1xuZXhwb3J0cy5EQVRFID0gREFURTtcbmV4cG9ydHMuRGF0ZVRpbWUgPSBEYXRlVGltZTtcbmV4cG9ydHMuRHVyYXRpb24gPSBEdXJhdGlvbjtcbmV4cG9ydHMuRW5kT2ZDb250ZW50ID0gRW5kT2ZDb250ZW50O1xuZXhwb3J0cy5FbnVtZXJhdGVkID0gRW51bWVyYXRlZDtcbmV4cG9ydHMuR2VuZXJhbFN0cmluZyA9IEdlbmVyYWxTdHJpbmc7XG5leHBvcnRzLkdlbmVyYWxpemVkVGltZSA9IEdlbmVyYWxpemVkVGltZTtcbmV4cG9ydHMuR3JhcGhpY1N0cmluZyA9IEdyYXBoaWNTdHJpbmc7XG5leHBvcnRzLkhleEJsb2NrID0gSGV4QmxvY2s7XG5leHBvcnRzLklBNVN0cmluZyA9IElBNVN0cmluZztcbmV4cG9ydHMuSW50ZWdlciA9IEludGVnZXI7XG5leHBvcnRzLk51bGwgPSBOdWxsO1xuZXhwb3J0cy5OdW1lcmljU3RyaW5nID0gTnVtZXJpY1N0cmluZztcbmV4cG9ydHMuT2JqZWN0SWRlbnRpZmllciA9IE9iamVjdElkZW50aWZpZXI7XG5leHBvcnRzLk9jdGV0U3RyaW5nID0gT2N0ZXRTdHJpbmc7XG5leHBvcnRzLlByaW1pdGl2ZSA9IFByaW1pdGl2ZTtcbmV4cG9ydHMuUHJpbnRhYmxlU3RyaW5nID0gUHJpbnRhYmxlU3RyaW5nO1xuZXhwb3J0cy5SYXdEYXRhID0gUmF3RGF0YTtcbmV4cG9ydHMuUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyID0gUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyO1xuZXhwb3J0cy5SZXBlYXRlZCA9IFJlcGVhdGVkO1xuZXhwb3J0cy5TZXF1ZW5jZSA9IFNlcXVlbmNlO1xuZXhwb3J0cy5TZXQgPSBTZXQ7XG5leHBvcnRzLlRJTUUgPSBUSU1FO1xuZXhwb3J0cy5UZWxldGV4U3RyaW5nID0gVGVsZXRleFN0cmluZztcbmV4cG9ydHMuVGltZU9mRGF5ID0gVGltZU9mRGF5O1xuZXhwb3J0cy5VVENUaW1lID0gVVRDVGltZTtcbmV4cG9ydHMuVW5pdmVyc2FsU3RyaW5nID0gVW5pdmVyc2FsU3RyaW5nO1xuZXhwb3J0cy5VdGY4U3RyaW5nID0gVXRmOFN0cmluZztcbmV4cG9ydHMuVmFsdWVCbG9jayA9IFZhbHVlQmxvY2s7XG5leHBvcnRzLlZpZGVvdGV4U3RyaW5nID0gVmlkZW90ZXhTdHJpbmc7XG5leHBvcnRzLlZpZXdXcml0ZXIgPSBWaWV3V3JpdGVyO1xuZXhwb3J0cy5WaXNpYmxlU3RyaW5nID0gVmlzaWJsZVN0cmluZztcbmV4cG9ydHMuY29tcGFyZVNjaGVtYSA9IGNvbXBhcmVTY2hlbWE7XG5leHBvcnRzLmZyb21CRVIgPSBmcm9tQkVSO1xuZXhwb3J0cy52ZXJpZnlTY2hlbWEgPSB2ZXJpZnlTY2hlbWE7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwdnRzdXRpbHMiLCJyZXF1aXJlIiwicHZ1dGlscyIsIl9pbnRlcm9wTmFtZXNwYWNlIiwiZSIsIl9fZXNNb2R1bGUiLCJuIiwiY3JlYXRlIiwia2V5cyIsImZvckVhY2giLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsImVudW1lcmFibGUiLCJmcmVlemUiLCJwdnRzdXRpbHNfX25hbWVzcGFjZSIsInB2dXRpbHNfX25hbWVzcGFjZSIsImFzc2VydEJpZ0ludCIsIkJpZ0ludCIsIkVycm9yIiwiY29uY2F0IiwiYnVmZmVycyIsIm91dHB1dExlbmd0aCIsInByZXZMZW5ndGgiLCJpIiwibGVuZ3RoIiwiYnVmZmVyIiwiYnl0ZUxlbmd0aCIsInJldFZpZXciLCJVaW50OEFycmF5Iiwic2V0IiwiY2hlY2tCdWZmZXJQYXJhbXMiLCJiYXNlQmxvY2siLCJpbnB1dEJ1ZmZlciIsImlucHV0T2Zmc2V0IiwiaW5wdXRMZW5ndGgiLCJlcnJvciIsIlZpZXdXcml0ZXIiLCJjb25zdHJ1Y3RvciIsIml0ZW1zIiwid3JpdGUiLCJidWYiLCJwdXNoIiwiZmluYWwiLCJwb3dlcnMyIiwiZGlnaXRzU3RyaW5nIiwiTkFNRSIsIlZBTFVFX0hFWF9WSUVXIiwiSVNfSEVYX09OTFkiLCJJRF9CTE9DSyIsIlRBR19DTEFTUyIsIlRBR19OVU1CRVIiLCJJU19DT05TVFJVQ1RFRCIsIkZST01fQkVSIiwiVE9fQkVSIiwiTE9DQUwiLCJFTVBUWV9TVFJJTkciLCJFTVBUWV9CVUZGRVIiLCJBcnJheUJ1ZmZlciIsIkVNUFRZX1ZJRVciLCJFTkRfT0ZfQ09OVEVOVF9OQU1FIiwiT0NURVRfU1RSSU5HX05BTUUiLCJCSVRfU1RSSU5HX05BTUUiLCJIZXhCbG9jayIsIkJhc2VDbGFzcyIsIl9hIiwiU29tZSIsImFyZ3MiLCJwYXJhbXMiLCJpc0hleE9ubHkiLCJ2YWx1ZUhleFZpZXciLCJ2YWx1ZUhleCIsIkJ1ZmZlclNvdXJjZUNvbnZlcnRlciIsInRvVWludDhBcnJheSIsInNsaWNlIiwiZnJvbUJFUiIsInZpZXciLCJlbmRMZW5ndGgiLCJzdWJhcnJheSIsIndhcm5pbmdzIiwiYmxvY2tMZW5ndGgiLCJ0b0JFUiIsInNpemVPbmx5IiwidG9KU09OIiwiQ29udmVydCIsIlRvSGV4IiwiTG9jYWxCYXNlQmxvY2siLCJ2YWx1ZUJlZm9yZURlY29kZSIsInZhbHVlQmVmb3JlRGVjb2RlVmlldyIsImJsb2NrTmFtZSIsIlZhbHVlQmxvY2siLCJUeXBlRXJyb3IiLCJ3cml0ZXIiLCJMb2NhbElkZW50aWZpY2F0aW9uQmxvY2siLCJpZEJsb2NrIiwiX2IiLCJfYyIsIl9kIiwidGFnQ2xhc3MiLCJ0YWdOdW1iZXIiLCJpc0NvbnN0cnVjdGVkIiwiZmlyc3RPY3RldCIsIm51bWJlciIsImVuY29kZWRCdWYiLCJ1dGlsVG9CYXNlIiwiZW5jb2RlZFZpZXciLCJzaXplIiwiY3VyVmlldyIsImlucHV0VmlldyIsImludEJ1ZmZlciIsInRhZ0NsYXNzTWFzayIsInRhZ051bWJlck1hc2siLCJjb3VudCIsImludFRhZ051bWJlckJ1ZmZlciIsInRhZ051bWJlckJ1ZmZlck1heExlbmd0aCIsInRlbXBCdWZmZXJWaWV3IiwidXRpbEZyb21CYXNlIiwiTG9jYWxMZW5ndGhCbG9jayIsImxlbkJsb2NrIiwiaXNJbmRlZmluaXRlRm9ybSIsImxvbmdGb3JtVXNlZCIsImxlbk9mZnNldCIsImxlbmd0aEJ1ZmZlclZpZXciLCJyZXRCdWYiLCJ0eXBlU3RvcmUiLCJCYXNlQmxvY2siLCJuYW1lIiwib3B0aW9uYWwiLCJwcmltaXRpdmVTY2hlbWEiLCJwYXJhbWV0ZXJzIiwidmFsdWVCbG9ja1R5cGUiLCJ2YWx1ZUJsb2NrIiwicmVzdWx0T2Zmc2V0IiwiX3dyaXRlciIsInByZXBhcmVJbmRlZmluaXRlRm9ybSIsImlkQmxvY2tCdWYiLCJ2YWx1ZUJsb2NrQnVmIiwibGVuQmxvY2tCdWYiLCJvYmplY3QiLCJ0b1N0cmluZyIsImVuY29kaW5nIiwib25Bc2NpaUVuY29kaW5nIiwiaXNFcXVhbCIsIm90aGVyIiwidGhpc1JhdyIsIm90aGVyUmF3IiwiaXNFcXVhbEJ1ZmZlciIsIkNvbnN0cnVjdGVkIiwiQmFzZVN0cmluZ0Jsb2NrIiwic3RyaW5nVmFsdWVCbG9ja1R5cGUiLCJmcm9tU3RyaW5nIiwiZ2V0VmFsdWUiLCJzZXRWYWx1ZSIsImZyb21CdWZmZXIiLCJMb2NhbFByaW1pdGl2ZVZhbHVlQmxvY2siLCJfYSR3IiwiUHJpbWl0aXZlIiwibG9jYWxDaGFuZ2VUeXBlIiwiaW5wdXRPYmplY3QiLCJuZXdUeXBlIiwibmV3T2JqZWN0IiwibG9jYWxGcm9tQkVSIiwiaW5jb21pbmdPZmZzZXQiLCJyZXR1cm5PYmplY3QiLCJvZmZzZXQiLCJyZXN1bHQiLCJuZXdBU04xVHlwZSIsIkVuZE9mQ29udGVudCIsIkJvb2xlYW4iLCJJbnRlZ2VyIiwiQml0U3RyaW5nIiwiT2N0ZXRTdHJpbmciLCJOdWxsIiwiT2JqZWN0SWRlbnRpZmllciIsIkVudW1lcmF0ZWQiLCJVdGY4U3RyaW5nIiwiUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyIiwiVElNRSIsIlNlcXVlbmNlIiwiU2V0IiwiTnVtZXJpY1N0cmluZyIsIlByaW50YWJsZVN0cmluZyIsIlRlbGV0ZXhTdHJpbmciLCJWaWRlb3RleFN0cmluZyIsIklBNVN0cmluZyIsIlVUQ1RpbWUiLCJHZW5lcmFsaXplZFRpbWUiLCJHcmFwaGljU3RyaW5nIiwiVmlzaWJsZVN0cmluZyIsIkdlbmVyYWxTdHJpbmciLCJVbml2ZXJzYWxTdHJpbmciLCJDaGFyYWN0ZXJTdHJpbmciLCJCbXBTdHJpbmciLCJEQVRFIiwiVGltZU9mRGF5IiwiRGF0ZVRpbWUiLCJEdXJhdGlvbiIsImNoZWNrTGVuIiwiaW5kZWZpbml0ZUxlbmd0aCIsIkxvY2FsQ29uc3RydWN0ZWRWYWx1ZUJsb2NrIiwiY3VycmVudE9mZnNldCIsInBvcCIsIl9hJHYiLCJ2YWx1ZXMiLCJzcGxpdCIsIm1hcCIsIm8iLCJqb2luIiwiTG9jYWxFbmRPZkNvbnRlbnRWYWx1ZUJsb2NrIiwib3ZlcnJpZGUiLCJfYSR1IiwiX2EkdCIsIkxvY2FsQm9vbGVhblZhbHVlQmxvY2siLCJvY3RldCIsInV0aWxEZWNvZGVUQyIsImNhbGwiLCJfYSRzIiwiTG9jYWxPY3RldFN0cmluZ1ZhbHVlQmxvY2siLCJwcm90b3R5cGUiLCJjdXJyZW50QmxvY2tOYW1lIiwiX2EkciIsImFzbiIsImFycmF5IiwiY29udGVudCIsIkxvY2FsQml0U3RyaW5nVmFsdWVCbG9jayIsInVudXNlZEJpdHMiLCJfYSRxIiwiYml0cyIsImJ5dGUiLCJwYWRTdGFydCIsImJpdHNTdHIiLCJzdWJzdHJpbmciLCJfYSRwIiwidmlld0FkZCIsImZpcnN0Iiwic2Vjb25kIiwiYyIsImZpcnN0VmlldyIsInNlY29uZFZpZXciLCJmaXJzdFZpZXdDb3B5IiwiZmlyc3RWaWV3Q29weUxlbmd0aCIsInNlY29uZFZpZXdDb3B5Iiwic2Vjb25kVmlld0NvcHlMZW5ndGgiLCJtYXgiLCJjb3VudGVyIiwidXRpbENvbmNhdFZpZXciLCJwb3dlcjIiLCJwIiwiZGlnaXRzIiwibmV3VmFsdWUiLCJ2aWV3U3ViIiwiYiIsIkxvY2FsSW50ZWdlclZhbHVlQmxvY2siLCJfdmFsdWVEZWMiLCJzZXRWYWx1ZUhleCIsInVuZGVmaW5lZCIsInZhbHVlRGVjIiwidiIsInV0aWxFbmNvZGVUQyIsImZyb21ERVIiLCJleHBlY3RlZExlbmd0aCIsInRvREVSIiwidXBkYXRlZFZpZXciLCJmaXJzdEJpdCIsImJpdE51bWJlciIsImN1cnJlbnRCeXRlIiwiYXNuMVZpZXciLCJmbGFnIiwiYnl0ZU51bWJlciIsImNoYXJBdCIsIl9hJG8iLCJ0b0JpZ0ludCIsImZyb21CaWdJbnQiLCJiaWdJbnRWYWx1ZSIsImhleCIsInJlcGxhY2UiLCJGcm9tSGV4IiwiZmlyc3RJbnQiLCJzZWNvbmRJbnQiLCJyZXMiLCJjb252ZXJ0VG9ERVIiLCJpbnRlZ2VyIiwiY29udmVydEZyb21ERVIiLCJfYSRuIiwiTG9jYWxTaWRWYWx1ZUJsb2NrIiwiaXNGaXJzdFNpZCIsInRlbXBWaWV3IiwidmFsdWVCaWdJbnQiLCJieXRlcyIsInBhcnNlSW50IiwibGVuIiwic2lkVmFsdWUiLCJMb2NhbE9iamVjdElkZW50aWZpZXJWYWx1ZUJsb2NrIiwic2lkQmxvY2siLCJyZXRCdWZmZXJzIiwidmFsdWVCdWYiLCJzdHJpbmciLCJwb3MxIiwicG9zMiIsInNpZCIsImluZGV4T2YiLCJwbHVzIiwicGFyc2VkU0lEIiwiaXNOYU4iLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwic2lkU3RyIiwic2lkQXJyYXkiLCJfYSRtIiwiTG9jYWxSZWxhdGl2ZVNpZFZhbHVlQmxvY2siLCJMb2NhbFJlbGF0aXZlT2JqZWN0SWRlbnRpZmllclZhbHVlQmxvY2siLCJfYSRsIiwiX2EkayIsIl9hJGoiLCJMb2NhbFN0cmluZ1ZhbHVlQmxvY2siLCJMb2NhbFNpbXBsZVN0cmluZ1ZhbHVlQmxvY2siLCJMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJpbnB1dFN0cmluZyIsInN0ckxlbiIsImNoYXJDb2RlQXQiLCJMb2NhbFV0ZjhTdHJpbmdWYWx1ZUJsb2NrIiwiVG9VdGY4U3RyaW5nIiwiZXgiLCJUb0JpbmFyeSIsIkZyb21VdGY4U3RyaW5nIiwiX2EkaSIsIkxvY2FsQm1wU3RyaW5nVmFsdWVCbG9jayIsIlRvVXRmMTZTdHJpbmciLCJGcm9tVXRmMTZTdHJpbmciLCJfYSRoIiwiTG9jYWxVbml2ZXJzYWxTdHJpbmdWYWx1ZUJsb2NrIiwiY29weUJ1ZmZlciIsImlzVmlldyIsInZhbHVlVmlldyIsIlVpbnQzMkFycmF5Iiwic3RyTGVuZ3RoIiwiY29kZUJ1ZiIsImNvZGVWaWV3IiwiZGlmIiwiaiIsIl9hJGciLCJfYSRmIiwiX2EkZSIsIl9hJGQiLCJfYSRjIiwiX2EkYiIsIl9hJGEiLCJfYSQ5IiwiX2EkOCIsIl9hJDciLCJfYSQ2IiwidmFsdWVEYXRlIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsImZyb21EYXRlIiwidG9CdWZmZXIiLCJzdHIiLCJpbnB1dERhdGUiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJ0b0RhdGUiLCJEYXRlIiwiVVRDIiwicGFyc2VyIiwicGFyc2VyQXJyYXkiLCJleGVjIiwib3V0cHV0QXJyYXkiLCJBcnJheSIsInBhZE51bWJlciIsInRvSVNPU3RyaW5nIiwiX2EkNSIsIm1pbGxpc2Vjb25kIiwiZ2V0VVRDTWlsbGlzZWNvbmRzIiwiaXNVVEMiLCJ0aW1lU3RyaW5nIiwiZGF0ZVRpbWVTdHJpbmciLCJmcmFjdGlvblBhcnQiLCJob3VyRGlmZmVyZW5jZSIsIm1pbnV0ZURpZmZlcmVuY2UiLCJ2YWx1ZU9mIiwibXVsdGlwbGllciIsImRpZmZlcmVuY2VQb3NpdGlvbiIsImRpZmZlcmVuY2VTdHJpbmciLCJmcmFjdGlvblBvaW50UG9zaXRpb24iLCJmcmFjdGlvblBhcnRDaGVjayIsImZyYWN0aW9uUmVzdWx0IiwiTWF0aCIsImZsb29yIiwidGVtcERhdGUiLCJnZXRVVENEYXkiLCJfYSQ0IiwiX2EkMyIsIl9hJDIiLCJfYSQxIiwiQW55IiwiQ2hvaWNlIiwiUmVwZWF0ZWQiLCJsb2NhbCIsIlJhd0RhdGEiLCJkYXRhIiwiZGF0YVZpZXciLCJjb21wYXJlU2NoZW1hIiwicm9vdCIsImlucHV0RGF0YSIsImlucHV0U2NoZW1hIiwidmVyaWZpZWQiLCJfcmVzdWx0IiwiaGFzT3duUHJvcGVydHkiLCJlbmNvZGVkSWQiLCJkZWNvZGVkT2Zmc2V0Iiwic2NoZW1hVmlldyIsImFkbWlzc2lvbiIsIm1heExlbmd0aCIsIl9vcHRpb25hbCIsImFycmF5Um9vdCIsImFzbjEiLCJ2ZXJpZnlTY2hlbWEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/asn1js/build/index.js\n");

/***/ })

};
;