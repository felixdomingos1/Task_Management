"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/webcrypto-core";
exports.ids = ["vendor-chunks/webcrypto-core"];
exports.modules = {

/***/ "(rsc)/./node_modules/webcrypto-core/build/webcrypto-core.js":
/*!*************************************************************!*\
  !*** ./node_modules/webcrypto-core/build/webcrypto-core.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n Copyright (c) Peculiar Ventures, LLC\n*/ \nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(rsc)/./node_modules/pvtsutils/build/index.js\");\nvar asn1Schema = __webpack_require__(/*! @peculiar/asn1-schema */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js\");\nvar tslib = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nvar jsonSchema = __webpack_require__(/*! @peculiar/json-schema */ \"(rsc)/./node_modules/@peculiar/json-schema/build/index.js\");\nvar asn1 = __webpack_require__(/*! asn1js */ \"(rsc)/./node_modules/asn1js/build/index.js\");\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar asn1__namespace = /*#__PURE__*/ _interopNamespaceDefault(asn1);\nclass CryptoError extends Error {\n}\nclass AlgorithmError extends CryptoError {\n}\nclass UnsupportedOperationError extends CryptoError {\n    constructor(methodName){\n        super(`Unsupported operation: ${methodName ? `${methodName}` : \"\"}`);\n    }\n}\nclass OperationError extends CryptoError {\n}\nclass RequiredPropertyError extends CryptoError {\n    constructor(propName){\n        super(`${propName}: Missing required property`);\n    }\n}\nclass PemConverter {\n    static toArrayBuffer(pem) {\n        const base64 = pem.replace(/-{5}(BEGIN|END) .*-{5}/g, \"\").replace(\"\\r\", \"\").replace(\"\\n\", \"\");\n        return pvtsutils.Convert.FromBase64(base64);\n    }\n    static toUint8Array(pem) {\n        const bytes = this.toArrayBuffer(pem);\n        return new Uint8Array(bytes);\n    }\n    static fromBufferSource(buffer, tag) {\n        const base64 = pvtsutils.Convert.ToBase64(buffer);\n        let sliced;\n        let offset = 0;\n        const rows = [];\n        while(true){\n            sliced = base64.slice(offset, offset = offset + 64);\n            if (sliced.length) {\n                rows.push(sliced);\n                if (sliced.length < 64) {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        const upperCaseTag = tag.toUpperCase();\n        return `-----BEGIN ${upperCaseTag}-----\\n${rows.join(\"\\n\")}\\n-----END ${upperCaseTag}-----`;\n    }\n    static isPEM(data) {\n        return /-----BEGIN .+-----[A-Za-z0-9+\\/\\+\\=\\s\\n]+-----END .+-----/i.test(data);\n    }\n    static getTagName(pem) {\n        if (!this.isPEM(pem)) {\n            throw new Error(\"Bad parameter. Incoming data is not right PEM\");\n        }\n        const res = /-----BEGIN (.+)-----/.exec(pem);\n        if (!res) {\n            throw new Error(\"Cannot get tag from PEM\");\n        }\n        return res[1];\n    }\n    static hasTagName(pem, tagName) {\n        const tag = this.getTagName(pem);\n        return tagName.toLowerCase() === tag.toLowerCase();\n    }\n    static isCertificate(pem) {\n        return this.hasTagName(pem, \"certificate\");\n    }\n    static isCertificateRequest(pem) {\n        return this.hasTagName(pem, \"certificate request\");\n    }\n    static isCRL(pem) {\n        return this.hasTagName(pem, \"x509 crl\");\n    }\n    static isPublicKey(pem) {\n        return this.hasTagName(pem, \"public key\");\n    }\n}\nfunction isJWK(data) {\n    return typeof data === \"object\" && \"kty\" in data;\n}\nclass ProviderCrypto {\n    async digest(...args) {\n        this.checkDigest.apply(this, args);\n        return this.onDigest.apply(this, args);\n    }\n    checkDigest(algorithm, data) {\n        this.checkAlgorithmName(algorithm);\n    }\n    async onDigest(algorithm, data) {\n        throw new UnsupportedOperationError(\"digest\");\n    }\n    async generateKey(...args) {\n        this.checkGenerateKey.apply(this, args);\n        return this.onGenerateKey.apply(this, args);\n    }\n    checkGenerateKey(algorithm, extractable, keyUsages, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkGenerateKeyParams(algorithm);\n        if (!(keyUsages && keyUsages.length)) {\n            throw new TypeError(`Usages cannot be empty when creating a key.`);\n        }\n        let allowedUsages;\n        if (Array.isArray(this.usages)) {\n            allowedUsages = this.usages;\n        } else {\n            allowedUsages = this.usages.privateKey.concat(this.usages.publicKey);\n        }\n        this.checkKeyUsages(keyUsages, allowedUsages);\n    }\n    checkGenerateKeyParams(algorithm) {}\n    async onGenerateKey(algorithm, extractable, keyUsages, ...args) {\n        throw new UnsupportedOperationError(\"generateKey\");\n    }\n    async sign(...args) {\n        this.checkSign.apply(this, args);\n        return this.onSign.apply(this, args);\n    }\n    checkSign(algorithm, key, data, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, \"sign\");\n    }\n    async onSign(algorithm, key, data, ...args) {\n        throw new UnsupportedOperationError(\"sign\");\n    }\n    async verify(...args) {\n        this.checkVerify.apply(this, args);\n        return this.onVerify.apply(this, args);\n    }\n    checkVerify(algorithm, key, signature, data, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, \"verify\");\n    }\n    async onVerify(algorithm, key, signature, data, ...args) {\n        throw new UnsupportedOperationError(\"verify\");\n    }\n    async encrypt(...args) {\n        this.checkEncrypt.apply(this, args);\n        return this.onEncrypt.apply(this, args);\n    }\n    checkEncrypt(algorithm, key, data, options = {}, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, options.keyUsage ? \"encrypt\" : void 0);\n    }\n    async onEncrypt(algorithm, key, data, ...args) {\n        throw new UnsupportedOperationError(\"encrypt\");\n    }\n    async decrypt(...args) {\n        this.checkDecrypt.apply(this, args);\n        return this.onDecrypt.apply(this, args);\n    }\n    checkDecrypt(algorithm, key, data, options = {}, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, options.keyUsage ? \"decrypt\" : void 0);\n    }\n    async onDecrypt(algorithm, key, data, ...args) {\n        throw new UnsupportedOperationError(\"decrypt\");\n    }\n    async deriveBits(...args) {\n        this.checkDeriveBits.apply(this, args);\n        return this.onDeriveBits.apply(this, args);\n    }\n    checkDeriveBits(algorithm, baseKey, length, options = {}, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(baseKey, options.keyUsage ? \"deriveBits\" : void 0);\n        if (length % 8 !== 0) {\n            throw new OperationError(\"length: Is not multiple of 8\");\n        }\n    }\n    async onDeriveBits(algorithm, baseKey, length, ...args) {\n        throw new UnsupportedOperationError(\"deriveBits\");\n    }\n    async exportKey(...args) {\n        this.checkExportKey.apply(this, args);\n        return this.onExportKey.apply(this, args);\n    }\n    checkExportKey(format, key, ...args) {\n        this.checkKeyFormat(format);\n        this.checkCryptoKey(key);\n        if (!key.extractable) {\n            throw new CryptoError(\"key: Is not extractable\");\n        }\n    }\n    async onExportKey(format, key, ...args) {\n        throw new UnsupportedOperationError(\"exportKey\");\n    }\n    async importKey(...args) {\n        this.checkImportKey.apply(this, args);\n        return this.onImportKey.apply(this, args);\n    }\n    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        this.checkKeyFormat(format);\n        this.checkKeyData(format, keyData);\n        this.checkAlgorithmName(algorithm);\n        this.checkImportParams(algorithm);\n        if (Array.isArray(this.usages)) {\n            this.checkKeyUsages(keyUsages, this.usages);\n        }\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        throw new UnsupportedOperationError(\"importKey\");\n    }\n    checkAlgorithmName(algorithm) {\n        if (algorithm.name.toLowerCase() !== this.name.toLowerCase()) {\n            throw new AlgorithmError(\"Unrecognized name\");\n        }\n    }\n    checkAlgorithmParams(algorithm) {}\n    checkDerivedKeyParams(algorithm) {}\n    checkKeyUsages(usages, allowed) {\n        for (const usage of usages){\n            if (allowed.indexOf(usage) === -1) {\n                throw new TypeError(\"Cannot create a key using the specified key usages\");\n            }\n        }\n    }\n    checkCryptoKey(key, keyUsage) {\n        this.checkAlgorithmName(key.algorithm);\n        if (keyUsage && key.usages.indexOf(keyUsage) === -1) {\n            throw new CryptoError(`key does not match that of operation`);\n        }\n    }\n    checkRequiredProperty(data, propName) {\n        if (!(propName in data)) {\n            throw new RequiredPropertyError(propName);\n        }\n    }\n    checkHashAlgorithm(algorithm, hashAlgorithms) {\n        for (const item of hashAlgorithms){\n            if (item.toLowerCase() === algorithm.name.toLowerCase()) {\n                return;\n            }\n        }\n        throw new OperationError(`hash: Must be one of ${hashAlgorithms.join(\", \")}`);\n    }\n    checkImportParams(algorithm) {}\n    checkKeyFormat(format) {\n        switch(format){\n            case \"raw\":\n            case \"pkcs8\":\n            case \"spki\":\n            case \"jwk\":\n                break;\n            default:\n                throw new TypeError(\"format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'\");\n        }\n    }\n    checkKeyData(format, keyData) {\n        if (!keyData) {\n            throw new TypeError(\"keyData: Cannot be empty on empty on key importing\");\n        }\n        if (format === \"jwk\") {\n            if (!isJWK(keyData)) {\n                throw new TypeError(\"keyData: Is not JsonWebToken\");\n            }\n        } else if (!pvtsutils.BufferSourceConverter.isBufferSource(keyData)) {\n            throw new TypeError(\"keyData: Is not ArrayBufferView or ArrayBuffer\");\n        }\n    }\n    prepareData(data) {\n        return pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n    }\n}\nclass AesProvider extends ProviderCrypto {\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not of type Number\");\n        }\n        switch(algorithm.length){\n            case 128:\n            case 192:\n            case 256:\n                break;\n            default:\n                throw new TypeError(\"length: Must be 128, 192, or 256\");\n        }\n    }\n    checkDerivedKeyParams(algorithm) {\n        this.checkGenerateKeyParams(algorithm);\n    }\n}\nclass AesCbcProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-CBC\";\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"iv\");\n        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n            throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.iv.byteLength !== 16) {\n            throw new TypeError(\"iv: Must have length 16 bytes\");\n        }\n    }\n}\nclass AesCmacProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-CMAC\";\n        this.usages = [\n            \"sign\",\n            \"verify\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (algorithm.length < 1) {\n            throw new OperationError(\"length: Must be more than 0\");\n        }\n    }\n}\nclass AesCtrProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-CTR\";\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"counter\");\n        if (!(algorithm.counter instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.counter))) {\n            throw new TypeError(\"counter: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.counter.byteLength !== 16) {\n            throw new TypeError(\"iv: Must have length 16 bytes\");\n        }\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (algorithm.length < 1) {\n            throw new OperationError(\"length: Must be more than 0\");\n        }\n    }\n}\nclass AesEcbProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-ECB\";\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n}\nclass AesGcmProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-GCM\";\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"iv\");\n        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n            throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.iv.byteLength < 1) {\n            throw new OperationError(\"iv: Must have length more than 0 and less than 2^64 - 1\");\n        }\n        if (!(\"tagLength\" in algorithm)) {\n            algorithm.tagLength = 128;\n        }\n        switch(algorithm.tagLength){\n            case 32:\n            case 64:\n            case 96:\n            case 104:\n            case 112:\n            case 120:\n            case 128:\n                break;\n            default:\n                throw new OperationError(\"tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128\");\n        }\n    }\n}\nclass AesKwProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-KW\";\n        this.usages = [\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n}\nclass DesProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        if (this.ivSize) {\n            this.checkRequiredProperty(algorithm, \"iv\");\n            if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n                throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n            }\n            if (algorithm.iv.byteLength !== this.ivSize) {\n                throw new TypeError(`iv: Must have length ${this.ivSize} bytes`);\n            }\n        }\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not of type Number\");\n        }\n        if (algorithm.length !== this.keySizeBits) {\n            throw new OperationError(`algorithm.length: Must be ${this.keySizeBits}`);\n        }\n    }\n    checkDerivedKeyParams(algorithm) {\n        this.checkGenerateKeyParams(algorithm);\n    }\n}\nclass RsaProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\n        }\n        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\n        }\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\n        if (algorithm.modulusLength % 8 || algorithm.modulusLength < 256 || algorithm.modulusLength > 16384) {\n            throw new TypeError(\"The modulus length must be a multiple of 8 bits and >= 256 and <= 16384\");\n        }\n    }\n    checkImportParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\nclass RsaSsaProvider extends RsaProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"RSASSA-PKCS1-v1_5\";\n        this.usages = {\n            privateKey: [\n                \"sign\"\n            ],\n            publicKey: [\n                \"verify\"\n            ]\n        };\n    }\n}\nclass RsaPssProvider extends RsaProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"RSA-PSS\";\n        this.usages = {\n            privateKey: [\n                \"sign\"\n            ],\n            publicKey: [\n                \"verify\"\n            ]\n        };\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"saltLength\");\n        if (typeof algorithm.saltLength !== \"number\") {\n            throw new TypeError(\"saltLength: Is not a Number\");\n        }\n        if (algorithm.saltLength < 0) {\n            throw new RangeError(\"saltLength: Must be positive number\");\n        }\n    }\n}\nclass RsaOaepProvider extends RsaProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"RSA-OAEP\";\n        this.usages = {\n            privateKey: [\n                \"decrypt\",\n                \"unwrapKey\"\n            ],\n            publicKey: [\n                \"encrypt\",\n                \"wrapKey\"\n            ]\n        };\n    }\n    checkAlgorithmParams(algorithm) {\n        if (algorithm.label && !(algorithm.label instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.label))) {\n            throw new TypeError(\"label: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n    }\n}\nclass EllipticProvider extends ProviderCrypto {\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"namedCurve\");\n        this.checkNamedCurve(algorithm.namedCurve);\n    }\n    checkNamedCurve(namedCurve) {\n        for (const item of this.namedCurves){\n            if (item.toLowerCase() === namedCurve.toLowerCase()) {\n                return;\n            }\n        }\n        throw new OperationError(`namedCurve: Must be one of ${this.namedCurves.join(\", \")}`);\n    }\n}\nclass EcdsaProvider extends EllipticProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"ECDSA\";\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n        this.usages = {\n            privateKey: [\n                \"sign\"\n            ],\n            publicKey: [\n                \"verify\"\n            ]\n        };\n        this.namedCurves = [\n            \"P-256\",\n            \"P-384\",\n            \"P-521\",\n            \"K-256\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\nconst KEY_TYPES = [\n    \"secret\",\n    \"private\",\n    \"public\"\n];\nclass CryptoKey {\n    static create(algorithm, type, extractable, usages) {\n        const key = new this();\n        key.algorithm = algorithm;\n        key.type = type;\n        key.extractable = extractable;\n        key.usages = usages;\n        return key;\n    }\n    static isKeyType(data) {\n        return KEY_TYPES.indexOf(data) !== -1;\n    }\n    get [Symbol.toStringTag]() {\n        return \"CryptoKey\";\n    }\n}\nclass EcdhProvider extends EllipticProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"ECDH\";\n        this.usages = {\n            privateKey: [\n                \"deriveBits\",\n                \"deriveKey\"\n            ],\n            publicKey: []\n        };\n        this.namedCurves = [\n            \"P-256\",\n            \"P-384\",\n            \"P-521\",\n            \"K-256\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"public\");\n        if (!(algorithm.public instanceof CryptoKey)) {\n            throw new TypeError(\"public: Is not a CryptoKey\");\n        }\n        if (algorithm.public.type !== \"public\") {\n            throw new OperationError(\"public: Is not a public key\");\n        }\n        if (algorithm.public.algorithm.name !== this.name) {\n            throw new OperationError(`public: Is not ${this.name} key`);\n        }\n    }\n}\nclass EcdhEsProvider extends EcdhProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"ECDH-ES\";\n        this.namedCurves = [\n            \"X25519\",\n            \"X448\"\n        ];\n    }\n}\nclass EdDsaProvider extends EllipticProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"EdDSA\";\n        this.usages = {\n            privateKey: [\n                \"sign\"\n            ],\n            publicKey: [\n                \"verify\"\n            ]\n        };\n        this.namedCurves = [\n            \"Ed25519\",\n            \"Ed448\"\n        ];\n    }\n}\nlet ObjectIdentifier = class ObjectIdentifier {\n    constructor(value){\n        if (value) {\n            this.value = value;\n        }\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.ObjectIdentifier\n    })\n], ObjectIdentifier.prototype, \"value\", void 0);\nObjectIdentifier = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], ObjectIdentifier);\nclass AlgorithmIdentifier {\n    constructor(params){\n        Object.assign(this, params);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.ObjectIdentifier\n    })\n], AlgorithmIdentifier.prototype, \"algorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true\n    })\n], AlgorithmIdentifier.prototype, \"parameters\", void 0);\nclass PrivateKeyInfo {\n    constructor(){\n        this.version = 0;\n        this.privateKeyAlgorithm = new AlgorithmIdentifier();\n        this.privateKey = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer\n    })\n], PrivateKeyInfo.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: AlgorithmIdentifier\n    })\n], PrivateKeyInfo.prototype, \"privateKeyAlgorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    })\n], PrivateKeyInfo.prototype, \"privateKey\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true\n    })\n], PrivateKeyInfo.prototype, \"attributes\", void 0);\nclass PublicKeyInfo {\n    constructor(){\n        this.publicKeyAlgorithm = new AlgorithmIdentifier();\n        this.publicKey = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: AlgorithmIdentifier\n    })\n], PublicKeyInfo.prototype, \"publicKeyAlgorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.BitString\n    })\n], PublicKeyInfo.prototype, \"publicKey\", void 0);\nconst JsonBase64UrlArrayBufferConverter = {\n    fromJSON: (value)=>pvtsutils.Convert.FromBase64Url(value),\n    toJSON: (value)=>pvtsutils.Convert.ToBase64Url(new Uint8Array(value))\n};\nconst AsnIntegerArrayBufferConverter = {\n    fromASN: (value)=>{\n        const valueHex = value.valueBlock.valueHex;\n        return !new Uint8Array(valueHex)[0] ? value.valueBlock.valueHex.slice(1) : value.valueBlock.valueHex;\n    },\n    toASN: (value)=>{\n        const valueHex = new Uint8Array(value)[0] > 127 ? pvtsutils.combine(new Uint8Array([\n            0\n        ]).buffer, value) : value;\n        return new asn1__namespace.Integer({\n            valueHex\n        });\n    }\n};\nvar index$3 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AsnIntegerArrayBufferConverter: AsnIntegerArrayBufferConverter,\n    JsonBase64UrlArrayBufferConverter: JsonBase64UrlArrayBufferConverter\n});\nclass RsaPrivateKey {\n    constructor(){\n        this.version = 0;\n        this.modulus = new ArrayBuffer(0);\n        this.publicExponent = new ArrayBuffer(0);\n        this.privateExponent = new ArrayBuffer(0);\n        this.prime1 = new ArrayBuffer(0);\n        this.prime2 = new ArrayBuffer(0);\n        this.exponent1 = new ArrayBuffer(0);\n        this.exponent2 = new ArrayBuffer(0);\n        this.coefficient = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: asn1Schema.AsnIntegerConverter\n    })\n], RsaPrivateKey.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"n\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"modulus\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"e\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"publicExponent\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"d\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"privateExponent\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"p\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"prime1\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"q\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"prime2\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"dp\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"exponent1\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"dq\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"exponent2\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"qi\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"coefficient\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true\n    })\n], RsaPrivateKey.prototype, \"otherPrimeInfos\", void 0);\nclass RsaPublicKey {\n    constructor(){\n        this.modulus = new ArrayBuffer(0);\n        this.publicExponent = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"n\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPublicKey.prototype, \"modulus\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"e\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPublicKey.prototype, \"publicExponent\", void 0);\nlet EcPublicKey = class EcPublicKey {\n    constructor(value){\n        this.value = new ArrayBuffer(0);\n        if (value) {\n            this.value = value;\n        }\n    }\n    toJSON() {\n        let bytes = new Uint8Array(this.value);\n        if (bytes[0] !== 0x04) {\n            throw new CryptoError(\"Wrong ECPoint. Current version supports only Uncompressed (0x04) point\");\n        }\n        bytes = new Uint8Array(this.value.slice(1));\n        const size = bytes.length / 2;\n        const offset = 0;\n        const json = {\n            x: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset, offset + size)),\n            y: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset + size, offset + size + size))\n        };\n        return json;\n    }\n    fromJSON(json) {\n        if (!(\"x\" in json)) {\n            throw new Error(\"x: Missing required property\");\n        }\n        if (!(\"y\" in json)) {\n            throw new Error(\"y: Missing required property\");\n        }\n        const x = pvtsutils.Convert.FromBase64Url(json.x);\n        const y = pvtsutils.Convert.FromBase64Url(json.y);\n        const value = pvtsutils.combine(new Uint8Array([\n            0x04\n        ]).buffer, x, y);\n        this.value = new Uint8Array(value).buffer;\n        return this;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    })\n], EcPublicKey.prototype, \"value\", void 0);\nEcPublicKey = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], EcPublicKey);\nclass EcPrivateKey {\n    constructor(){\n        this.version = 1;\n        this.privateKey = new ArrayBuffer(0);\n    }\n    fromJSON(json) {\n        if (!(\"d\" in json)) {\n            throw new Error(\"d: Missing required property\");\n        }\n        this.privateKey = pvtsutils.Convert.FromBase64Url(json.d);\n        if (\"x\" in json) {\n            const publicKey = new EcPublicKey();\n            publicKey.fromJSON(json);\n            const asn = asn1Schema.AsnSerializer.toASN(publicKey);\n            if (\"valueHex\" in asn.valueBlock) {\n                this.publicKey = asn.valueBlock.valueHex;\n            }\n        }\n        return this;\n    }\n    toJSON() {\n        const jwk = {};\n        jwk.d = pvtsutils.Convert.ToBase64Url(this.privateKey);\n        if (this.publicKey) {\n            Object.assign(jwk, new EcPublicKey(this.publicKey).toJSON());\n        }\n        return jwk;\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: asn1Schema.AsnIntegerConverter\n    })\n], EcPrivateKey.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    })\n], EcPrivateKey.prototype, \"privateKey\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        context: 0,\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true\n    })\n], EcPrivateKey.prototype, \"parameters\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        context: 1,\n        type: asn1Schema.AsnPropTypes.BitString,\n        optional: true\n    })\n], EcPrivateKey.prototype, \"publicKey\", void 0);\nconst AsnIntegerWithoutPaddingConverter = {\n    fromASN: (value)=>{\n        const bytes = new Uint8Array(value.valueBlock.valueHex);\n        return bytes[0] === 0 ? bytes.buffer.slice(1) : bytes.buffer;\n    },\n    toASN: (value)=>{\n        const bytes = new Uint8Array(value);\n        if (bytes[0] > 127) {\n            const newValue = new Uint8Array(bytes.length + 1);\n            newValue.set(bytes, 1);\n            return new asn1__namespace.Integer({\n                valueHex: newValue.buffer\n            });\n        }\n        return new asn1__namespace.Integer({\n            valueHex: value\n        });\n    }\n};\nvar index$2 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AsnIntegerWithoutPaddingConverter: AsnIntegerWithoutPaddingConverter\n});\nclass EcUtils {\n    static decodePoint(data, pointSize) {\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);\n        if (view.length === 0 || view[0] !== 4) {\n            throw new Error(\"Only uncompressed point format supported\");\n        }\n        const n = (view.length - 1) / 2;\n        if (n !== Math.ceil(pointSize / 8)) {\n            throw new Error(\"Point does not match field size\");\n        }\n        const xb = view.slice(1, n + 1);\n        const yb = view.slice(n + 1, n + 1 + n);\n        return {\n            x: xb,\n            y: yb\n        };\n    }\n    static encodePoint(point, pointSize) {\n        const size = Math.ceil(pointSize / 8);\n        if (point.x.byteLength !== size || point.y.byteLength !== size) {\n            throw new Error(\"X,Y coordinates don't match point size criteria\");\n        }\n        const x = pvtsutils.BufferSourceConverter.toUint8Array(point.x);\n        const y = pvtsutils.BufferSourceConverter.toUint8Array(point.y);\n        const res = new Uint8Array(size * 2 + 1);\n        res[0] = 4;\n        res.set(x, 1);\n        res.set(y, size + 1);\n        return res;\n    }\n    static getSize(pointSize) {\n        return Math.ceil(pointSize / 8);\n    }\n    static encodeSignature(signature, pointSize) {\n        const size = this.getSize(pointSize);\n        const r = pvtsutils.BufferSourceConverter.toUint8Array(signature.r);\n        const s = pvtsutils.BufferSourceConverter.toUint8Array(signature.s);\n        const res = new Uint8Array(size * 2);\n        res.set(this.padStart(r, size));\n        res.set(this.padStart(s, size), size);\n        return res;\n    }\n    static decodeSignature(data, pointSize) {\n        const size = this.getSize(pointSize);\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);\n        if (view.length !== size * 2) {\n            throw new Error(\"Incorrect size of the signature\");\n        }\n        const r = view.slice(0, size);\n        const s = view.slice(size);\n        return {\n            r: this.trimStart(r),\n            s: this.trimStart(s)\n        };\n    }\n    static trimStart(data) {\n        let i = 0;\n        while(i < data.length - 1 && data[i] === 0){\n            i++;\n        }\n        if (i === 0) {\n            return data;\n        }\n        return data.slice(i, data.length);\n    }\n    static padStart(data, size) {\n        if (size === data.length) {\n            return data;\n        }\n        const res = new Uint8Array(size);\n        res.set(data, size - data.length);\n        return res;\n    }\n}\nclass EcDsaSignature {\n    constructor(){\n        this.r = new ArrayBuffer(0);\n        this.s = new ArrayBuffer(0);\n    }\n    static fromWebCryptoSignature(value) {\n        const pointSize = value.byteLength / 2;\n        const point = EcUtils.decodeSignature(value, pointSize * 8);\n        const ecSignature = new EcDsaSignature();\n        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(point.r);\n        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(point.s);\n        return ecSignature;\n    }\n    toWebCryptoSignature(pointSize) {\n        pointSize !== null && pointSize !== void 0 ? pointSize : pointSize = Math.max(this.r.byteLength, this.s.byteLength) * 8;\n        const signature = EcUtils.encodeSignature(this, pointSize);\n        return signature.buffer;\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerWithoutPaddingConverter\n    })\n], EcDsaSignature.prototype, \"r\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerWithoutPaddingConverter\n    })\n], EcDsaSignature.prototype, \"s\", void 0);\nclass OneAsymmetricKey extends PrivateKeyInfo {\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        context: 1,\n        implicit: true,\n        type: asn1Schema.AsnPropTypes.BitString,\n        optional: true\n    })\n], OneAsymmetricKey.prototype, \"publicKey\", void 0);\nlet EdPrivateKey = class EdPrivateKey {\n    constructor(){\n        this.value = new ArrayBuffer(0);\n    }\n    fromJSON(json) {\n        if (!json.d) {\n            throw new Error(\"d: Missing required property\");\n        }\n        this.value = pvtsutils.Convert.FromBase64Url(json.d);\n        return this;\n    }\n    toJSON() {\n        const jwk = {\n            d: pvtsutils.Convert.ToBase64Url(this.value)\n        };\n        return jwk;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    })\n], EdPrivateKey.prototype, \"value\", void 0);\nEdPrivateKey = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], EdPrivateKey);\nlet EdPublicKey = class EdPublicKey {\n    constructor(value){\n        this.value = new ArrayBuffer(0);\n        if (value) {\n            this.value = value;\n        }\n    }\n    toJSON() {\n        const json = {\n            x: pvtsutils.Convert.ToBase64Url(this.value)\n        };\n        return json;\n    }\n    fromJSON(json) {\n        if (!(\"x\" in json)) {\n            throw new Error(\"x: Missing required property\");\n        }\n        this.value = pvtsutils.Convert.FromBase64Url(json.x);\n        return this;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.BitString\n    })\n], EdPublicKey.prototype, \"value\", void 0);\nEdPublicKey = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], EdPublicKey);\nlet CurvePrivateKey = class CurvePrivateKey {\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    }),\n    jsonSchema.JsonProp({\n        type: jsonSchema.JsonPropTypes.String,\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], CurvePrivateKey.prototype, \"d\", void 0);\nCurvePrivateKey = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], CurvePrivateKey);\nconst idSecp256r1 = \"1.2.840.10045.3.1.7\";\nconst idEllipticCurve = \"1.3.132.0\";\nconst idSecp384r1 = `${idEllipticCurve}.34`;\nconst idSecp521r1 = `${idEllipticCurve}.35`;\nconst idSecp256k1 = `${idEllipticCurve}.10`;\nconst idVersionOne = \"1.3.36.3.3.2.8.1.1\";\nconst idBrainpoolP160r1 = `${idVersionOne}.1`;\nconst idBrainpoolP160t1 = `${idVersionOne}.2`;\nconst idBrainpoolP192r1 = `${idVersionOne}.3`;\nconst idBrainpoolP192t1 = `${idVersionOne}.4`;\nconst idBrainpoolP224r1 = `${idVersionOne}.5`;\nconst idBrainpoolP224t1 = `${idVersionOne}.6`;\nconst idBrainpoolP256r1 = `${idVersionOne}.7`;\nconst idBrainpoolP256t1 = `${idVersionOne}.8`;\nconst idBrainpoolP320r1 = `${idVersionOne}.9`;\nconst idBrainpoolP320t1 = `${idVersionOne}.10`;\nconst idBrainpoolP384r1 = `${idVersionOne}.11`;\nconst idBrainpoolP384t1 = `${idVersionOne}.12`;\nconst idBrainpoolP512r1 = `${idVersionOne}.13`;\nconst idBrainpoolP512t1 = `${idVersionOne}.14`;\nconst idX25519 = \"1.3.101.110\";\nconst idX448 = \"1.3.101.111\";\nconst idEd25519 = \"1.3.101.112\";\nconst idEd448 = \"1.3.101.113\";\nvar index$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AlgorithmIdentifier: AlgorithmIdentifier,\n    get CurvePrivateKey () {\n        return CurvePrivateKey;\n    },\n    EcDsaSignature: EcDsaSignature,\n    EcPrivateKey: EcPrivateKey,\n    get EcPublicKey () {\n        return EcPublicKey;\n    },\n    get EdPrivateKey () {\n        return EdPrivateKey;\n    },\n    get EdPublicKey () {\n        return EdPublicKey;\n    },\n    get ObjectIdentifier () {\n        return ObjectIdentifier;\n    },\n    OneAsymmetricKey: OneAsymmetricKey,\n    PrivateKeyInfo: PrivateKeyInfo,\n    PublicKeyInfo: PublicKeyInfo,\n    RsaPrivateKey: RsaPrivateKey,\n    RsaPublicKey: RsaPublicKey,\n    converters: index$2,\n    idBrainpoolP160r1: idBrainpoolP160r1,\n    idBrainpoolP160t1: idBrainpoolP160t1,\n    idBrainpoolP192r1: idBrainpoolP192r1,\n    idBrainpoolP192t1: idBrainpoolP192t1,\n    idBrainpoolP224r1: idBrainpoolP224r1,\n    idBrainpoolP224t1: idBrainpoolP224t1,\n    idBrainpoolP256r1: idBrainpoolP256r1,\n    idBrainpoolP256t1: idBrainpoolP256t1,\n    idBrainpoolP320r1: idBrainpoolP320r1,\n    idBrainpoolP320t1: idBrainpoolP320t1,\n    idBrainpoolP384r1: idBrainpoolP384r1,\n    idBrainpoolP384t1: idBrainpoolP384t1,\n    idBrainpoolP512r1: idBrainpoolP512r1,\n    idBrainpoolP512t1: idBrainpoolP512t1,\n    idEd25519: idEd25519,\n    idEd448: idEd448,\n    idEllipticCurve: idEllipticCurve,\n    idSecp256k1: idSecp256k1,\n    idSecp256r1: idSecp256r1,\n    idSecp384r1: idSecp384r1,\n    idSecp521r1: idSecp521r1,\n    idVersionOne: idVersionOne,\n    idX25519: idX25519,\n    idX448: idX448\n});\nclass EcCurves {\n    constructor(){}\n    static register(item) {\n        const oid = new ObjectIdentifier();\n        oid.value = item.id;\n        const raw = asn1Schema.AsnConvert.serialize(oid);\n        this.items.push({\n            ...item,\n            raw\n        });\n        this.names.push(item.name);\n    }\n    static find(nameOrId) {\n        nameOrId = nameOrId.toUpperCase();\n        for (const item of this.items){\n            if (item.name.toUpperCase() === nameOrId || item.id.toUpperCase() === nameOrId) {\n                return item;\n            }\n        }\n        return null;\n    }\n    static get(nameOrId) {\n        const res = this.find(nameOrId);\n        if (!res) {\n            throw new Error(`Unsupported EC named curve '${nameOrId}'`);\n        }\n        return res;\n    }\n}\nEcCurves.items = [];\nEcCurves.names = [];\nEcCurves.register({\n    name: \"P-256\",\n    id: idSecp256r1,\n    size: 256\n});\nEcCurves.register({\n    name: \"P-384\",\n    id: idSecp384r1,\n    size: 384\n});\nEcCurves.register({\n    name: \"P-521\",\n    id: idSecp521r1,\n    size: 521\n});\nEcCurves.register({\n    name: \"K-256\",\n    id: idSecp256k1,\n    size: 256\n});\nEcCurves.register({\n    name: \"brainpoolP160r1\",\n    id: idBrainpoolP160r1,\n    size: 160\n});\nEcCurves.register({\n    name: \"brainpoolP160t1\",\n    id: idBrainpoolP160t1,\n    size: 160\n});\nEcCurves.register({\n    name: \"brainpoolP192r1\",\n    id: idBrainpoolP192r1,\n    size: 192\n});\nEcCurves.register({\n    name: \"brainpoolP192t1\",\n    id: idBrainpoolP192t1,\n    size: 192\n});\nEcCurves.register({\n    name: \"brainpoolP224r1\",\n    id: idBrainpoolP224r1,\n    size: 224\n});\nEcCurves.register({\n    name: \"brainpoolP224t1\",\n    id: idBrainpoolP224t1,\n    size: 224\n});\nEcCurves.register({\n    name: \"brainpoolP256r1\",\n    id: idBrainpoolP256r1,\n    size: 256\n});\nEcCurves.register({\n    name: \"brainpoolP256t1\",\n    id: idBrainpoolP256t1,\n    size: 256\n});\nEcCurves.register({\n    name: \"brainpoolP320r1\",\n    id: idBrainpoolP320r1,\n    size: 320\n});\nEcCurves.register({\n    name: \"brainpoolP320t1\",\n    id: idBrainpoolP320t1,\n    size: 320\n});\nEcCurves.register({\n    name: \"brainpoolP384r1\",\n    id: idBrainpoolP384r1,\n    size: 384\n});\nEcCurves.register({\n    name: \"brainpoolP384t1\",\n    id: idBrainpoolP384t1,\n    size: 384\n});\nEcCurves.register({\n    name: \"brainpoolP512r1\",\n    id: idBrainpoolP512r1,\n    size: 512\n});\nEcCurves.register({\n    name: \"brainpoolP512t1\",\n    id: idBrainpoolP512t1,\n    size: 512\n});\nclass HmacProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"HMAC\";\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n        this.usages = [\n            \"sign\",\n            \"verify\"\n        ];\n    }\n    getDefaultLength(algName) {\n        switch(algName.toUpperCase()){\n            case \"SHA-1\":\n            case \"SHA-256\":\n            case \"SHA-384\":\n            case \"SHA-512\":\n                return 512;\n            default:\n                throw new Error(`Unknown algorithm name '${algName}'`);\n        }\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        if (\"length\" in algorithm) {\n            if (typeof algorithm.length !== \"number\") {\n                throw new TypeError(\"length: Is not a Number\");\n            }\n            if (algorithm.length < 1) {\n                throw new RangeError(\"length: Number is out of range\");\n            }\n        }\n    }\n    checkImportParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\nclass Pbkdf2Provider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"PBKDF2\";\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n        this.usages = [\n            \"deriveBits\",\n            \"deriveKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"salt\");\n        if (!(algorithm.salt instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.salt))) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        this.checkRequiredProperty(algorithm, \"iterations\");\n        if (typeof algorithm.iterations !== \"number\") {\n            throw new TypeError(\"iterations: Is not a Number\");\n        }\n        if (algorithm.iterations < 1) {\n            throw new TypeError(\"iterations: Is less than 1\");\n        }\n    }\n    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);\n        if (extractable) {\n            throw new SyntaxError(\"extractable: Must be 'false'\");\n        }\n    }\n}\nclass HkdfProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"HKDF\";\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n        this.usages = [\n            \"deriveKey\",\n            \"deriveBits\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"salt\");\n        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.salt)) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        this.checkRequiredProperty(algorithm, \"info\");\n        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.info)) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n    }\n    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);\n        if (extractable) {\n            throw new SyntaxError(\"extractable: Must be 'false'\");\n        }\n    }\n}\nclass ShakeProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.usages = [];\n        this.defaultLength = 0;\n    }\n    digest(...args) {\n        args[0] = {\n            length: this.defaultLength,\n            ...args[0]\n        };\n        return super.digest.apply(this, args);\n    }\n    checkDigest(algorithm, data) {\n        super.checkDigest(algorithm, data);\n        const length = algorithm.length || 0;\n        if (typeof length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (length < 0) {\n            throw new TypeError(\"length: Is negative\");\n        }\n    }\n}\nclass Shake128Provider extends ShakeProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"shake128\";\n        this.defaultLength = 16;\n    }\n}\nclass Shake256Provider extends ShakeProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"shake256\";\n        this.defaultLength = 32;\n    }\n}\nclass Crypto {\n    get [Symbol.toStringTag]() {\n        return \"Crypto\";\n    }\n    randomUUID() {\n        const b = this.getRandomValues(new Uint8Array(16));\n        b[6] = b[6] & 0x0f | 0x40;\n        b[8] = b[8] & 0x3f | 0x80;\n        const uuid = pvtsutils.Convert.ToHex(b).toLowerCase();\n        return `${uuid.substring(0, 8)}-${uuid.substring(8, 12)}-${uuid.substring(12, 16)}-${uuid.substring(16, 20)}-${uuid.substring(20)}`;\n    }\n}\nclass ProviderStorage {\n    constructor(){\n        this.items = {};\n    }\n    get(algorithmName) {\n        return this.items[algorithmName.toLowerCase()] || null;\n    }\n    set(provider) {\n        this.items[provider.name.toLowerCase()] = provider;\n    }\n    removeAt(algorithmName) {\n        const provider = this.get(algorithmName.toLowerCase());\n        if (provider) {\n            delete this.items[algorithmName];\n        }\n        return provider;\n    }\n    has(name) {\n        return !!this.get(name);\n    }\n    get length() {\n        return Object.keys(this.items).length;\n    }\n    get algorithms() {\n        const algorithms = [];\n        for(const key in this.items){\n            const provider = this.items[key];\n            algorithms.push(provider.name);\n        }\n        return algorithms.sort();\n    }\n}\nclass SubtleCrypto {\n    constructor(){\n        this.providers = new ProviderStorage();\n    }\n    static isHashedAlgorithm(data) {\n        return data && typeof data === \"object\" && \"name\" in data && \"hash\" in data ? true : false;\n    }\n    get [Symbol.toStringTag]() {\n        return \"SubtleCrypto\";\n    }\n    async digest(...args) {\n        this.checkRequiredArguments(args, 2, \"digest\");\n        const [algorithm, data, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.digest(preparedAlgorithm, preparedData, ...params);\n        return result;\n    }\n    async generateKey(...args) {\n        this.checkRequiredArguments(args, 3, \"generateKey\");\n        const [algorithm, extractable, keyUsages, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.generateKey({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, extractable, keyUsages, ...params);\n        return result;\n    }\n    async sign(...args) {\n        this.checkRequiredArguments(args, 3, \"sign\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.sign({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, key, preparedData, ...params);\n        return result;\n    }\n    async verify(...args) {\n        this.checkRequiredArguments(args, 4, \"verify\");\n        const [algorithm, key, signature, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const preparedSignature = pvtsutils.BufferSourceConverter.toArrayBuffer(signature);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.verify({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, key, preparedSignature, preparedData, ...params);\n        return result;\n    }\n    async encrypt(...args) {\n        this.checkRequiredArguments(args, 3, \"encrypt\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.encrypt({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, key, preparedData, {\n            keyUsage: true\n        }, ...params);\n        return result;\n    }\n    async decrypt(...args) {\n        this.checkRequiredArguments(args, 3, \"decrypt\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.decrypt({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, key, preparedData, {\n            keyUsage: true\n        }, ...params);\n        return result;\n    }\n    async deriveBits(...args) {\n        this.checkRequiredArguments(args, 3, \"deriveBits\");\n        const [algorithm, baseKey, length, ...params] = args;\n        this.checkCryptoKey(baseKey);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.deriveBits({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, baseKey, length, {\n            keyUsage: true\n        }, ...params);\n        return result;\n    }\n    async deriveKey(...args) {\n        this.checkRequiredArguments(args, 5, \"deriveKey\");\n        const [algorithm, baseKey, derivedKeyType, extractable, keyUsages, ...params] = args;\n        const preparedDerivedKeyType = this.prepareAlgorithm(derivedKeyType);\n        const importProvider = this.getProvider(preparedDerivedKeyType.name);\n        importProvider.checkDerivedKeyParams(preparedDerivedKeyType);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        provider.checkCryptoKey(baseKey, \"deriveKey\");\n        const derivedBits = await provider.deriveBits({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, baseKey, derivedKeyType.length || 512, {\n            keyUsage: false\n        }, ...params);\n        return this.importKey(\"raw\", derivedBits, derivedKeyType, extractable, keyUsages, ...params);\n    }\n    async exportKey(...args) {\n        this.checkRequiredArguments(args, 2, \"exportKey\");\n        const [format, key, ...params] = args;\n        this.checkCryptoKey(key);\n        const provider = this.getProvider(key.algorithm.name);\n        const result = await provider.exportKey(format, key, ...params);\n        return result;\n    }\n    async importKey(...args) {\n        this.checkRequiredArguments(args, 5, \"importKey\");\n        const [format, keyData, algorithm, extractable, keyUsages, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        if ([\n            \"pkcs8\",\n            \"spki\",\n            \"raw\"\n        ].indexOf(format) !== -1) {\n            const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);\n            return provider.importKey(format, preparedData, {\n                ...preparedAlgorithm,\n                name: provider.name\n            }, extractable, keyUsages, ...params);\n        } else {\n            if (!keyData.kty) {\n                throw new TypeError(\"keyData: Is not JSON\");\n            }\n        }\n        return provider.importKey(format, keyData, {\n            ...preparedAlgorithm,\n            name: provider.name\n        }, extractable, keyUsages, ...params);\n    }\n    async wrapKey(format, key, wrappingKey, wrapAlgorithm, ...args) {\n        let keyData = await this.exportKey(format, key, ...args);\n        if (format === \"jwk\") {\n            const json = JSON.stringify(keyData);\n            keyData = pvtsutils.Convert.FromUtf8String(json);\n        }\n        const preparedAlgorithm = this.prepareAlgorithm(wrapAlgorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        return provider.encrypt({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, wrappingKey, preparedData, {\n            keyUsage: false\n        }, ...args);\n    }\n    async unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages, ...args) {\n        const preparedAlgorithm = this.prepareAlgorithm(unwrapAlgorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(wrappedKey);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        let keyData = await provider.decrypt({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, unwrappingKey, preparedData, {\n            keyUsage: false\n        }, ...args);\n        if (format === \"jwk\") {\n            try {\n                keyData = JSON.parse(pvtsutils.Convert.ToUtf8String(keyData));\n            } catch (e) {\n                const error = new TypeError(\"wrappedKey: Is not a JSON\");\n                error.internal = e;\n                throw error;\n            }\n        }\n        return this.importKey(format, keyData, unwrappedKeyAlgorithm, extractable, keyUsages, ...args);\n    }\n    checkRequiredArguments(args, size, methodName) {\n        if (args.length < size) {\n            throw new TypeError(`Failed to execute '${methodName}' on 'SubtleCrypto': ${size} arguments required, but only ${args.length} present`);\n        }\n    }\n    prepareAlgorithm(algorithm) {\n        if (typeof algorithm === \"string\") {\n            return {\n                name: algorithm\n            };\n        }\n        if (SubtleCrypto.isHashedAlgorithm(algorithm)) {\n            const preparedAlgorithm = {\n                ...algorithm\n            };\n            preparedAlgorithm.hash = this.prepareAlgorithm(algorithm.hash);\n            return preparedAlgorithm;\n        }\n        return {\n            ...algorithm\n        };\n    }\n    getProvider(name) {\n        const provider = this.providers.get(name);\n        if (!provider) {\n            throw new AlgorithmError(\"Unrecognized name\");\n        }\n        return provider;\n    }\n    checkCryptoKey(key) {\n        if (!(key instanceof CryptoKey)) {\n            throw new TypeError(`Key is not of type 'CryptoKey'`);\n        }\n    }\n}\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    converters: index$3\n});\nconst REQUIRED_FIELDS = [\n    \"crv\",\n    \"e\",\n    \"k\",\n    \"kty\",\n    \"n\",\n    \"x\",\n    \"y\"\n];\nclass JwkUtils {\n    static async thumbprint(hash, jwk, crypto) {\n        const data = this.format(jwk, true);\n        return crypto.subtle.digest(hash, pvtsutils.Convert.FromBinary(JSON.stringify(data)));\n    }\n    static format(jwk, remove = false) {\n        let res = Object.entries(jwk);\n        if (remove) {\n            res = res.filter((o)=>REQUIRED_FIELDS.includes(o[0]));\n        }\n        res = res.sort(([keyA], [keyB])=>keyA > keyB ? 1 : keyA < keyB ? -1 : 0);\n        return Object.fromEntries(res);\n    }\n}\nObject.defineProperty(exports, \"BufferSourceConverter\", ({\n    enumerable: true,\n    get: function() {\n        return pvtsutils.BufferSourceConverter;\n    }\n}));\nexports.AesCbcProvider = AesCbcProvider;\nexports.AesCmacProvider = AesCmacProvider;\nexports.AesCtrProvider = AesCtrProvider;\nexports.AesEcbProvider = AesEcbProvider;\nexports.AesGcmProvider = AesGcmProvider;\nexports.AesKwProvider = AesKwProvider;\nexports.AesProvider = AesProvider;\nexports.AlgorithmError = AlgorithmError;\nexports.Crypto = Crypto;\nexports.CryptoError = CryptoError;\nexports.CryptoKey = CryptoKey;\nexports.DesProvider = DesProvider;\nexports.EcCurves = EcCurves;\nexports.EcUtils = EcUtils;\nexports.EcdhEsProvider = EcdhEsProvider;\nexports.EcdhProvider = EcdhProvider;\nexports.EcdsaProvider = EcdsaProvider;\nexports.EdDsaProvider = EdDsaProvider;\nexports.EllipticProvider = EllipticProvider;\nexports.HkdfProvider = HkdfProvider;\nexports.HmacProvider = HmacProvider;\nexports.JwkUtils = JwkUtils;\nexports.OperationError = OperationError;\nexports.Pbkdf2Provider = Pbkdf2Provider;\nexports.PemConverter = PemConverter;\nexports.ProviderCrypto = ProviderCrypto;\nexports.ProviderStorage = ProviderStorage;\nexports.RequiredPropertyError = RequiredPropertyError;\nexports.RsaOaepProvider = RsaOaepProvider;\nexports.RsaProvider = RsaProvider;\nexports.RsaPssProvider = RsaPssProvider;\nexports.RsaSsaProvider = RsaSsaProvider;\nexports.Shake128Provider = Shake128Provider;\nexports.Shake256Provider = Shake256Provider;\nexports.ShakeProvider = ShakeProvider;\nexports.SubtleCrypto = SubtleCrypto;\nexports.UnsupportedOperationError = UnsupportedOperationError;\nexports.asn1 = index$1;\nexports.isJWK = isJWK;\nexports.json = index;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViY3J5cHRvLWNvcmUvYnVpbGQvd2ViY3J5cHRvLWNvcmUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsR0FFQTtBQUVBLElBQUlBLFlBQVlDLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlDLGFBQWFELG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlHLGFBQWFILG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlJLE9BQU9KLG1CQUFPQSxDQUFDO0FBRW5CLFNBQVNLLHlCQUF5QkMsQ0FBQztJQUNqQyxJQUFJQyxJQUFJQyxPQUFPQyxNQUFNLENBQUM7SUFDdEIsSUFBSUgsR0FBRztRQUNMRSxPQUFPRSxJQUFJLENBQUNKLEdBQUdLLE9BQU8sQ0FBQyxTQUFVQyxDQUFDO1lBQ2hDLElBQUlBLE1BQU0sV0FBVztnQkFDbkIsSUFBSUMsSUFBSUwsT0FBT00sd0JBQXdCLENBQUNSLEdBQUdNO2dCQUMzQ0osT0FBT08sY0FBYyxDQUFDUixHQUFHSyxHQUFHQyxFQUFFRyxHQUFHLEdBQUdILElBQUk7b0JBQ3RDSSxZQUFZO29CQUNaRCxLQUFLO3dCQUFjLE9BQU9WLENBQUMsQ0FBQ00sRUFBRTtvQkFBRTtnQkFDbEM7WUFDRjtRQUNGO0lBQ0Y7SUFDQUwsRUFBRVcsT0FBTyxHQUFHWjtJQUNaLE9BQU9FLE9BQU9XLE1BQU0sQ0FBQ1o7QUFDdkI7QUFFQSxJQUFJYSxrQkFBa0IsV0FBVyxHQUFFZix5QkFBeUJEO0FBRTVELE1BQU1pQixvQkFBb0JDO0FBQzFCO0FBRUEsTUFBTUMsdUJBQXVCRjtBQUM3QjtBQUVBLE1BQU1HLGtDQUFrQ0g7SUFDcENJLFlBQVlDLFVBQVUsQ0FBRTtRQUNwQixLQUFLLENBQUMsQ0FBQyx1QkFBdUIsRUFBRUEsYUFBYSxDQUFDLEVBQUVBLFdBQVcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUN2RTtBQUNKO0FBRUEsTUFBTUMsdUJBQXVCTjtBQUM3QjtBQUVBLE1BQU1P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QWdCLEdBQUdwRjtBQUNuQm9GLGVBQWUsR0FBRzVJO0FBQ2xCNEksc0JBQXNCLEdBQUczTTtBQUN6QjJNLG9CQUFvQixHQUFHN007QUFDdkI2TSxxQkFBcUIsR0FBR3BOO0FBQ3hCb04scUJBQXFCLEdBQUcxTTtBQUN4QjBNLHdCQUF3QixHQUFHeE47QUFDM0J3TixvQkFBb0IsR0FBR2xFO0FBQ3ZCa0Usb0JBQW9CLEdBQUd6RTtBQUN2QnlFLGdCQUFnQixHQUFHYjtBQUNuQmEsc0JBQXNCLEdBQUcvVjtBQUN6QitWLHNCQUFzQixHQUFHdEU7QUFDekJzRSxvQkFBb0IsR0FBRzVWO0FBQ3ZCNFYsc0JBQXNCLEdBQUd2VDtBQUN6QnVULHVCQUF1QixHQUFHckQ7QUFDMUJxRCw2QkFBNkIsR0FBRzlWO0FBQ2hDOFYsdUJBQXVCLEdBQUcxTjtBQUMxQjBOLG1CQUFtQixHQUFHbE87QUFDdEJrTyxzQkFBc0IsR0FBRzdOO0FBQ3pCNk4sc0JBQXNCLEdBQUc5TjtBQUN6QjhOLHdCQUF3QixHQUFHOUQ7QUFDM0I4RCx3QkFBd0IsR0FBRzdEO0FBQzNCNkQscUJBQXFCLEdBQUdoRTtBQUN4QmdFLG9CQUFvQixHQUFHOUM7QUFDdkI4QyxpQ0FBaUMsR0FBR2xXO0FBQ3BDa1csWUFBWSxHQUFHdEY7QUFDZnNGLGFBQWEsR0FBR3hUO0FBQ2hCd1QsWUFBWSxHQUFHZiIsInNvdXJjZXMiOlsid2VicGFjazovL215dGFza3MvLi9ub2RlX21vZHVsZXMvd2ViY3J5cHRvLWNvcmUvYnVpbGQvd2ViY3J5cHRvLWNvcmUuanM/OGRlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiBDb3B5cmlnaHQgKGMpIFBlY3VsaWFyIFZlbnR1cmVzLCBMTENcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB2dHN1dGlscyA9IHJlcXVpcmUoJ3B2dHN1dGlscycpO1xudmFyIGFzbjFTY2hlbWEgPSByZXF1aXJlKCdAcGVjdWxpYXIvYXNuMS1zY2hlbWEnKTtcbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIganNvblNjaGVtYSA9IHJlcXVpcmUoJ0BwZWN1bGlhci9qc29uLXNjaGVtYScpO1xudmFyIGFzbjEgPSByZXF1aXJlKCdhc24xanMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGUpIHtcbiAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG4uZGVmYXVsdCA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgYXNuMV9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChhc24xKTtcblxuY2xhc3MgQ3J5cHRvRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5cbmNsYXNzIEFsZ29yaXRobUVycm9yIGV4dGVuZHMgQ3J5cHRvRXJyb3Ige1xufVxuXG5jbGFzcyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yIGV4dGVuZHMgQ3J5cHRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgc3VwZXIoYFVuc3VwcG9ydGVkIG9wZXJhdGlvbjogJHttZXRob2ROYW1lID8gYCR7bWV0aG9kTmFtZX1gIDogXCJcIn1gKTtcbiAgICB9XG59XG5cbmNsYXNzIE9wZXJhdGlvbkVycm9yIGV4dGVuZHMgQ3J5cHRvRXJyb3Ige1xufVxuXG5jbGFzcyBSZXF1aXJlZFByb3BlcnR5RXJyb3IgZXh0ZW5kcyBDcnlwdG9FcnJvciB7XG4gICAgY29uc3RydWN0b3IocHJvcE5hbWUpIHtcbiAgICAgICAgc3VwZXIoYCR7cHJvcE5hbWV9OiBNaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5YCk7XG4gICAgfVxufVxuXG5jbGFzcyBQZW1Db252ZXJ0ZXIge1xuICAgIHN0YXRpYyB0b0FycmF5QnVmZmVyKHBlbSkge1xuICAgICAgICBjb25zdCBiYXNlNjQgPSBwZW1cbiAgICAgICAgICAgIC5yZXBsYWNlKC8tezV9KEJFR0lOfEVORCkgLiotezV9L2csIFwiXCIpXG4gICAgICAgICAgICAucmVwbGFjZShcIlxcclwiLCBcIlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoXCJcXG5cIiwgXCJcIik7XG4gICAgICAgIHJldHVybiBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0KGJhc2U2NCk7XG4gICAgfVxuICAgIHN0YXRpYyB0b1VpbnQ4QXJyYXkocGVtKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy50b0FycmF5QnVmZmVyKHBlbSk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnVmZmVyU291cmNlKGJ1ZmZlciwgdGFnKSB7XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0KGJ1ZmZlcik7XG4gICAgICAgIGxldCBzbGljZWQ7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCByb3dzID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBzbGljZWQgPSBiYXNlNjQuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgPSBvZmZzZXQgKyA2NCk7XG4gICAgICAgICAgICBpZiAoc2xpY2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJvd3MucHVzaChzbGljZWQpO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZWQubGVuZ3RoIDwgNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBwZXJDYXNlVGFnID0gdGFnLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBgLS0tLS1CRUdJTiAke3VwcGVyQ2FzZVRhZ30tLS0tLVxcbiR7cm93cy5qb2luKFwiXFxuXCIpfVxcbi0tLS0tRU5EICR7dXBwZXJDYXNlVGFnfS0tLS0tYDtcbiAgICB9XG4gICAgc3RhdGljIGlzUEVNKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIC8tLS0tLUJFR0lOIC4rLS0tLS1bQS1aYS16MC05K1xcL1xcK1xcPVxcc1xcbl0rLS0tLS1FTkQgListLS0tLS9pLnRlc3QoZGF0YSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRUYWdOYW1lKHBlbSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNQRU0ocGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIHBhcmFtZXRlci4gSW5jb21pbmcgZGF0YSBpcyBub3QgcmlnaHQgUEVNXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IC8tLS0tLUJFR0lOICguKyktLS0tLS8uZXhlYyhwZW0pO1xuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0YWcgZnJvbSBQRU1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc1sxXTtcbiAgICB9XG4gICAgc3RhdGljIGhhc1RhZ05hbWUocGVtLCB0YWdOYW1lKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHRoaXMuZ2V0VGFnTmFtZShwZW0pO1xuICAgICAgICByZXR1cm4gdGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQ2VydGlmaWNhdGUocGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1RhZ05hbWUocGVtLCBcImNlcnRpZmljYXRlXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNDZXJ0aWZpY2F0ZVJlcXVlc3QocGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1RhZ05hbWUocGVtLCBcImNlcnRpZmljYXRlIHJlcXVlc3RcIik7XG4gICAgfVxuICAgIHN0YXRpYyBpc0NSTChwZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzVGFnTmFtZShwZW0sIFwieDUwOSBjcmxcIik7XG4gICAgfVxuICAgIHN0YXRpYyBpc1B1YmxpY0tleShwZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzVGFnTmFtZShwZW0sIFwicHVibGljIGtleVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzSldLKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgXCJrdHlcIiBpbiBkYXRhO1xufVxuXG5jbGFzcyBQcm92aWRlckNyeXB0byB7XG4gICAgYXN5bmMgZGlnZXN0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0RpZ2VzdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25EaWdlc3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgIH1cbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJkaWdlc3RcIik7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlS2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0dlbmVyYXRlS2V5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vbkdlbmVyYXRlS2V5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0dlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKTtcbiAgICAgICAgaWYgKCEoa2V5VXNhZ2VzICYmIGtleVVzYWdlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVc2FnZXMgY2Fubm90IGJlIGVtcHR5IHdoZW4gY3JlYXRpbmcgYSBrZXkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFsbG93ZWRVc2FnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudXNhZ2VzKSkge1xuICAgICAgICAgICAgYWxsb3dlZFVzYWdlcyA9IHRoaXMudXNhZ2VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWxsb3dlZFVzYWdlcyA9IHRoaXMudXNhZ2VzLnByaXZhdGVLZXkuY29uY2F0KHRoaXMudXNhZ2VzLnB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0tleVVzYWdlcyhrZXlVc2FnZXMsIGFsbG93ZWRVc2FnZXMpO1xuICAgIH1cbiAgICBjaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSkge1xuICAgIH1cbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4uYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihcImdlbmVyYXRlS2V5XCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1NpZ24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uU2lnbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2hlY2tTaWduKGFsZ29yaXRobSwga2V5LCBkYXRhLCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXksIFwic2lnblwiKTtcbiAgICB9XG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhLCAuLi5hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwic2lnblwiKTtcbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1ZlcmlmeS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25WZXJpZnkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSwgXCJ2ZXJpZnlcIik7XG4gICAgfVxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJ2ZXJpZnlcIik7XG4gICAgfVxuICAgIGFzeW5jIGVuY3J5cHQoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrRW5jcnlwdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25FbmNyeXB0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0VuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEsIG9wdGlvbnMgPSB7fSwgLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5LCBvcHRpb25zLmtleVVzYWdlID8gXCJlbmNyeXB0XCIgOiB2b2lkIDApO1xuICAgIH1cbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJlbmNyeXB0XCIpO1xuICAgIH1cbiAgICBhc3luYyBkZWNyeXB0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0RlY3J5cHQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uRGVjcnlwdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2hlY2tEZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhLCBvcHRpb25zID0ge30sIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSwgb3B0aW9ucy5rZXlVc2FnZSA/IFwiZGVjcnlwdFwiIDogdm9pZCAwKTtcbiAgICB9XG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhLCAuLi5hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwiZGVjcnlwdFwiKTtcbiAgICB9XG4gICAgYXN5bmMgZGVyaXZlQml0cyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXJpdmVCaXRzLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vbkRlcml2ZUJpdHMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrRGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCwgb3B0aW9ucyA9IHt9LCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShiYXNlS2V5LCBvcHRpb25zLmtleVVzYWdlID8gXCJkZXJpdmVCaXRzXCIgOiB2b2lkIDApO1xuICAgICAgICBpZiAobGVuZ3RoICUgOCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKFwibGVuZ3RoOiBJcyBub3QgbXVsdGlwbGUgb2YgOFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvbkRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJkZXJpdmVCaXRzXCIpO1xuICAgIH1cbiAgICBhc3luYyBleHBvcnRLZXkoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrRXhwb3J0S2V5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vbkV4cG9ydEtleS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2hlY2tFeHBvcnRLZXkoZm9ybWF0LCBrZXksIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0tleUZvcm1hdChmb3JtYXQpO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGlmICgha2V5LmV4dHJhY3RhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3J5cHRvRXJyb3IoXCJrZXk6IElzIG5vdCBleHRyYWN0YWJsZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSwgLi4uYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihcImV4cG9ydEtleVwiKTtcbiAgICB9XG4gICAgYXN5bmMgaW1wb3J0S2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0ltcG9ydEtleS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25JbXBvcnRLZXkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tLZXlGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5jaGVja0tleURhdGEoZm9ybWF0LCBrZXlEYXRhKTtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0ltcG9ydFBhcmFtcyhhbGdvcml0aG0pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnVzYWdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tLZXlVc2FnZXMoa2V5VXNhZ2VzLCB0aGlzLnVzYWdlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJpbXBvcnRLZXlcIik7XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pIHtcbiAgICAgICAgaWYgKGFsZ29yaXRobS5uYW1lLnRvTG93ZXJDYXNlKCkgIT09IHRoaXMubmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWxnb3JpdGhtRXJyb3IoXCJVbnJlY29nbml6ZWQgbmFtZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICB9XG4gICAgY2hlY2tEZXJpdmVkS2V5UGFyYW1zKGFsZ29yaXRobSkge1xuICAgIH1cbiAgICBjaGVja0tleVVzYWdlcyh1c2FnZXMsIGFsbG93ZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCB1c2FnZSBvZiB1c2FnZXMpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd2VkLmluZGV4T2YodXNhZ2UpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY3JlYXRlIGEga2V5IHVzaW5nIHRoZSBzcGVjaWZpZWQga2V5IHVzYWdlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGtleS5hbGdvcml0aG0pO1xuICAgICAgICBpZiAoa2V5VXNhZ2UgJiYga2V5LnVzYWdlcy5pbmRleE9mKGtleVVzYWdlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDcnlwdG9FcnJvcihga2V5IGRvZXMgbm90IG1hdGNoIHRoYXQgb2Ygb3BlcmF0aW9uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tSZXF1aXJlZFByb3BlcnR5KGRhdGEsIHByb3BOYW1lKSB7XG4gICAgICAgIGlmICghKHByb3BOYW1lIGluIGRhdGEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRQcm9wZXJ0eUVycm9yKHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLCBoYXNoQWxnb3JpdGhtcykge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaGFzaEFsZ29yaXRobXMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnRvTG93ZXJDYXNlKCkgPT09IGFsZ29yaXRobS5uYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGBoYXNoOiBNdXN0IGJlIG9uZSBvZiAke2hhc2hBbGdvcml0aG1zLmpvaW4oXCIsIFwiKX1gKTtcbiAgICB9XG4gICAgY2hlY2tJbXBvcnRQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgfVxuICAgIGNoZWNrS2V5Rm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSBcInJhd1wiOlxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6XG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOlxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZm9ybWF0OiBJcyBpbnZhbGlkIHZhbHVlLiBNdXN0IGJlICdqd2snLCAncmF3JywgJ3Nwa2knLCBvciAncGtjczgnXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrS2V5RGF0YShmb3JtYXQsIGtleURhdGEpIHtcbiAgICAgICAgaWYgKCFrZXlEYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5RGF0YTogQ2Fubm90IGJlIGVtcHR5IG9uIGVtcHR5IG9uIGtleSBpbXBvcnRpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqd2tcIikge1xuICAgICAgICAgICAgaWYgKCFpc0pXSyhrZXlEYXRhKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXlEYXRhOiBJcyBub3QgSnNvbldlYlRva2VuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLmlzQnVmZmVyU291cmNlKGtleURhdGEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5RGF0YTogSXMgbm90IEFycmF5QnVmZmVyVmlldyBvciBBcnJheUJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmVwYXJlRGF0YShkYXRhKSB7XG4gICAgICAgIHJldHVybiBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgfVxufVxuXG5jbGFzcyBBZXNQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwibGVuZ3RoXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobS5sZW5ndGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IElzIG5vdCBvZiB0eXBlIE51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTI4OlxuICAgICAgICAgICAgY2FzZSAxOTI6XG4gICAgICAgICAgICBjYXNlIDI1NjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxlbmd0aDogTXVzdCBiZSAxMjgsIDE5Miwgb3IgMjU2XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrRGVyaXZlZEtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSk7XG4gICAgfVxufVxuXG5jbGFzcyBBZXNDYmNQcm92aWRlciBleHRlbmRzIEFlc1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBRVMtQ0JDXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIiwgXCJ3cmFwS2V5XCIsIFwidW53cmFwS2V5XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIml2XCIpO1xuICAgICAgICBpZiAoIShhbGdvcml0aG0uaXYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYWxnb3JpdGhtLml2KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpdjogSXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLml2LmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXY6IE11c3QgaGF2ZSBsZW5ndGggMTYgYnl0ZXNcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFlc0NtYWNQcm92aWRlciBleHRlbmRzIEFlc1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBRVMtQ01BQ1wiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwibGVuZ3RoXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobS5sZW5ndGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IElzIG5vdCBhIE51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcImxlbmd0aDogTXVzdCBiZSBtb3JlIHRoYW4gMFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQWVzQ3RyUHJvdmlkZXIgZXh0ZW5kcyBBZXNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQUVTLUNUUlwiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCIsIFwid3JhcEtleVwiLCBcInVud3JhcEtleVwiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJjb3VudGVyXCIpO1xuICAgICAgICBpZiAoIShhbGdvcml0aG0uY291bnRlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhhbGdvcml0aG0uY291bnRlcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY291bnRlcjogSXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLmNvdW50ZXIuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpdjogTXVzdCBoYXZlIGxlbmd0aCAxNiBieXRlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwibGVuZ3RoXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobS5sZW5ndGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IElzIG5vdCBhIE51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcImxlbmd0aDogTXVzdCBiZSBtb3JlIHRoYW4gMFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQWVzRWNiUHJvdmlkZXIgZXh0ZW5kcyBBZXNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQUVTLUVDQlwiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCIsIFwid3JhcEtleVwiLCBcInVud3JhcEtleVwiXTtcbiAgICB9XG59XG5cbmNsYXNzIEFlc0djbVByb3ZpZGVyIGV4dGVuZHMgQWVzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFFUy1HQ01cIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiLCBcIndyYXBLZXlcIiwgXCJ1bndyYXBLZXlcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaXZcIik7XG4gICAgICAgIGlmICghKGFsZ29yaXRobS5pdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhhbGdvcml0aG0uaXYpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIml2OiBJcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0uaXYuYnl0ZUxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcIml2OiBNdXN0IGhhdmUgbGVuZ3RoIG1vcmUgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMl42NCAtIDFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoXCJ0YWdMZW5ndGhcIiBpbiBhbGdvcml0aG0pKSB7XG4gICAgICAgICAgICBhbGdvcml0aG0udGFnTGVuZ3RoID0gMTI4O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLnRhZ0xlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICBjYXNlIDk2OlxuICAgICAgICAgICAgY2FzZSAxMDQ6XG4gICAgICAgICAgICBjYXNlIDExMjpcbiAgICAgICAgICAgIGNhc2UgMTIwOlxuICAgICAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcInRhZ0xlbmd0aDogTXVzdCBiZSBvbmUgb2YgMzIsIDY0LCA5NiwgMTA0LCAxMTIsIDEyMCBvciAxMjhcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFlc0t3UHJvdmlkZXIgZXh0ZW5kcyBBZXNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQUVTLUtXXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wid3JhcEtleVwiLCBcInVud3JhcEtleVwiXTtcbiAgICB9XG59XG5cbmNsYXNzIERlc1Byb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCIsIFwid3JhcEtleVwiLCBcInVud3JhcEtleVwiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIGlmICh0aGlzLml2U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIml2XCIpO1xuICAgICAgICAgICAgaWYgKCEoYWxnb3JpdGhtLml2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGFsZ29yaXRobS5pdikpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIml2OiBJcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsZ29yaXRobS5pdi5ieXRlTGVuZ3RoICE9PSB0aGlzLml2U2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGl2OiBNdXN0IGhhdmUgbGVuZ3RoICR7dGhpcy5pdlNpemV9IGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImxlbmd0aFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0ubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBJcyBub3Qgb2YgdHlwZSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5sZW5ndGggIT09IHRoaXMua2V5U2l6ZUJpdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgYWxnb3JpdGhtLmxlbmd0aDogTXVzdCBiZSAke3RoaXMua2V5U2l6ZUJpdHN9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tEZXJpdmVkS2V5UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKTtcbiAgICB9XG59XG5cbmNsYXNzIFJzYVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhhc2hBbGdvcml0aG1zID0gW1wiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIl07XG4gICAgfVxuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJoYXNoXCIpO1xuICAgICAgICB0aGlzLmNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0uaGFzaCwgdGhpcy5oYXNoQWxnb3JpdGhtcyk7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJwdWJsaWNFeHBvbmVudFwiKTtcbiAgICAgICAgaWYgKCEoYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50ICYmIGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHVibGljRXhwb25lbnQ6IE1pc3Npbmcgb3Igbm90IGEgVWludDhBcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWJsaWNFeHBvbmVudCA9IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0KGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCk7XG4gICAgICAgIGlmICghKHB1YmxpY0V4cG9uZW50ID09PSBcIkF3PT1cIiB8fCBwdWJsaWNFeHBvbmVudCA9PT0gXCJBUUFCXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHVibGljRXhwb25lbnQ6IE11c3QgYmUgWzNdIG9yIFsxLDAsMV1cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIm1vZHVsdXNMZW5ndGhcIik7XG4gICAgICAgIGlmIChhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCAlIDhcbiAgICAgICAgICAgIHx8IGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoIDwgMjU2XG4gICAgICAgICAgICB8fCBhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA+IDE2Mzg0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIG1vZHVsdXMgbGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA4IGJpdHMgYW5kID49IDI1NiBhbmQgPD0gMTYzODRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tJbXBvcnRQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJoYXNoXCIpO1xuICAgICAgICB0aGlzLmNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0uaGFzaCwgdGhpcy5oYXNoQWxnb3JpdGhtcyk7XG4gICAgfVxufVxuXG5jbGFzcyBSc2FTc2FQcm92aWRlciBleHRlbmRzIFJzYVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSU0FTU0EtUEtDUzEtdjFfNVwiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IFtcInNpZ25cIl0sXG4gICAgICAgICAgICBwdWJsaWNLZXk6IFtcInZlcmlmeVwiXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNsYXNzIFJzYVBzc1Byb3ZpZGVyIGV4dGVuZHMgUnNhUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJTQS1QU1NcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJzaWduXCJdLFxuICAgICAgICAgICAgcHVibGljS2V5OiBbXCJ2ZXJpZnlcIl0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwic2FsdExlbmd0aFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0uc2FsdExlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNhbHRMZW5ndGg6IElzIG5vdCBhIE51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLnNhbHRMZW5ndGggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNhbHRMZW5ndGg6IE11c3QgYmUgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBSc2FPYWVwUHJvdmlkZXIgZXh0ZW5kcyBSc2FQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUlNBLU9BRVBcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJkZWNyeXB0XCIsIFwidW53cmFwS2V5XCJdLFxuICAgICAgICAgICAgcHVibGljS2V5OiBbXCJlbmNyeXB0XCIsIFwid3JhcEtleVwiXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIGlmIChhbGdvcml0aG0ubGFiZWxcbiAgICAgICAgICAgICYmICEoYWxnb3JpdGhtLmxhYmVsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGFsZ29yaXRobS5sYWJlbCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGFiZWw6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEVsbGlwdGljUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckNyeXB0byB7XG4gICAgY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIm5hbWVkQ3VydmVcIik7XG4gICAgICAgIHRoaXMuY2hlY2tOYW1lZEN1cnZlKGFsZ29yaXRobS5uYW1lZEN1cnZlKTtcbiAgICB9XG4gICAgY2hlY2tOYW1lZEN1cnZlKG5hbWVkQ3VydmUpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMubmFtZWRDdXJ2ZXMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnRvTG93ZXJDYXNlKCkgPT09IG5hbWVkQ3VydmUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYG5hbWVkQ3VydmU6IE11c3QgYmUgb25lIG9mICR7dGhpcy5uYW1lZEN1cnZlcy5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxufVxuXG5jbGFzcyBFY2RzYVByb3ZpZGVyIGV4dGVuZHMgRWxsaXB0aWNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiRUNEU0FcIjtcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCJdO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IFtcInNpZ25cIl0sXG4gICAgICAgICAgICBwdWJsaWNLZXk6IFtcInZlcmlmeVwiXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lZEN1cnZlcyA9IFtcIlAtMjU2XCIsIFwiUC0zODRcIiwgXCJQLTUyMVwiLCBcIkstMjU2XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImhhc2hcIik7XG4gICAgICAgIHRoaXMuY2hlY2tIYXNoQWxnb3JpdGhtKGFsZ29yaXRobS5oYXNoLCB0aGlzLmhhc2hBbGdvcml0aG1zKTtcbiAgICB9XG59XG5cbmNvbnN0IEtFWV9UWVBFUyA9IFtcInNlY3JldFwiLCBcInByaXZhdGVcIiwgXCJwdWJsaWNcIl07XG5jbGFzcyBDcnlwdG9LZXkge1xuICAgIHN0YXRpYyBjcmVhdGUoYWxnb3JpdGhtLCB0eXBlLCBleHRyYWN0YWJsZSwgdXNhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyB0aGlzKCk7XG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XG4gICAgICAgIGtleS50eXBlID0gdHlwZTtcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XG4gICAgICAgIGtleS51c2FnZXMgPSB1c2FnZXM7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0tleVR5cGUoZGF0YSkge1xuICAgICAgICByZXR1cm4gS0VZX1RZUEVTLmluZGV4T2YoZGF0YSkgIT09IC0xO1xuICAgIH1cbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBcIkNyeXB0b0tleVwiO1xuICAgIH1cbn1cblxuY2xhc3MgRWNkaFByb3ZpZGVyIGV4dGVuZHMgRWxsaXB0aWNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiRUNESFwiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IFtcImRlcml2ZUJpdHNcIiwgXCJkZXJpdmVLZXlcIl0sXG4gICAgICAgICAgICBwdWJsaWNLZXk6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWVkQ3VydmVzID0gW1wiUC0yNTZcIiwgXCJQLTM4NFwiLCBcIlAtNTIxXCIsIFwiSy0yNTZcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwicHVibGljXCIpO1xuICAgICAgICBpZiAoIShhbGdvcml0aG0ucHVibGljIGluc3RhbmNlb2YgQ3J5cHRvS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInB1YmxpYzogSXMgbm90IGEgQ3J5cHRvS2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0ucHVibGljLnR5cGUgIT09IFwicHVibGljXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcInB1YmxpYzogSXMgbm90IGEgcHVibGljIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLnB1YmxpYy5hbGdvcml0aG0ubmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYHB1YmxpYzogSXMgbm90ICR7dGhpcy5uYW1lfSBrZXlgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgRWNkaEVzUHJvdmlkZXIgZXh0ZW5kcyBFY2RoUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkVDREgtRVNcIjtcbiAgICAgICAgdGhpcy5uYW1lZEN1cnZlcyA9IFtcIlgyNTUxOVwiLCBcIlg0NDhcIl07XG4gICAgfVxufVxuXG5jbGFzcyBFZERzYVByb3ZpZGVyIGV4dGVuZHMgRWxsaXB0aWNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiRWREU0FcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJzaWduXCJdLFxuICAgICAgICAgICAgcHVibGljS2V5OiBbXCJ2ZXJpZnlcIl0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmFtZWRDdXJ2ZXMgPSBbXCJFZDI1NTE5XCIsIFwiRWQ0NDhcIl07XG4gICAgfVxufVxuXG5sZXQgT2JqZWN0SWRlbnRpZmllciA9IGNsYXNzIE9iamVjdElkZW50aWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLk9iamVjdElkZW50aWZpZXIgfSlcbl0sIE9iamVjdElkZW50aWZpZXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5PYmplY3RJZGVudGlmaWVyID0gdHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25UeXBlKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25UeXBlVHlwZXMuQ2hvaWNlIH0pXG5dLCBPYmplY3RJZGVudGlmaWVyKTtcblxuY2xhc3MgQWxnb3JpdGhtSWRlbnRpZmllciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1zKTtcbiAgICB9XG59XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3Aoe1xuICAgICAgICB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5PYmplY3RJZGVudGlmaWVyLFxuICAgIH0pXG5dLCBBbGdvcml0aG1JZGVudGlmaWVyLnByb3RvdHlwZSwgXCJhbGdvcml0aG1cIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7XG4gICAgICAgIHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkFueSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgfSlcbl0sIEFsZ29yaXRobUlkZW50aWZpZXIucHJvdG90eXBlLCBcInBhcmFtZXRlcnNcIiwgdm9pZCAwKTtcblxuY2xhc3MgUHJpdmF0ZUtleUluZm8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgICAgICB0aGlzLnByaXZhdGVLZXlBbGdvcml0aG0gPSBuZXcgQWxnb3JpdGhtSWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLnByaXZhdGVLZXkgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciB9KVxuXSwgUHJpdmF0ZUtleUluZm8ucHJvdG90eXBlLCBcInZlcnNpb25cIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IEFsZ29yaXRobUlkZW50aWZpZXIgfSlcbl0sIFByaXZhdGVLZXlJbmZvLnByb3RvdHlwZSwgXCJwcml2YXRlS2V5QWxnb3JpdGhtXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5PY3RldFN0cmluZyB9KVxuXSwgUHJpdmF0ZUtleUluZm8ucHJvdG90eXBlLCBcInByaXZhdGVLZXlcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkFueSwgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFByaXZhdGVLZXlJbmZvLnByb3RvdHlwZSwgXCJhdHRyaWJ1dGVzXCIsIHZvaWQgMCk7XG5cbmNsYXNzIFB1YmxpY0tleUluZm8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnB1YmxpY0tleUFsZ29yaXRobSA9IG5ldyBBbGdvcml0aG1JZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbn1cbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IEFsZ29yaXRobUlkZW50aWZpZXIgfSlcbl0sIFB1YmxpY0tleUluZm8ucHJvdG90eXBlLCBcInB1YmxpY0tleUFsZ29yaXRobVwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuQml0U3RyaW5nIH0pXG5dLCBQdWJsaWNLZXlJbmZvLnByb3RvdHlwZSwgXCJwdWJsaWNLZXlcIiwgdm9pZCAwKTtcblxuY29uc3QgSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyID0ge1xuICAgIGZyb21KU09OOiAodmFsdWUpID0+IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwodmFsdWUpLFxuICAgIHRvSlNPTjogKHZhbHVlKSA9PiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybChuZXcgVWludDhBcnJheSh2YWx1ZSkpLFxufTtcblxuY29uc3QgQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZUhleCA9IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXg7XG4gICAgICAgIHJldHVybiAhKG5ldyBVaW50OEFycmF5KHZhbHVlSGV4KVswXSlcbiAgICAgICAgICAgID8gdmFsdWUudmFsdWVCbG9jay52YWx1ZUhleC5zbGljZSgxKVxuICAgICAgICAgICAgOiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4O1xuICAgIH0sXG4gICAgdG9BU046ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZUhleCA9IG5ldyBVaW50OEFycmF5KHZhbHVlKVswXSA+IDEyN1xuICAgICAgICAgICAgPyBwdnRzdXRpbHMuY29tYmluZShuZXcgVWludDhBcnJheShbMF0pLmJ1ZmZlciwgdmFsdWUpXG4gICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFfX25hbWVzcGFjZS5JbnRlZ2VyKHsgdmFsdWVIZXggfSk7XG4gICAgfSxcbn07XG5cbnZhciBpbmRleCQzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyLFxuICBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlclxufSk7XG5cbmNsYXNzIFJzYVByaXZhdGVLZXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgICAgICB0aGlzLm1vZHVsdXMgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMucHVibGljRXhwb25lbnQgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMucHJpdmF0ZUV4cG9uZW50ID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLnByaW1lMSA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5wcmltZTIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMuZXhwb25lbnQxID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLmV4cG9uZW50MiA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5jb2VmZmljaWVudCA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG59XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IGFzbjFTY2hlbWEuQXNuSW50ZWdlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwidmVyc2lvblwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwiblwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwibW9kdWx1c1wiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwiZVwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwicHVibGljRXhwb25lbnRcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImRcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcInByaXZhdGVFeHBvbmVudFwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwicFwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwicHJpbWUxXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJxXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJwcmltZTJcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImRwXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJleHBvbmVudDFcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImRxXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJleHBvbmVudDJcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcInFpXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJjb2VmZmljaWVudFwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuQW55LCBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwib3RoZXJQcmltZUluZm9zXCIsIHZvaWQgMCk7XG5cbmNsYXNzIFJzYVB1YmxpY0tleSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubW9kdWx1cyA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5wdWJsaWNFeHBvbmVudCA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG59XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJuXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQdWJsaWNLZXkucHJvdG90eXBlLCBcIm1vZHVsdXNcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImVcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVB1YmxpY0tleS5wcm90b3R5cGUsIFwicHVibGljRXhwb25lbnRcIiwgdm9pZCAwKTtcblxubGV0IEVjUHVibGljS2V5ID0gY2xhc3MgRWNQdWJsaWNLZXkge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy52YWx1ZSk7XG4gICAgICAgIGlmIChieXRlc1swXSAhPT0gMHgwNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0Vycm9yKFwiV3JvbmcgRUNQb2ludC4gQ3VycmVudCB2ZXJzaW9uIHN1cHBvcnRzIG9ubHkgVW5jb21wcmVzc2VkICgweDA0KSBwb2ludFwiKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMudmFsdWUuc2xpY2UoMSkpO1xuICAgICAgICBjb25zdCBzaXplID0gYnl0ZXMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgICAgIHg6IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKGJ5dGVzLmJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHNpemUpKSxcbiAgICAgICAgICAgIHk6IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKGJ5dGVzLmJ1ZmZlci5zbGljZShvZmZzZXQgKyBzaXplLCBvZmZzZXQgKyBzaXplICsgc2l6ZSkpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIShcInhcIiBpbiBqc29uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieDogTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShcInlcIiBpbiBqc29uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieTogTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybChqc29uLngpO1xuICAgICAgICBjb25zdCB5ID0gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybChqc29uLnkpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHB2dHN1dGlscy5jb21iaW5lKG5ldyBVaW50OEFycmF5KFsweDA0XSkuYnVmZmVyLCB4LCB5KTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBVaW50OEFycmF5KHZhbHVlKS5idWZmZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5PY3RldFN0cmluZyB9KVxuXSwgRWNQdWJsaWNLZXkucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5FY1B1YmxpY0tleSA9IHRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuVHlwZSh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuVHlwZVR5cGVzLkNob2ljZSB9KVxuXSwgRWNQdWJsaWNLZXkpO1xuXG5jbGFzcyBFY1ByaXZhdGVLZXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAxO1xuICAgICAgICB0aGlzLnByaXZhdGVLZXkgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCEoXCJkXCIgaW4ganNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImQ6IE1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcml2YXRlS2V5ID0gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybChqc29uLmQpO1xuICAgICAgICBpZiAoXCJ4XCIgaW4ganNvbikge1xuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IEVjUHVibGljS2V5KCk7XG4gICAgICAgICAgICBwdWJsaWNLZXkuZnJvbUpTT04oanNvbik7XG4gICAgICAgICAgICBjb25zdCBhc24gPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIudG9BU04ocHVibGljS2V5KTtcbiAgICAgICAgICAgIGlmIChcInZhbHVlSGV4XCIgaW4gYXNuLnZhbHVlQmxvY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY0tleSA9IGFzbi52YWx1ZUJsb2NrLnZhbHVlSGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGp3ayA9IHt9O1xuICAgICAgICBqd2suZCA9IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKHRoaXMucHJpdmF0ZUtleSk7XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihqd2ssIG5ldyBFY1B1YmxpY0tleSh0aGlzLnB1YmxpY0tleSkudG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqd2s7XG4gICAgfVxufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBhc24xU2NoZW1hLkFzbkludGVnZXJDb252ZXJ0ZXIgfSlcbl0sIEVjUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwidmVyc2lvblwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuT2N0ZXRTdHJpbmcgfSlcbl0sIEVjUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwicHJpdmF0ZUtleVwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgY29udGV4dDogMCwgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuQW55LCBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRWNQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJwYXJhbWV0ZXJzXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyBjb250ZXh0OiAxLCB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5CaXRTdHJpbmcsIG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBFY1ByaXZhdGVLZXkucHJvdG90eXBlLCBcInB1YmxpY0tleVwiLCB2b2lkIDApO1xuXG5jb25zdCBBc25JbnRlZ2VyV2l0aG91dFBhZGRpbmdDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUudmFsdWVCbG9jay52YWx1ZUhleCk7XG4gICAgICAgIHJldHVybiAoYnl0ZXNbMF0gPT09IDApXG4gICAgICAgICAgICA/IGJ5dGVzLmJ1ZmZlci5zbGljZSgxKVxuICAgICAgICAgICAgOiBieXRlcy5idWZmZXI7XG4gICAgfSxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoYnl0ZXNbMF0gPiAxMjcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICBuZXdWYWx1ZS5zZXQoYnl0ZXMsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc24xX19uYW1lc3BhY2UuSW50ZWdlcih7IHZhbHVlSGV4OiBuZXdWYWx1ZS5idWZmZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBhc24xX19uYW1lc3BhY2UuSW50ZWdlcih7IHZhbHVlSGV4OiB2YWx1ZSB9KTtcbiAgICB9LFxufTtcblxudmFyIGluZGV4JDIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQXNuSW50ZWdlcldpdGhvdXRQYWRkaW5nQ29udmVydGVyOiBBc25JbnRlZ2VyV2l0aG91dFBhZGRpbmdDb252ZXJ0ZXJcbn0pO1xuXG5jbGFzcyBFY1V0aWxzIHtcbiAgICBzdGF0aWMgZGVjb2RlUG9pbnQoZGF0YSwgcG9pbnRTaXplKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgaWYgKCh2aWV3Lmxlbmd0aCA9PT0gMCkgfHwgKHZpZXdbMF0gIT09IDQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHVuY29tcHJlc3NlZCBwb2ludCBmb3JtYXQgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG4gPSAodmlldy5sZW5ndGggLSAxKSAvIDI7XG4gICAgICAgIGlmIChuICE9PSAoTWF0aC5jZWlsKHBvaW50U2l6ZSAvIDgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9pbnQgZG9lcyBub3QgbWF0Y2ggZmllbGQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4YiA9IHZpZXcuc2xpY2UoMSwgbiArIDEpO1xuICAgICAgICBjb25zdCB5YiA9IHZpZXcuc2xpY2UobiArIDEsIG4gKyAxICsgbik7XG4gICAgICAgIHJldHVybiB7IHg6IHhiLCB5OiB5YiB9O1xuICAgIH1cbiAgICBzdGF0aWMgZW5jb2RlUG9pbnQocG9pbnQsIHBvaW50U2l6ZSkge1xuICAgICAgICBjb25zdCBzaXplID0gTWF0aC5jZWlsKHBvaW50U2l6ZSAvIDgpO1xuICAgICAgICBpZiAocG9pbnQueC5ieXRlTGVuZ3RoICE9PSBzaXplIHx8IHBvaW50LnkuYnl0ZUxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWCxZIGNvb3JkaW5hdGVzIGRvbid0IG1hdGNoIHBvaW50IHNpemUgY3JpdGVyaWFcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeCA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHBvaW50LngpO1xuICAgICAgICBjb25zdCB5ID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkocG9pbnQueSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHNpemUgKiAyICsgMSk7XG4gICAgICAgIHJlc1swXSA9IDQ7XG4gICAgICAgIHJlcy5zZXQoeCwgMSk7XG4gICAgICAgIHJlcy5zZXQoeSwgc2l6ZSArIDEpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0U2l6ZShwb2ludFNpemUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChwb2ludFNpemUgLyA4KTtcbiAgICB9XG4gICAgc3RhdGljIGVuY29kZVNpZ25hdHVyZShzaWduYXR1cmUsIHBvaW50U2l6ZSkge1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKHBvaW50U2l6ZSk7XG4gICAgICAgIGNvbnN0IHIgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShzaWduYXR1cmUucik7XG4gICAgICAgIGNvbnN0IHMgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShzaWduYXR1cmUucyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHNpemUgKiAyKTtcbiAgICAgICAgcmVzLnNldCh0aGlzLnBhZFN0YXJ0KHIsIHNpemUpKTtcbiAgICAgICAgcmVzLnNldCh0aGlzLnBhZFN0YXJ0KHMsIHNpemUpLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIGRlY29kZVNpZ25hdHVyZShkYXRhLCBwb2ludFNpemUpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZShwb2ludFNpemUpO1xuICAgICAgICBjb25zdCB2aWV3ID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgIGlmICh2aWV3Lmxlbmd0aCAhPT0gKHNpemUgKiAyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IHNpemUgb2YgdGhlIHNpZ25hdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gdmlldy5zbGljZSgwLCBzaXplKTtcbiAgICAgICAgY29uc3QgcyA9IHZpZXcuc2xpY2Uoc2l6ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiB0aGlzLnRyaW1TdGFydChyKSxcbiAgICAgICAgICAgIHM6IHRoaXMudHJpbVN0YXJ0KHMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgdHJpbVN0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoKGkgPCBkYXRhLmxlbmd0aCAtIDEpICYmIChkYXRhW2ldID09PSAwKSkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5zbGljZShpLCBkYXRhLmxlbmd0aCk7XG4gICAgfVxuICAgIHN0YXRpYyBwYWRTdGFydChkYXRhLCBzaXplKSB7XG4gICAgICAgIGlmIChzaXplID09PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgIHJlcy5zZXQoZGF0YSwgc2l6ZSAtIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbmNsYXNzIEVjRHNhU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLnMgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tV2ViQ3J5cHRvU2lnbmF0dXJlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IHZhbHVlLmJ5dGVMZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBwb2ludCA9IEVjVXRpbHMuZGVjb2RlU2lnbmF0dXJlKHZhbHVlLCBwb2ludFNpemUgKiA4KTtcbiAgICAgICAgY29uc3QgZWNTaWduYXR1cmUgPSBuZXcgRWNEc2FTaWduYXR1cmUoKTtcbiAgICAgICAgZWNTaWduYXR1cmUuciA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihwb2ludC5yKTtcbiAgICAgICAgZWNTaWduYXR1cmUucyA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihwb2ludC5zKTtcbiAgICAgICAgcmV0dXJuIGVjU2lnbmF0dXJlO1xuICAgIH1cbiAgICB0b1dlYkNyeXB0b1NpZ25hdHVyZShwb2ludFNpemUpIHtcbiAgICAgICAgcG9pbnRTaXplICE9PSBudWxsICYmIHBvaW50U2l6ZSAhPT0gdm9pZCAwID8gcG9pbnRTaXplIDogKHBvaW50U2l6ZSA9IE1hdGgubWF4KHRoaXMuci5ieXRlTGVuZ3RoLCB0aGlzLnMuYnl0ZUxlbmd0aCkgKiA4KTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gRWNVdGlscy5lbmNvZGVTaWduYXR1cmUodGhpcywgcG9pbnRTaXplKTtcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZS5idWZmZXI7XG4gICAgfVxufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyV2l0aG91dFBhZGRpbmdDb252ZXJ0ZXIgfSlcbl0sIEVjRHNhU2lnbmF0dXJlLnByb3RvdHlwZSwgXCJyXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJXaXRob3V0UGFkZGluZ0NvbnZlcnRlciB9KVxuXSwgRWNEc2FTaWduYXR1cmUucHJvdG90eXBlLCBcInNcIiwgdm9pZCAwKTtcblxuY2xhc3MgT25lQXN5bW1ldHJpY0tleSBleHRlbmRzIFByaXZhdGVLZXlJbmZvIHtcbn1cbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IGNvbnRleHQ6IDEsIGltcGxpY2l0OiB0cnVlLCB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5CaXRTdHJpbmcsIG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBPbmVBc3ltbWV0cmljS2V5LnByb3RvdHlwZSwgXCJwdWJsaWNLZXlcIiwgdm9pZCAwKTtcblxubGV0IEVkUHJpdmF0ZUtleSA9IGNsYXNzIEVkUHJpdmF0ZUtleSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uLmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImQ6IE1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoanNvbi5kKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgandrID0ge1xuICAgICAgICAgICAgZDogcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwodGhpcy52YWx1ZSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBqd2s7XG4gICAgfVxufTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLk9jdGV0U3RyaW5nIH0pXG5dLCBFZFByaXZhdGVLZXkucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5FZFByaXZhdGVLZXkgPSB0c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblR5cGUoeyB0eXBlOiBhc24xU2NoZW1hLkFzblR5cGVUeXBlcy5DaG9pY2UgfSlcbl0sIEVkUHJpdmF0ZUtleSk7XG5cbmxldCBFZFB1YmxpY0tleSA9IGNsYXNzIEVkUHVibGljS2V5IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgICAgICB4OiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybCh0aGlzLnZhbHVlKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCEoXCJ4XCIgaW4ganNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIng6IE1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoanNvbi54KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkJpdFN0cmluZyB9KVxuXSwgRWRQdWJsaWNLZXkucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5FZFB1YmxpY0tleSA9IHRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuVHlwZSh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuVHlwZVR5cGVzLkNob2ljZSB9KVxuXSwgRWRQdWJsaWNLZXkpO1xuXG5sZXQgQ3VydmVQcml2YXRlS2V5ID0gY2xhc3MgQ3VydmVQcml2YXRlS2V5IHtcbn07XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5PY3RldFN0cmluZyB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgdHlwZToganNvblNjaGVtYS5Kc29uUHJvcFR5cGVzLlN0cmluZywgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIEN1cnZlUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwiZFwiLCB2b2lkIDApO1xuQ3VydmVQcml2YXRlS2V5ID0gdHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25UeXBlKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25UeXBlVHlwZXMuQ2hvaWNlIH0pXG5dLCBDdXJ2ZVByaXZhdGVLZXkpO1xuXG5jb25zdCBpZFNlY3AyNTZyMSA9IFwiMS4yLjg0MC4xMDA0NS4zLjEuN1wiO1xuY29uc3QgaWRFbGxpcHRpY0N1cnZlID0gXCIxLjMuMTMyLjBcIjtcbmNvbnN0IGlkU2VjcDM4NHIxID0gYCR7aWRFbGxpcHRpY0N1cnZlfS4zNGA7XG5jb25zdCBpZFNlY3A1MjFyMSA9IGAke2lkRWxsaXB0aWNDdXJ2ZX0uMzVgO1xuY29uc3QgaWRTZWNwMjU2azEgPSBgJHtpZEVsbGlwdGljQ3VydmV9LjEwYDtcbmNvbnN0IGlkVmVyc2lvbk9uZSA9IFwiMS4zLjM2LjMuMy4yLjguMS4xXCI7XG5jb25zdCBpZEJyYWlucG9vbFAxNjByMSA9IGAke2lkVmVyc2lvbk9uZX0uMWA7XG5jb25zdCBpZEJyYWlucG9vbFAxNjB0MSA9IGAke2lkVmVyc2lvbk9uZX0uMmA7XG5jb25zdCBpZEJyYWlucG9vbFAxOTJyMSA9IGAke2lkVmVyc2lvbk9uZX0uM2A7XG5jb25zdCBpZEJyYWlucG9vbFAxOTJ0MSA9IGAke2lkVmVyc2lvbk9uZX0uNGA7XG5jb25zdCBpZEJyYWlucG9vbFAyMjRyMSA9IGAke2lkVmVyc2lvbk9uZX0uNWA7XG5jb25zdCBpZEJyYWlucG9vbFAyMjR0MSA9IGAke2lkVmVyc2lvbk9uZX0uNmA7XG5jb25zdCBpZEJyYWlucG9vbFAyNTZyMSA9IGAke2lkVmVyc2lvbk9uZX0uN2A7XG5jb25zdCBpZEJyYWlucG9vbFAyNTZ0MSA9IGAke2lkVmVyc2lvbk9uZX0uOGA7XG5jb25zdCBpZEJyYWlucG9vbFAzMjByMSA9IGAke2lkVmVyc2lvbk9uZX0uOWA7XG5jb25zdCBpZEJyYWlucG9vbFAzMjB0MSA9IGAke2lkVmVyc2lvbk9uZX0uMTBgO1xuY29uc3QgaWRCcmFpbnBvb2xQMzg0cjEgPSBgJHtpZFZlcnNpb25PbmV9LjExYDtcbmNvbnN0IGlkQnJhaW5wb29sUDM4NHQxID0gYCR7aWRWZXJzaW9uT25lfS4xMmA7XG5jb25zdCBpZEJyYWlucG9vbFA1MTJyMSA9IGAke2lkVmVyc2lvbk9uZX0uMTNgO1xuY29uc3QgaWRCcmFpbnBvb2xQNTEydDEgPSBgJHtpZFZlcnNpb25PbmV9LjE0YDtcbmNvbnN0IGlkWDI1NTE5ID0gXCIxLjMuMTAxLjExMFwiO1xuY29uc3QgaWRYNDQ4ID0gXCIxLjMuMTAxLjExMVwiO1xuY29uc3QgaWRFZDI1NTE5ID0gXCIxLjMuMTAxLjExMlwiO1xuY29uc3QgaWRFZDQ0OCA9IFwiMS4zLjEwMS4xMTNcIjtcblxudmFyIGluZGV4JDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQWxnb3JpdGhtSWRlbnRpZmllcjogQWxnb3JpdGhtSWRlbnRpZmllcixcbiAgZ2V0IEN1cnZlUHJpdmF0ZUtleSAoKSB7IHJldHVybiBDdXJ2ZVByaXZhdGVLZXk7IH0sXG4gIEVjRHNhU2lnbmF0dXJlOiBFY0RzYVNpZ25hdHVyZSxcbiAgRWNQcml2YXRlS2V5OiBFY1ByaXZhdGVLZXksXG4gIGdldCBFY1B1YmxpY0tleSAoKSB7IHJldHVybiBFY1B1YmxpY0tleTsgfSxcbiAgZ2V0IEVkUHJpdmF0ZUtleSAoKSB7IHJldHVybiBFZFByaXZhdGVLZXk7IH0sXG4gIGdldCBFZFB1YmxpY0tleSAoKSB7IHJldHVybiBFZFB1YmxpY0tleTsgfSxcbiAgZ2V0IE9iamVjdElkZW50aWZpZXIgKCkgeyByZXR1cm4gT2JqZWN0SWRlbnRpZmllcjsgfSxcbiAgT25lQXN5bW1ldHJpY0tleTogT25lQXN5bW1ldHJpY0tleSxcbiAgUHJpdmF0ZUtleUluZm86IFByaXZhdGVLZXlJbmZvLFxuICBQdWJsaWNLZXlJbmZvOiBQdWJsaWNLZXlJbmZvLFxuICBSc2FQcml2YXRlS2V5OiBSc2FQcml2YXRlS2V5LFxuICBSc2FQdWJsaWNLZXk6IFJzYVB1YmxpY0tleSxcbiAgY29udmVydGVyczogaW5kZXgkMixcbiAgaWRCcmFpbnBvb2xQMTYwcjE6IGlkQnJhaW5wb29sUDE2MHIxLFxuICBpZEJyYWlucG9vbFAxNjB0MTogaWRCcmFpbnBvb2xQMTYwdDEsXG4gIGlkQnJhaW5wb29sUDE5MnIxOiBpZEJyYWlucG9vbFAxOTJyMSxcbiAgaWRCcmFpbnBvb2xQMTkydDE6IGlkQnJhaW5wb29sUDE5MnQxLFxuICBpZEJyYWlucG9vbFAyMjRyMTogaWRCcmFpbnBvb2xQMjI0cjEsXG4gIGlkQnJhaW5wb29sUDIyNHQxOiBpZEJyYWlucG9vbFAyMjR0MSxcbiAgaWRCcmFpbnBvb2xQMjU2cjE6IGlkQnJhaW5wb29sUDI1NnIxLFxuICBpZEJyYWlucG9vbFAyNTZ0MTogaWRCcmFpbnBvb2xQMjU2dDEsXG4gIGlkQnJhaW5wb29sUDMyMHIxOiBpZEJyYWlucG9vbFAzMjByMSxcbiAgaWRCcmFpbnBvb2xQMzIwdDE6IGlkQnJhaW5wb29sUDMyMHQxLFxuICBpZEJyYWlucG9vbFAzODRyMTogaWRCcmFpbnBvb2xQMzg0cjEsXG4gIGlkQnJhaW5wb29sUDM4NHQxOiBpZEJyYWlucG9vbFAzODR0MSxcbiAgaWRCcmFpbnBvb2xQNTEycjE6IGlkQnJhaW5wb29sUDUxMnIxLFxuICBpZEJyYWlucG9vbFA1MTJ0MTogaWRCcmFpbnBvb2xQNTEydDEsXG4gIGlkRWQyNTUxOTogaWRFZDI1NTE5LFxuICBpZEVkNDQ4OiBpZEVkNDQ4LFxuICBpZEVsbGlwdGljQ3VydmU6IGlkRWxsaXB0aWNDdXJ2ZSxcbiAgaWRTZWNwMjU2azE6IGlkU2VjcDI1NmsxLFxuICBpZFNlY3AyNTZyMTogaWRTZWNwMjU2cjEsXG4gIGlkU2VjcDM4NHIxOiBpZFNlY3AzODRyMSxcbiAgaWRTZWNwNTIxcjE6IGlkU2VjcDUyMXIxLFxuICBpZFZlcnNpb25PbmU6IGlkVmVyc2lvbk9uZSxcbiAgaWRYMjU1MTk6IGlkWDI1NTE5LFxuICBpZFg0NDg6IGlkWDQ0OFxufSk7XG5cbmNsYXNzIEVjQ3VydmVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIHN0YXRpYyByZWdpc3RlcihpdGVtKSB7XG4gICAgICAgIGNvbnN0IG9pZCA9IG5ldyBPYmplY3RJZGVudGlmaWVyKCk7XG4gICAgICAgIG9pZC52YWx1ZSA9IGl0ZW0uaWQ7XG4gICAgICAgIGNvbnN0IHJhdyA9IGFzbjFTY2hlbWEuQXNuQ29udmVydC5zZXJpYWxpemUob2lkKTtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHtcbiAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICByYXcsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWVzLnB1c2goaXRlbS5uYW1lKTtcbiAgICB9XG4gICAgc3RhdGljIGZpbmQobmFtZU9ySWQpIHtcbiAgICAgICAgbmFtZU9ySWQgPSBuYW1lT3JJZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZS50b1VwcGVyQ2FzZSgpID09PSBuYW1lT3JJZCB8fCBpdGVtLmlkLnRvVXBwZXJDYXNlKCkgPT09IG5hbWVPcklkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQobmFtZU9ySWQpIHtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5maW5kKG5hbWVPcklkKTtcbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgRUMgbmFtZWQgY3VydmUgJyR7bmFtZU9ySWR9J2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuRWNDdXJ2ZXMuaXRlbXMgPSBbXTtcbkVjQ3VydmVzLm5hbWVzID0gW107XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiUC0yNTZcIiwgaWQ6IGlkU2VjcDI1NnIxLCBzaXplOiAyNTYgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiUC0zODRcIiwgaWQ6IGlkU2VjcDM4NHIxLCBzaXplOiAzODQgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiUC01MjFcIiwgaWQ6IGlkU2VjcDUyMXIxLCBzaXplOiA1MjEgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiSy0yNTZcIiwgaWQ6IGlkU2VjcDI1NmsxLCBzaXplOiAyNTYgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDE2MHIxXCIsIGlkOiBpZEJyYWlucG9vbFAxNjByMSwgc2l6ZTogMTYwIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAxNjB0MVwiLCBpZDogaWRCcmFpbnBvb2xQMTYwdDEsIHNpemU6IDE2MCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMTkycjFcIiwgaWQ6IGlkQnJhaW5wb29sUDE5MnIxLCBzaXplOiAxOTIgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDE5MnQxXCIsIGlkOiBpZEJyYWlucG9vbFAxOTJ0MSwgc2l6ZTogMTkyIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAyMjRyMVwiLCBpZDogaWRCcmFpbnBvb2xQMjI0cjEsIHNpemU6IDIyNCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMjI0dDFcIiwgaWQ6IGlkQnJhaW5wb29sUDIyNHQxLCBzaXplOiAyMjQgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDI1NnIxXCIsIGlkOiBpZEJyYWlucG9vbFAyNTZyMSwgc2l6ZTogMjU2IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAyNTZ0MVwiLCBpZDogaWRCcmFpbnBvb2xQMjU2dDEsIHNpemU6IDI1NiB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMzIwcjFcIiwgaWQ6IGlkQnJhaW5wb29sUDMyMHIxLCBzaXplOiAzMjAgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDMyMHQxXCIsIGlkOiBpZEJyYWlucG9vbFAzMjB0MSwgc2l6ZTogMzIwIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAzODRyMVwiLCBpZDogaWRCcmFpbnBvb2xQMzg0cjEsIHNpemU6IDM4NCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMzg0dDFcIiwgaWQ6IGlkQnJhaW5wb29sUDM4NHQxLCBzaXplOiAzODQgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDUxMnIxXCIsIGlkOiBpZEJyYWlucG9vbFA1MTJyMSwgc2l6ZTogNTEyIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFA1MTJ0MVwiLCBpZDogaWRCcmFpbnBvb2xQNTEydDEsIHNpemU6IDUxMiB9KTtcblxuY2xhc3MgSG1hY1Byb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkhNQUNcIjtcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCJdO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl07XG4gICAgfVxuICAgIGdldERlZmF1bHRMZW5ndGgoYWxnTmFtZSkge1xuICAgICAgICBzd2l0Y2ggKGFsZ05hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcIlNIQS0xXCI6XG4gICAgICAgICAgICBjYXNlIFwiU0hBLTI1NlwiOlxuICAgICAgICAgICAgY2FzZSBcIlNIQS0zODRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtNTEyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDUxMjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFsZ29yaXRobSBuYW1lICcke2FsZ05hbWV9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJoYXNoXCIpO1xuICAgICAgICB0aGlzLmNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0uaGFzaCwgdGhpcy5oYXNoQWxnb3JpdGhtcyk7XG4gICAgICAgIGlmIChcImxlbmd0aFwiIGluIGFsZ29yaXRobSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0ubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxlbmd0aDogSXMgbm90IGEgTnVtYmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsZ29yaXRobS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJsZW5ndGg6IE51bWJlciBpcyBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tJbXBvcnRQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJoYXNoXCIpO1xuICAgICAgICB0aGlzLmNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0uaGFzaCwgdGhpcy5oYXNoQWxnb3JpdGhtcyk7XG4gICAgfVxufVxuXG5jbGFzcyBQYmtkZjJQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJQQktERjJcIjtcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCJdO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcImRlcml2ZUJpdHNcIiwgXCJkZXJpdmVLZXlcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaGFzaFwiKTtcbiAgICAgICAgdGhpcy5jaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gsIHRoaXMuaGFzaEFsZ29yaXRobXMpO1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwic2FsdFwiKTtcbiAgICAgICAgaWYgKCEoYWxnb3JpdGhtLnNhbHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYWxnb3JpdGhtLnNhbHQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNhbHQ6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIml0ZXJhdGlvbnNcIik7XG4gICAgICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLml0ZXJhdGlvbnMgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRpb25zOiBJcyBub3QgYSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5pdGVyYXRpb25zIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIml0ZXJhdGlvbnM6IElzIGxlc3MgdGhhbiAxXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyLmNoZWNrSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgaWYgKGV4dHJhY3RhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJleHRyYWN0YWJsZTogTXVzdCBiZSAnZmFsc2UnXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBIa2RmUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSEtERlwiO1xuICAgICAgICB0aGlzLmhhc2hBbGdvcml0aG1zID0gW1wiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIl07XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wiZGVyaXZlS2V5XCIsIFwiZGVyaXZlQml0c1wiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJoYXNoXCIpO1xuICAgICAgICB0aGlzLmNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0uaGFzaCwgdGhpcy5oYXNoQWxnb3JpdGhtcyk7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJzYWx0XCIpO1xuICAgICAgICBpZiAoIXB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIuaXNCdWZmZXJTb3VyY2UoYWxnb3JpdGhtLnNhbHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic2FsdDogSXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaW5mb1wiKTtcbiAgICAgICAgaWYgKCFwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLmlzQnVmZmVyU291cmNlKGFsZ29yaXRobS5pbmZvKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNhbHQ6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tJbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIuY2hlY2tJbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICBpZiAoZXh0cmFjdGFibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcImV4dHJhY3RhYmxlOiBNdXN0IGJlICdmYWxzZSdcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFNoYWtlUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XG4gICAgICAgIHRoaXMuZGVmYXVsdExlbmd0aCA9IDA7XG4gICAgfVxuICAgIGRpZ2VzdCguLi5hcmdzKSB7XG4gICAgICAgIGFyZ3NbMF0gPSB7IGxlbmd0aDogdGhpcy5kZWZhdWx0TGVuZ3RoLCAuLi5hcmdzWzBdIH07XG4gICAgICAgIHJldHVybiBzdXBlci5kaWdlc3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xuICAgICAgICBzdXBlci5jaGVja0RpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBhbGdvcml0aG0ubGVuZ3RoIHx8IDA7XG4gICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBJcyBub3QgYSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IElzIG5lZ2F0aXZlXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTaGFrZTEyOFByb3ZpZGVyIGV4dGVuZHMgU2hha2VQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwic2hha2UxMjhcIjtcbiAgICAgICAgdGhpcy5kZWZhdWx0TGVuZ3RoID0gMTY7XG4gICAgfVxufVxuXG5jbGFzcyBTaGFrZTI1NlByb3ZpZGVyIGV4dGVuZHMgU2hha2VQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwic2hha2UyNTZcIjtcbiAgICAgICAgdGhpcy5kZWZhdWx0TGVuZ3RoID0gMzI7XG4gICAgfVxufVxuXG5jbGFzcyBDcnlwdG8ge1xuICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ3J5cHRvXCI7XG4gICAgfVxuICAgIHJhbmRvbVVVSUQoKSB7XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxNikpO1xuICAgICAgICBiWzZdID0gKGJbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgICAgIGJbOF0gPSAoYls4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICAgICAgY29uc3QgdXVpZCA9IHB2dHN1dGlscy5Db252ZXJ0LlRvSGV4KGIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBgJHt1dWlkLnN1YnN0cmluZygwLCA4KX0tJHt1dWlkLnN1YnN0cmluZyg4LCAxMil9LSR7dXVpZC5zdWJzdHJpbmcoMTIsIDE2KX0tJHt1dWlkLnN1YnN0cmluZygxNiwgMjApfS0ke3V1aWQuc3Vic3RyaW5nKDIwKX1gO1xuICAgIH1cbn1cblxuY2xhc3MgUHJvdmlkZXJTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IHt9O1xuICAgIH1cbiAgICBnZXQoYWxnb3JpdGhtTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1thbGdvcml0aG1OYW1lLnRvTG93ZXJDYXNlKCldIHx8IG51bGw7XG4gICAgfVxuICAgIHNldChwcm92aWRlcikge1xuICAgICAgICB0aGlzLml0ZW1zW3Byb3ZpZGVyLm5hbWUudG9Mb3dlckNhc2UoKV0gPSBwcm92aWRlcjtcbiAgICB9XG4gICAgcmVtb3ZlQXQoYWxnb3JpdGhtTmFtZSkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0KGFsZ29yaXRobU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaXRlbXNbYWxnb3JpdGhtTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgIH1cbiAgICBoYXMobmFtZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldChuYW1lKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaXRlbXMpLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGFsZ29yaXRobXMoKSB7XG4gICAgICAgIGNvbnN0IGFsZ29yaXRobXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLml0ZW1zW2tleV07XG4gICAgICAgICAgICBhbGdvcml0aG1zLnB1c2gocHJvdmlkZXIubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsZ29yaXRobXMuc29ydCgpO1xuICAgIH1cbn1cblxuY2xhc3MgU3VidGxlQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBuZXcgUHJvdmlkZXJTdG9yYWdlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0hhc2hlZEFsZ29yaXRobShkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICAgICAgICAmJiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgJiYgXCJuYW1lXCIgaW4gZGF0YVxuICAgICAgICAgICAgJiYgXCJoYXNoXCIgaW4gZGF0YVxuICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBcIlN1YnRsZUNyeXB0b1wiO1xuICAgIH1cbiAgICBhc3luYyBkaWdlc3QoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgMiwgXCJkaWdlc3RcIik7XG4gICAgICAgIGNvbnN0IFthbGdvcml0aG0sIGRhdGEsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcmVwYXJlZERhdGEgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuZGlnZXN0KHByZXBhcmVkQWxnb3JpdGhtLCBwcmVwYXJlZERhdGEsIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlS2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDMsIFwiZ2VuZXJhdGVLZXlcIik7XG4gICAgICAgIGNvbnN0IFthbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmdlbmVyYXRlS2V5KHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgc2lnbiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCAzLCBcInNpZ25cIik7XG4gICAgICAgIGNvbnN0IFthbGdvcml0aG0sIGtleSwgZGF0YSwgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLnNpZ24oeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBrZXksIHByZXBhcmVkRGF0YSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDQsIFwidmVyaWZ5XCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSwgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICBjb25zdCBwcmVwYXJlZFNpZ25hdHVyZSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihzaWduYXR1cmUpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLnZlcmlmeSh7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIGtleSwgcHJlcGFyZWRTaWduYXR1cmUsIHByZXBhcmVkRGF0YSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZW5jcnlwdCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCAzLCBcImVuY3J5cHRcIik7XG4gICAgICAgIGNvbnN0IFthbGdvcml0aG0sIGtleSwgZGF0YSwgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmVuY3J5cHQoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBrZXksIHByZXBhcmVkRGF0YSwgeyBrZXlVc2FnZTogdHJ1ZSB9LCAuLi5wYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBkZWNyeXB0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDMsIFwiZGVjcnlwdFwiKTtcbiAgICAgICAgY29uc3QgW2FsZ29yaXRobSwga2V5LCBkYXRhLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXkpO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcmVwYXJlZERhdGEgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuZGVjcnlwdCh7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIGtleSwgcHJlcGFyZWREYXRhLCB7IGtleVVzYWdlOiB0cnVlIH0sIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGRlcml2ZUJpdHMoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgMywgXCJkZXJpdmVCaXRzXCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGJhc2VLZXkpO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmRlcml2ZUJpdHMoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBiYXNlS2V5LCBsZW5ndGgsIHsga2V5VXNhZ2U6IHRydWUgfSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZGVyaXZlS2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDUsIFwiZGVyaXZlS2V5XCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBiYXNlS2V5LCBkZXJpdmVkS2V5VHlwZSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkRGVyaXZlZEtleVR5cGUgPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oZGVyaXZlZEtleVR5cGUpO1xuICAgICAgICBjb25zdCBpbXBvcnRQcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWREZXJpdmVkS2V5VHlwZS5uYW1lKTtcbiAgICAgICAgaW1wb3J0UHJvdmlkZXIuY2hlY2tEZXJpdmVkS2V5UGFyYW1zKHByZXBhcmVkRGVyaXZlZEtleVR5cGUpO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIHByb3ZpZGVyLmNoZWNrQ3J5cHRvS2V5KGJhc2VLZXksIFwiZGVyaXZlS2V5XCIpO1xuICAgICAgICBjb25zdCBkZXJpdmVkQml0cyA9IGF3YWl0IHByb3ZpZGVyLmRlcml2ZUJpdHMoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBiYXNlS2V5LCBkZXJpdmVkS2V5VHlwZS5sZW5ndGggfHwgNTEyLCB7IGtleVVzYWdlOiBmYWxzZSB9LCAuLi5wYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRLZXkoXCJyYXdcIiwgZGVyaXZlZEJpdHMsIGRlcml2ZWRLZXlUeXBlLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5wYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBleHBvcnRLZXkoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgMiwgXCJleHBvcnRLZXlcIik7XG4gICAgICAgIGNvbnN0IFtmb3JtYXQsIGtleSwgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGtleS5hbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmV4cG9ydEtleShmb3JtYXQsIGtleSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgaW1wb3J0S2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDUsIFwiaW1wb3J0S2V5XCIpO1xuICAgICAgICBjb25zdCBbZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGlmIChbXCJwa2NzOFwiLCBcInNwa2lcIiwgXCJyYXdcIl0uaW5kZXhPZihmb3JtYXQpICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGtleURhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmltcG9ydEtleShmb3JtYXQsIHByZXBhcmVkRGF0YSwgeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFrZXlEYXRhLmt0eSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXlEYXRhOiBJcyBub3QgSlNPTlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvdmlkZXIuaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5wYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyB3cmFwS2V5KGZvcm1hdCwga2V5LCB3cmFwcGluZ0tleSwgd3JhcEFsZ29yaXRobSwgLi4uYXJncykge1xuICAgICAgICBsZXQga2V5RGF0YSA9IGF3YWl0IHRoaXMuZXhwb3J0S2V5KGZvcm1hdCwga2V5LCAuLi5hcmdzKTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqd2tcIikge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KGtleURhdGEpO1xuICAgICAgICAgICAga2V5RGF0YSA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21VdGY4U3RyaW5nKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKHdyYXBBbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcmVwYXJlZERhdGEgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoa2V5RGF0YSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmVuY3J5cHQoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCB3cmFwcGluZ0tleSwgcHJlcGFyZWREYXRhLCB7IGtleVVzYWdlOiBmYWxzZSB9LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgdW53cmFwS2V5KGZvcm1hdCwgd3JhcHBlZEtleSwgdW53cmFwcGluZ0tleSwgdW53cmFwQWxnb3JpdGhtLCB1bndyYXBwZWRLZXlBbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0odW53cmFwQWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHdyYXBwZWRLZXkpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGxldCBrZXlEYXRhID0gYXdhaXQgcHJvdmlkZXIuZGVjcnlwdCh7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIHVud3JhcHBpbmdLZXksIHByZXBhcmVkRGF0YSwgeyBrZXlVc2FnZTogZmFsc2UgfSwgLi4uYXJncyk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiandrXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAga2V5RGF0YSA9IEpTT04ucGFyc2UocHZ0c3V0aWxzLkNvbnZlcnQuVG9VdGY4U3RyaW5nKGtleURhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKFwid3JhcHBlZEtleTogSXMgbm90IGEgSlNPTlwiKTtcbiAgICAgICAgICAgICAgICBlcnJvci5pbnRlcm5hbCA9IGU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgdW53cmFwcGVkS2V5QWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCBzaXplLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICcke21ldGhvZE5hbWV9JyBvbiAnU3VidGxlQ3J5cHRvJzogJHtzaXplfSBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJncy5sZW5ndGh9IHByZXNlbnRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSkge1xuICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBhbGdvcml0aG0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChTdWJ0bGVDcnlwdG8uaXNIYXNoZWRBbGdvcml0aG0oYWxnb3JpdGhtKSkge1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB7IC4uLmFsZ29yaXRobSB9O1xuICAgICAgICAgICAgcHJlcGFyZWRBbGdvcml0aG0uaGFzaCA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0uaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gcHJlcGFyZWRBbGdvcml0aG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4uYWxnb3JpdGhtIH07XG4gICAgfVxuICAgIGdldFByb3ZpZGVyKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVycy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBbGdvcml0aG1FcnJvcihcIlVucmVjb2duaXplZCBuYW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICB9XG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbnN0YW5jZW9mIENyeXB0b0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEtleSBpcyBub3Qgb2YgdHlwZSAnQ3J5cHRvS2V5J2ApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgY29udmVydGVyczogaW5kZXgkM1xufSk7XG5cbmNvbnN0IFJFUVVJUkVEX0ZJRUxEUyA9IFtcImNydlwiLCBcImVcIiwgXCJrXCIsIFwia3R5XCIsIFwiblwiLCBcInhcIiwgXCJ5XCJdO1xuY2xhc3MgSndrVXRpbHMge1xuICAgIHN0YXRpYyBhc3luYyB0aHVtYnByaW50KGhhc2gsIGp3aywgY3J5cHRvKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmZvcm1hdChqd2ssIHRydWUpO1xuICAgICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5kaWdlc3QoaGFzaCwgcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJpbmFyeShKU09OLnN0cmluZ2lmeShkYXRhKSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZm9ybWF0KGp3aywgcmVtb3ZlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlcyA9IE9iamVjdC5lbnRyaWVzKGp3ayk7XG4gICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5maWx0ZXIobyA9PiBSRVFVSVJFRF9GSUVMRFMuaW5jbHVkZXMob1swXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IHJlcy5zb3J0KChba2V5QV0sIFtrZXlCXSkgPT4ga2V5QSA+IGtleUIgPyAxIDoga2V5QSA8IGtleUIgPyAtMSA6IDApO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHJlcyk7XG4gICAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0J1ZmZlclNvdXJjZUNvbnZlcnRlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyOyB9XG59KTtcbmV4cG9ydHMuQWVzQ2JjUHJvdmlkZXIgPSBBZXNDYmNQcm92aWRlcjtcbmV4cG9ydHMuQWVzQ21hY1Byb3ZpZGVyID0gQWVzQ21hY1Byb3ZpZGVyO1xuZXhwb3J0cy5BZXNDdHJQcm92aWRlciA9IEFlc0N0clByb3ZpZGVyO1xuZXhwb3J0cy5BZXNFY2JQcm92aWRlciA9IEFlc0VjYlByb3ZpZGVyO1xuZXhwb3J0cy5BZXNHY21Qcm92aWRlciA9IEFlc0djbVByb3ZpZGVyO1xuZXhwb3J0cy5BZXNLd1Byb3ZpZGVyID0gQWVzS3dQcm92aWRlcjtcbmV4cG9ydHMuQWVzUHJvdmlkZXIgPSBBZXNQcm92aWRlcjtcbmV4cG9ydHMuQWxnb3JpdGhtRXJyb3IgPSBBbGdvcml0aG1FcnJvcjtcbmV4cG9ydHMuQ3J5cHRvID0gQ3J5cHRvO1xuZXhwb3J0cy5DcnlwdG9FcnJvciA9IENyeXB0b0Vycm9yO1xuZXhwb3J0cy5DcnlwdG9LZXkgPSBDcnlwdG9LZXk7XG5leHBvcnRzLkRlc1Byb3ZpZGVyID0gRGVzUHJvdmlkZXI7XG5leHBvcnRzLkVjQ3VydmVzID0gRWNDdXJ2ZXM7XG5leHBvcnRzLkVjVXRpbHMgPSBFY1V0aWxzO1xuZXhwb3J0cy5FY2RoRXNQcm92aWRlciA9IEVjZGhFc1Byb3ZpZGVyO1xuZXhwb3J0cy5FY2RoUHJvdmlkZXIgPSBFY2RoUHJvdmlkZXI7XG5leHBvcnRzLkVjZHNhUHJvdmlkZXIgPSBFY2RzYVByb3ZpZGVyO1xuZXhwb3J0cy5FZERzYVByb3ZpZGVyID0gRWREc2FQcm92aWRlcjtcbmV4cG9ydHMuRWxsaXB0aWNQcm92aWRlciA9IEVsbGlwdGljUHJvdmlkZXI7XG5leHBvcnRzLkhrZGZQcm92aWRlciA9IEhrZGZQcm92aWRlcjtcbmV4cG9ydHMuSG1hY1Byb3ZpZGVyID0gSG1hY1Byb3ZpZGVyO1xuZXhwb3J0cy5Kd2tVdGlscyA9IEp3a1V0aWxzO1xuZXhwb3J0cy5PcGVyYXRpb25FcnJvciA9IE9wZXJhdGlvbkVycm9yO1xuZXhwb3J0cy5QYmtkZjJQcm92aWRlciA9IFBia2RmMlByb3ZpZGVyO1xuZXhwb3J0cy5QZW1Db252ZXJ0ZXIgPSBQZW1Db252ZXJ0ZXI7XG5leHBvcnRzLlByb3ZpZGVyQ3J5cHRvID0gUHJvdmlkZXJDcnlwdG87XG5leHBvcnRzLlByb3ZpZGVyU3RvcmFnZSA9IFByb3ZpZGVyU3RvcmFnZTtcbmV4cG9ydHMuUmVxdWlyZWRQcm9wZXJ0eUVycm9yID0gUmVxdWlyZWRQcm9wZXJ0eUVycm9yO1xuZXhwb3J0cy5Sc2FPYWVwUHJvdmlkZXIgPSBSc2FPYWVwUHJvdmlkZXI7XG5leHBvcnRzLlJzYVByb3ZpZGVyID0gUnNhUHJvdmlkZXI7XG5leHBvcnRzLlJzYVBzc1Byb3ZpZGVyID0gUnNhUHNzUHJvdmlkZXI7XG5leHBvcnRzLlJzYVNzYVByb3ZpZGVyID0gUnNhU3NhUHJvdmlkZXI7XG5leHBvcnRzLlNoYWtlMTI4UHJvdmlkZXIgPSBTaGFrZTEyOFByb3ZpZGVyO1xuZXhwb3J0cy5TaGFrZTI1NlByb3ZpZGVyID0gU2hha2UyNTZQcm92aWRlcjtcbmV4cG9ydHMuU2hha2VQcm92aWRlciA9IFNoYWtlUHJvdmlkZXI7XG5leHBvcnRzLlN1YnRsZUNyeXB0byA9IFN1YnRsZUNyeXB0bztcbmV4cG9ydHMuVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvciA9IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3I7XG5leHBvcnRzLmFzbjEgPSBpbmRleCQxO1xuZXhwb3J0cy5pc0pXSyA9IGlzSldLO1xuZXhwb3J0cy5qc29uID0gaW5kZXg7XG4iXSwibmFtZXMiOlsicHZ0c3V0aWxzIiwicmVxdWlyZSIsImFzbjFTY2hlbWEiLCJ0c2xpYiIsImpzb25TY2hlbWEiLCJhc24xIiwiX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0IiwiZSIsIm4iLCJPYmplY3QiLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZGVmYXVsdCIsImZyZWV6ZSIsImFzbjFfX25hbWVzcGFjZSIsIkNyeXB0b0Vycm9yIiwiRXJyb3IiLCJBbGdvcml0aG1FcnJvciIsIlVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1ldGhvZE5hbWUiLCJPcGVyYXRpb25FcnJvciIsIlJlcXVpcmVkUHJvcGVydHlFcnJvciIsInByb3BOYW1lIiwiUGVtQ29udmVydGVyIiwidG9BcnJheUJ1ZmZlciIsInBlbSIsImJhc2U2NCIsInJlcGxhY2UiLCJDb252ZXJ0IiwiRnJvbUJhc2U2NCIsInRvVWludDhBcnJheSIsImJ5dGVzIiwiVWludDhBcnJheSIsImZyb21CdWZmZXJTb3VyY2UiLCJidWZmZXIiLCJ0YWciLCJUb0Jhc2U2NCIsInNsaWNlZCIsIm9mZnNldCIsInJvd3MiLCJzbGljZSIsImxlbmd0aCIsInB1c2giLCJ1cHBlckNhc2VUYWciLCJ0b1VwcGVyQ2FzZSIsImpvaW4iLCJpc1BFTSIsImRhdGEiLCJ0ZXN0IiwiZ2V0VGFnTmFtZSIsInJlcyIsImV4ZWMiLCJoYXNUYWdOYW1lIiwidGFnTmFtZSIsInRvTG93ZXJDYXNlIiwiaXNDZXJ0aWZpY2F0ZSIsImlzQ2VydGlmaWNhdGVSZXF1ZXN0IiwiaXNDUkwiLCJpc1B1YmxpY0tleSIsImlzSldLIiwiUHJvdmlkZXJDcnlwdG8iLCJkaWdlc3QiLCJhcmdzIiwiY2hlY2tEaWdlc3QiLCJhcHBseSIsIm9uRGlnZXN0IiwiYWxnb3JpdGhtIiwiY2hlY2tBbGdvcml0aG1OYW1lIiwiZ2VuZXJhdGVLZXkiLCJjaGVja0dlbmVyYXRlS2V5Iiwib25HZW5lcmF0ZUtleSIsImV4dHJhY3RhYmxlIiwia2V5VXNhZ2VzIiwiY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyIsIlR5cGVFcnJvciIsImFsbG93ZWRVc2FnZXMiLCJBcnJheSIsImlzQXJyYXkiLCJ1c2FnZXMiLCJwcml2YXRlS2V5IiwiY29uY2F0IiwicHVibGljS2V5IiwiY2hlY2tLZXlVc2FnZXMiLCJzaWduIiwiY2hlY2tTaWduIiwib25TaWduIiwia2V5IiwiY2hlY2tBbGdvcml0aG1QYXJhbXMiLCJjaGVja0NyeXB0b0tleSIsInZlcmlmeSIsImNoZWNrVmVyaWZ5Iiwib25WZXJpZnkiLCJzaWduYXR1cmUiLCJlbmNyeXB0IiwiY2hlY2tFbmNyeXB0Iiwib25FbmNyeXB0Iiwib3B0aW9ucyIsImtleVVzYWdlIiwiZGVjcnlwdCIsImNoZWNrRGVjcnlwdCIsIm9uRGVjcnlwdCIsImRlcml2ZUJpdHMiLCJjaGVja0Rlcml2ZUJpdHMiLCJvbkRlcml2ZUJpdHMiLCJiYXNlS2V5IiwiZXhwb3J0S2V5IiwiY2hlY2tFeHBvcnRLZXkiLCJvbkV4cG9ydEtleSIsImZvcm1hdCIsImNoZWNrS2V5Rm9ybWF0IiwiaW1wb3J0S2V5IiwiY2hlY2tJbXBvcnRLZXkiLCJvbkltcG9ydEtleSIsImtleURhdGEiLCJjaGVja0tleURhdGEiLCJjaGVja0ltcG9ydFBhcmFtcyIsIm5hbWUiLCJjaGVja0Rlcml2ZWRLZXlQYXJhbXMiLCJhbGxvd2VkIiwidXNhZ2UiLCJpbmRleE9mIiwiY2hlY2tSZXF1aXJlZFByb3BlcnR5IiwiY2hlY2tIYXNoQWxnb3JpdGhtIiwiaGFzaEFsZ29yaXRobXMiLCJpdGVtIiwiQnVmZmVyU291cmNlQ29udmVydGVyIiwiaXNCdWZmZXJTb3VyY2UiLCJwcmVwYXJlRGF0YSIsIkFlc1Byb3ZpZGVyIiwiQWVzQ2JjUHJvdmlkZXIiLCJhcmd1bWVudHMiLCJpdiIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnl0ZUxlbmd0aCIsIkFlc0NtYWNQcm92aWRlciIsIkFlc0N0clByb3ZpZGVyIiwiY291bnRlciIsIkFlc0VjYlByb3ZpZGVyIiwiQWVzR2NtUHJvdmlkZXIiLCJ0YWdMZW5ndGgiLCJBZXNLd1Byb3ZpZGVyIiwiRGVzUHJvdmlkZXIiLCJpdlNpemUiLCJrZXlTaXplQml0cyIsIlJzYVByb3ZpZGVyIiwiaGFzaCIsInB1YmxpY0V4cG9uZW50IiwibW9kdWx1c0xlbmd0aCIsIlJzYVNzYVByb3ZpZGVyIiwiUnNhUHNzUHJvdmlkZXIiLCJzYWx0TGVuZ3RoIiwiUmFuZ2VFcnJvciIsIlJzYU9hZXBQcm92aWRlciIsImxhYmVsIiwiRWxsaXB0aWNQcm92aWRlciIsImNoZWNrTmFtZWRDdXJ2ZSIsIm5hbWVkQ3VydmUiLCJuYW1lZEN1cnZlcyIsIkVjZHNhUHJvdmlkZXIiLCJLRVlfVFlQRVMiLCJDcnlwdG9LZXkiLCJ0eXBlIiwiaXNLZXlUeXBlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJFY2RoUHJvdmlkZXIiLCJwdWJsaWMiLCJFY2RoRXNQcm92aWRlciIsIkVkRHNhUHJvdmlkZXIiLCJPYmplY3RJZGVudGlmaWVyIiwidmFsdWUiLCJfX2RlY29yYXRlIiwiQXNuUHJvcCIsIkFzblByb3BUeXBlcyIsInByb3RvdHlwZSIsIkFzblR5cGUiLCJBc25UeXBlVHlwZXMiLCJDaG9pY2UiLCJBbGdvcml0aG1JZGVudGlmaWVyIiwicGFyYW1zIiwiYXNzaWduIiwiQW55Iiwib3B0aW9uYWwiLCJQcml2YXRlS2V5SW5mbyIsInZlcnNpb24iLCJwcml2YXRlS2V5QWxnb3JpdGhtIiwiSW50ZWdlciIsIk9jdGV0U3RyaW5nIiwiUHVibGljS2V5SW5mbyIsInB1YmxpY0tleUFsZ29yaXRobSIsIkJpdFN0cmluZyIsIkpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciIsImZyb21KU09OIiwiRnJvbUJhc2U2NFVybCIsInRvSlNPTiIsIlRvQmFzZTY0VXJsIiwiQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIiwiZnJvbUFTTiIsInZhbHVlSGV4IiwidmFsdWVCbG9jayIsInRvQVNOIiwiY29tYmluZSIsImluZGV4JDMiLCJfX3Byb3RvX18iLCJSc2FQcml2YXRlS2V5IiwibW9kdWx1cyIsInByaXZhdGVFeHBvbmVudCIsInByaW1lMSIsInByaW1lMiIsImV4cG9uZW50MSIsImV4cG9uZW50MiIsImNvZWZmaWNpZW50IiwiY29udmVydGVyIiwiQXNuSW50ZWdlckNvbnZlcnRlciIsIkpzb25Qcm9wIiwiUnNhUHVibGljS2V5IiwiRWNQdWJsaWNLZXkiLCJzaXplIiwianNvbiIsIngiLCJ5IiwiRWNQcml2YXRlS2V5IiwiYXNuIiwiQXNuU2VyaWFsaXplciIsImp3ayIsImNvbnRleHQiLCJBc25JbnRlZ2VyV2l0aG91dFBhZGRpbmdDb252ZXJ0ZXIiLCJuZXdWYWx1ZSIsInNldCIsImluZGV4JDIiLCJFY1V0aWxzIiwiZGVjb2RlUG9pbnQiLCJwb2ludFNpemUiLCJ2aWV3IiwiTWF0aCIsImNlaWwiLCJ4YiIsInliIiwiZW5jb2RlUG9pbnQiLCJwb2ludCIsImdldFNpemUiLCJlbmNvZGVTaWduYXR1cmUiLCJyIiwicyIsInBhZFN0YXJ0IiwiZGVjb2RlU2lnbmF0dXJlIiwidHJpbVN0YXJ0IiwiaSIsIkVjRHNhU2lnbmF0dXJlIiwiZnJvbVdlYkNyeXB0b1NpZ25hdHVyZSIsImVjU2lnbmF0dXJlIiwidG9XZWJDcnlwdG9TaWduYXR1cmUiLCJtYXgiLCJPbmVBc3ltbWV0cmljS2V5IiwiaW1wbGljaXQiLCJFZFByaXZhdGVLZXkiLCJFZFB1YmxpY0tleSIsIkN1cnZlUHJpdmF0ZUtleSIsIkpzb25Qcm9wVHlwZXMiLCJTdHJpbmciLCJpZFNlY3AyNTZyMSIsImlkRWxsaXB0aWNDdXJ2ZSIsImlkU2VjcDM4NHIxIiwiaWRTZWNwNTIxcjEiLCJpZFNlY3AyNTZrMSIsImlkVmVyc2lvbk9uZSIsImlkQnJhaW5wb29sUDE2MHIxIiwiaWRCcmFpbnBvb2xQMTYwdDEiLCJpZEJyYWlucG9vbFAxOTJyMSIsImlkQnJhaW5wb29sUDE5MnQxIiwiaWRCcmFpbnBvb2xQMjI0cjEiLCJpZEJyYWlucG9vbFAyMjR0MSIsImlkQnJhaW5wb29sUDI1NnIxIiwiaWRCcmFpbnBvb2xQMjU2dDEiLCJpZEJyYWlucG9vbFAzMjByMSIsImlkQnJhaW5wb29sUDMyMHQxIiwiaWRCcmFpbnBvb2xQMzg0cjEiLCJpZEJyYWlucG9vbFAzODR0MSIsImlkQnJhaW5wb29sUDUxMnIxIiwiaWRCcmFpbnBvb2xQNTEydDEiLCJpZFgyNTUxOSIsImlkWDQ0OCIsImlkRWQyNTUxOSIsImlkRWQ0NDgiLCJpbmRleCQxIiwiY29udmVydGVycyIsIkVjQ3VydmVzIiwicmVnaXN0ZXIiLCJvaWQiLCJpZCIsInJhdyIsIkFzbkNvbnZlcnQiLCJzZXJpYWxpemUiLCJpdGVtcyIsIm5hbWVzIiwiZmluZCIsIm5hbWVPcklkIiwiSG1hY1Byb3ZpZGVyIiwiZ2V0RGVmYXVsdExlbmd0aCIsImFsZ05hbWUiLCJQYmtkZjJQcm92aWRlciIsInNhbHQiLCJpdGVyYXRpb25zIiwiU3ludGF4RXJyb3IiLCJIa2RmUHJvdmlkZXIiLCJpbmZvIiwiU2hha2VQcm92aWRlciIsImRlZmF1bHRMZW5ndGgiLCJTaGFrZTEyOFByb3ZpZGVyIiwiU2hha2UyNTZQcm92aWRlciIsIkNyeXB0byIsInJhbmRvbVVVSUQiLCJiIiwiZ2V0UmFuZG9tVmFsdWVzIiwidXVpZCIsIlRvSGV4Iiwic3Vic3RyaW5nIiwiUHJvdmlkZXJTdG9yYWdlIiwiYWxnb3JpdGhtTmFtZSIsInByb3ZpZGVyIiwicmVtb3ZlQXQiLCJoYXMiLCJhbGdvcml0aG1zIiwic29ydCIsIlN1YnRsZUNyeXB0byIsInByb3ZpZGVycyIsImlzSGFzaGVkQWxnb3JpdGhtIiwiY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyIsInByZXBhcmVkQWxnb3JpdGhtIiwicHJlcGFyZUFsZ29yaXRobSIsInByZXBhcmVkRGF0YSIsImdldFByb3ZpZGVyIiwicmVzdWx0IiwicHJlcGFyZWRTaWduYXR1cmUiLCJkZXJpdmVLZXkiLCJkZXJpdmVkS2V5VHlwZSIsInByZXBhcmVkRGVyaXZlZEtleVR5cGUiLCJpbXBvcnRQcm92aWRlciIsImRlcml2ZWRCaXRzIiwia3R5Iiwid3JhcEtleSIsIndyYXBwaW5nS2V5Iiwid3JhcEFsZ29yaXRobSIsIkpTT04iLCJzdHJpbmdpZnkiLCJGcm9tVXRmOFN0cmluZyIsInVud3JhcEtleSIsIndyYXBwZWRLZXkiLCJ1bndyYXBwaW5nS2V5IiwidW53cmFwQWxnb3JpdGhtIiwidW53cmFwcGVkS2V5QWxnb3JpdGhtIiwicGFyc2UiLCJUb1V0ZjhTdHJpbmciLCJlcnJvciIsImludGVybmFsIiwiaW5kZXgiLCJSRVFVSVJFRF9GSUVMRFMiLCJKd2tVdGlscyIsInRodW1icHJpbnQiLCJjcnlwdG8iLCJzdWJ0bGUiLCJGcm9tQmluYXJ5IiwicmVtb3ZlIiwiZW50cmllcyIsImZpbHRlciIsIm8iLCJpbmNsdWRlcyIsImtleUEiLCJrZXlCIiwiZnJvbUVudHJpZXMiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/webcrypto-core/build/webcrypto-core.js\n");

/***/ })

};
;